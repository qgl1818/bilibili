/*!
 *Last modified: 2023-03-15 19:24:18
 *Filename: ax.js
 *Description: Global JS
 *Version: v2.0.9
 *Website:www.axui.cn or ax.hobly.cn
 *Contact:3217728223@qq.com
 *Author:Michael
 */
/*!
 * Fuse.js v6.5.3 from https://github.com/krisk/Fuse  or http://fusejs.io | AXUI增加了window变量
 */
!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?module.exports=factory():"function"==typeof define&&define.amd?define(factory):(global=window||global||self).Fuse=factory()}(this,(function(){"use strict";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){_defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}function _typeof(obj){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj})(obj)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){return protoProps&&_defineProperties(Constructor.prototype,protoProps),staticProps&&_defineProperties(Constructor,staticProps),Object.defineProperty(Constructor,"prototype",{writable:!1}),Constructor}function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _inherits(subClass,superClass){if("function"!=typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function");Object.defineProperty(subClass,"prototype",{value:Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}}),writable:!1}),superClass&&_setPrototypeOf(subClass,superClass)}function _getPrototypeOf(o){return(_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o)})(o)}function _setPrototypeOf(o,p){return(_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){return o.__proto__=p,o})(o,p)}function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function _assertThisInitialized(self){if(void 0===self)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return self}function _possibleConstructorReturn(self,call){if(call&&("object"==typeof call||"function"==typeof call))return call;if(void 0!==call)throw new TypeError("Derived constructors may only return object or undefined");return _assertThisInitialized(self)}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget)}else result=Super.apply(this,arguments);return _possibleConstructorReturn(this,result)}}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_unsupportedIterableToArray(arr)||_nonIterableSpread()}function _arrayWithoutHoles(arr){if(Array.isArray(arr))return _arrayLikeToArray(arr)}function _iterableToArray(iter){if("undefined"!=typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}function _unsupportedIterableToArray(o,minLen){if(o){if("string"==typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray(o,minLen):void 0}}function _arrayLikeToArray(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function isArray(value){return Array.isArray?Array.isArray(value):"[object Array]"===getTag(value)}var INFINITY=1/0;function baseToString(value){if("string"==typeof value)return value;var result=value+"";return"0"==result&&1/value==-1/0?"-0":result}function toString(value){return null==value?"":baseToString(value)}function isString(value){return"string"==typeof value}function isNumber(value){return"number"==typeof value}function isBoolean(value){return!0===value||!1===value||isObjectLike(value)&&"[object Boolean]"==getTag(value)}function isObject(value){return"object"===_typeof(value)}function isObjectLike(value){return isObject(value)&&null!==value}function isDefined(value){return null!=value}function isBlank(value){return!value.trim().length}function getTag(value){return null==value?void 0===value?"[object Undefined]":"[object Null]":Object.prototype.toString.call(value)}var EXTENDED_SEARCH_UNAVAILABLE="Extended search is not available",INCORRECT_INDEX_TYPE="Incorrect 'index' type",LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY=function LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key){return"Invalid value for key ".concat(key)},PATTERN_LENGTH_TOO_LARGE=function PATTERN_LENGTH_TOO_LARGE(max){return"Pattern length exceeds max of ".concat(max,".")},MISSING_KEY_PROPERTY=function MISSING_KEY_PROPERTY(name){return"Missing ".concat(name," property in key")},INVALID_KEY_WEIGHT_VALUE=function INVALID_KEY_WEIGHT_VALUE(key){return"Property 'weight' in key '".concat(key,"' must be a positive integer")},hasOwn=Object.prototype.hasOwnProperty,KeyStore=function(){function KeyStore(keys){var _this=this;_classCallCheck(this,KeyStore),this._keys=[],this._keyMap={};var totalWeight=0;keys.forEach((function(key){var obj=createKey(key);totalWeight+=obj.weight,_this._keys.push(obj),_this._keyMap[obj.id]=obj,totalWeight+=obj.weight})),this._keys.forEach((function(key){key.weight/=totalWeight}))}return _createClass(KeyStore,[{key:"get",value:function get(keyId){return this._keyMap[keyId]}},{key:"keys",value:function keys(){return this._keys}},{key:"toJSON",value:function toJSON(){return JSON.stringify(this._keys)}}]),KeyStore}();function createKey(key){var path=null,id=null,src=null,weight=1;if(isString(key)||isArray(key))src=key,path=createKeyPath(key),id=createKeyId(key);else{if(!hasOwn.call(key,"name"))throw new Error(MISSING_KEY_PROPERTY("name"));var name=key.name;if(src=name,hasOwn.call(key,"weight")&&(weight=key.weight)<=0)throw new Error(INVALID_KEY_WEIGHT_VALUE(name));path=createKeyPath(name),id=createKeyId(name)}return{path:path,id:id,weight:weight,src:src}}function createKeyPath(key){return isArray(key)?key:key.split(".")}function createKeyId(key){return isArray(key)?key.join("."):key}function get(obj,path){var list=[],arr=!1,deepGet;return function deepGet(obj,path,index){if(isDefined(obj))if(path[index]){var key,value=obj[path[index]];if(!isDefined(value))return;if(index===path.length-1&&(isString(value)||isNumber(value)||isBoolean(value)))list.push(toString(value));else if(isArray(value)){arr=!0;for(var i=0,len=value.length;i<len;i+=1)deepGet(value[i],path,index+1)}else path.length&&deepGet(value,path,index+1)}else list.push(obj)}(obj,isString(path)?path.split("."):path,0),arr?list:list[0]}var MatchOptions={includeMatches:!1,findAllMatches:!1,minMatchCharLength:1},BasicOptions,FuzzyOptions={location:0,threshold:.6,distance:100},AdvancedOptions={useExtendedSearch:!1,getFn:get,ignoreLocation:!1,ignoreFieldNorm:!1,fieldNormWeight:1},Config=_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({},{isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:function sortFn(a,b){return a.score===b.score?a.idx<b.idx?-1:1:a.score<b.score?-1:1}}),MatchOptions),FuzzyOptions),AdvancedOptions),SPACE=/[^ ]+/g;function norm(){var weight=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,mantissa=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3,cache=new Map,m=Math.pow(10,mantissa);return{get:function get(value){var numTokens=value.match(SPACE).length;if(cache.has(numTokens))return cache.get(numTokens);var norm=1/Math.pow(numTokens,.5*weight),n=parseFloat(Math.round(norm*m)/m);return cache.set(numTokens,n),n},clear:function clear(){cache.clear()}}}var FuseIndex=function(){function FuseIndex(){var _ref=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},_ref$getFn=_ref.getFn,getFn=void 0===_ref$getFn?Config.getFn:_ref$getFn,_ref$fieldNormWeight=_ref.fieldNormWeight,fieldNormWeight=void 0===_ref$fieldNormWeight?Config.fieldNormWeight:_ref$fieldNormWeight;_classCallCheck(this,FuseIndex),this.norm=norm(fieldNormWeight,3),this.getFn=getFn,this.isCreated=!1,this.setIndexRecords()}return _createClass(FuseIndex,[{key:"setSources",value:function setSources(){var docs=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.docs=docs}},{key:"setIndexRecords",value:function setIndexRecords(){var records=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.records=records}},{key:"setKeys",value:function setKeys(){var _this=this,keys=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.keys=keys,this._keysMap={},keys.forEach((function(key,idx){_this._keysMap[key.id]=idx}))}},{key:"create",value:function create(){var _this2=this;!this.isCreated&&this.docs.length&&(this.isCreated=!0,isString(this.docs[0])?this.docs.forEach((function(doc,docIndex){_this2._addString(doc,docIndex)})):this.docs.forEach((function(doc,docIndex){_this2._addObject(doc,docIndex)})),this.norm.clear())}},{key:"add",value:function add(doc){var idx=this.size();isString(doc)?this._addString(doc,idx):this._addObject(doc,idx)}},{key:"removeAt",value:function removeAt(idx){this.records.splice(idx,1);for(var i=idx,len=this.size();i<len;i+=1)this.records[i].i-=1}},{key:"getValueForItemAtKeyId",value:function getValueForItemAtKeyId(item,keyId){return item[this._keysMap[keyId]]}},{key:"size",value:function size(){return this.records.length}},{key:"_addString",value:function _addString(doc,docIndex){if(isDefined(doc)&&!isBlank(doc)){var record={v:doc,i:docIndex,n:this.norm.get(doc)};this.records.push(record)}}},{key:"_addObject",value:function _addObject(doc,docIndex){var _this3=this,record={i:docIndex,$:{}};this.keys.forEach((function(key,keyIndex){var value=_this3.getFn(doc,key.path);if(isDefined(value))if(isArray(value))!function(){for(var subRecords=[],stack=[{nestedArrIndex:-1,value:value}];stack.length;){var _stack$pop=stack.pop(),nestedArrIndex=_stack$pop.nestedArrIndex,_value=_stack$pop.value;if(isDefined(_value))if(isString(_value)&&!isBlank(_value)){var subRecord={v:_value,i:nestedArrIndex,n:_this3.norm.get(_value)};subRecords.push(subRecord)}else isArray(_value)&&_value.forEach((function(item,k){stack.push({nestedArrIndex:k,value:item})}))}record.$[keyIndex]=subRecords}();else if(!isBlank(value)){var subRecord={v:value,n:_this3.norm.get(value)};record.$[keyIndex]=subRecord}})),this.records.push(record)}},{key:"toJSON",value:function toJSON(){return{keys:this.keys,records:this.records}}}]),FuseIndex}();function createIndex(keys,docs){var _ref2=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},_ref2$getFn=_ref2.getFn,getFn=void 0===_ref2$getFn?Config.getFn:_ref2$getFn,_ref2$fieldNormWeight=_ref2.fieldNormWeight,fieldNormWeight=void 0===_ref2$fieldNormWeight?Config.fieldNormWeight:_ref2$fieldNormWeight,myIndex=new FuseIndex({getFn:getFn,fieldNormWeight:fieldNormWeight});return myIndex.setKeys(keys.map(createKey)),myIndex.setSources(docs),myIndex.create(),myIndex}function parseIndex(data){var _ref3=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref3$getFn=_ref3.getFn,getFn=void 0===_ref3$getFn?Config.getFn:_ref3$getFn,_ref3$fieldNormWeight=_ref3.fieldNormWeight,fieldNormWeight=void 0===_ref3$fieldNormWeight?Config.fieldNormWeight:_ref3$fieldNormWeight,keys=data.keys,records=data.records,myIndex=new FuseIndex({getFn:getFn,fieldNormWeight:fieldNormWeight});return myIndex.setKeys(keys),myIndex.setIndexRecords(records),myIndex}function computeScore$1(pattern){var _ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$errors=_ref.errors,errors=void 0===_ref$errors?0:_ref$errors,_ref$currentLocation=_ref.currentLocation,currentLocation=void 0===_ref$currentLocation?0:_ref$currentLocation,_ref$expectedLocation=_ref.expectedLocation,expectedLocation=void 0===_ref$expectedLocation?0:_ref$expectedLocation,_ref$distance=_ref.distance,distance=void 0===_ref$distance?Config.distance:_ref$distance,_ref$ignoreLocation=_ref.ignoreLocation,ignoreLocation=void 0===_ref$ignoreLocation?Config.ignoreLocation:_ref$ignoreLocation,accuracy=errors/pattern.length;if(ignoreLocation)return accuracy;var proximity=Math.abs(expectedLocation-currentLocation);return distance?accuracy+proximity/distance:proximity?1:accuracy}function convertMaskToIndices(){for(var matchmask=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],minMatchCharLength=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Config.minMatchCharLength,indices=[],start=-1,end=-1,i=0,len=matchmask.length;i<len;i+=1){var match=matchmask[i];match&&-1===start?start=i:match||-1===start||((end=i-1)-start+1>=minMatchCharLength&&indices.push([start,end]),start=-1)}return matchmask[i-1]&&i-start>=minMatchCharLength&&indices.push([start,i-1]),indices}var MAX_BITS=32;function search(text,pattern,patternAlphabet){var _ref=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},_ref$location=_ref.location,location=void 0===_ref$location?Config.location:_ref$location,_ref$distance=_ref.distance,distance=void 0===_ref$distance?Config.distance:_ref$distance,_ref$threshold=_ref.threshold,threshold=void 0===_ref$threshold?Config.threshold:_ref$threshold,_ref$findAllMatches=_ref.findAllMatches,findAllMatches=void 0===_ref$findAllMatches?Config.findAllMatches:_ref$findAllMatches,_ref$minMatchCharLeng=_ref.minMatchCharLength,minMatchCharLength=void 0===_ref$minMatchCharLeng?Config.minMatchCharLength:_ref$minMatchCharLeng,_ref$includeMatches=_ref.includeMatches,includeMatches=void 0===_ref$includeMatches?Config.includeMatches:_ref$includeMatches,_ref$ignoreLocation=_ref.ignoreLocation,ignoreLocation=void 0===_ref$ignoreLocation?Config.ignoreLocation:_ref$ignoreLocation;if(pattern.length>32)throw new Error(PATTERN_LENGTH_TOO_LARGE(32));for(var patternLen=pattern.length,textLen=text.length,expectedLocation=Math.max(0,Math.min(location,textLen)),currentThreshold=threshold,bestLocation=expectedLocation,computeMatches=minMatchCharLength>1||includeMatches,matchMask=computeMatches?Array(textLen):[],index;(index=text.indexOf(pattern,bestLocation))>-1;){var score=computeScore$1(pattern,{currentLocation:index,expectedLocation:expectedLocation,distance:distance,ignoreLocation:ignoreLocation});if(currentThreshold=Math.min(score,currentThreshold),bestLocation=index+patternLen,computeMatches)for(var i=0;i<patternLen;)matchMask[index+i]=1,i+=1}bestLocation=-1;for(var lastBitArr=[],finalScore=1,binMax=patternLen+textLen,mask=1<<patternLen-1,_i=0;_i<patternLen;_i+=1){for(var binMin=0,binMid=binMax;binMin<binMid;){var _score2=computeScore$1(pattern,{errors:_i,currentLocation:expectedLocation+binMid,expectedLocation:expectedLocation,distance:distance,ignoreLocation:ignoreLocation});_score2<=currentThreshold?binMin=binMid:binMax=binMid,binMid=Math.floor((binMax-binMin)/2+binMin)}binMax=binMid;var start=Math.max(1,expectedLocation-binMid+1),finish=findAllMatches?textLen:Math.min(expectedLocation+binMid,textLen)+patternLen,bitArr=Array(finish+2);bitArr[finish+1]=(1<<_i)-1;for(var j=finish;j>=start;j-=1){var currentLocation=j-1,charMatch=patternAlphabet[text.charAt(currentLocation)];if(computeMatches&&(matchMask[currentLocation]=+!!charMatch),bitArr[j]=(bitArr[j+1]<<1|1)&charMatch,_i&&(bitArr[j]|=(lastBitArr[j+1]|lastBitArr[j])<<1|1|lastBitArr[j+1]),bitArr[j]&mask&&(finalScore=computeScore$1(pattern,{errors:_i,currentLocation:currentLocation,expectedLocation:expectedLocation,distance:distance,ignoreLocation:ignoreLocation}))<=currentThreshold){if(currentThreshold=finalScore,(bestLocation=currentLocation)<=expectedLocation)break;start=Math.max(1,2*expectedLocation-bestLocation)}}var _score=computeScore$1(pattern,{errors:_i+1,currentLocation:expectedLocation,expectedLocation:expectedLocation,distance:distance,ignoreLocation:ignoreLocation});if(_score>currentThreshold)break;lastBitArr=bitArr}var result={isMatch:bestLocation>=0,score:Math.max(.001,finalScore)};if(computeMatches){var indices=convertMaskToIndices(matchMask,minMatchCharLength);indices.length?includeMatches&&(result.indices=indices):result.isMatch=!1}return result}function createPatternAlphabet(pattern){for(var mask={},i=0,len=pattern.length;i<len;i+=1){var _char=pattern.charAt(i);mask[_char]=(mask[_char]||0)|1<<len-i-1}return mask}var BitapSearch=function(){function BitapSearch(pattern){var _this=this,_ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$location=_ref.location,location=void 0===_ref$location?Config.location:_ref$location,_ref$threshold=_ref.threshold,threshold=void 0===_ref$threshold?Config.threshold:_ref$threshold,_ref$distance=_ref.distance,distance=void 0===_ref$distance?Config.distance:_ref$distance,_ref$includeMatches=_ref.includeMatches,includeMatches=void 0===_ref$includeMatches?Config.includeMatches:_ref$includeMatches,_ref$findAllMatches=_ref.findAllMatches,findAllMatches=void 0===_ref$findAllMatches?Config.findAllMatches:_ref$findAllMatches,_ref$minMatchCharLeng=_ref.minMatchCharLength,minMatchCharLength=void 0===_ref$minMatchCharLeng?Config.minMatchCharLength:_ref$minMatchCharLeng,_ref$isCaseSensitive=_ref.isCaseSensitive,isCaseSensitive=void 0===_ref$isCaseSensitive?Config.isCaseSensitive:_ref$isCaseSensitive,_ref$ignoreLocation=_ref.ignoreLocation,ignoreLocation=void 0===_ref$ignoreLocation?Config.ignoreLocation:_ref$ignoreLocation;if(_classCallCheck(this,BitapSearch),this.options={location:location,threshold:threshold,distance:distance,includeMatches:includeMatches,findAllMatches:findAllMatches,minMatchCharLength:minMatchCharLength,isCaseSensitive:isCaseSensitive,ignoreLocation:ignoreLocation},this.pattern=isCaseSensitive?pattern:pattern.toLowerCase(),this.chunks=[],this.pattern.length){var addChunk=function addChunk(pattern,startIndex){_this.chunks.push({pattern:pattern,alphabet:createPatternAlphabet(pattern),startIndex:startIndex})},len=this.pattern.length;if(len>32){for(var i=0,remainder=len%32,end=len-remainder;i<end;)addChunk(this.pattern.substr(i,32),i),i+=32;if(remainder){var startIndex=len-32;addChunk(this.pattern.substr(startIndex),startIndex)}}else addChunk(this.pattern,0)}}return _createClass(BitapSearch,[{key:"searchIn",value:function searchIn(text){var _this$options=this.options,isCaseSensitive=_this$options.isCaseSensitive,includeMatches=_this$options.includeMatches;if(isCaseSensitive||(text=text.toLowerCase()),this.pattern===text){var _result={isMatch:!0,score:0};return includeMatches&&(_result.indices=[[0,text.length-1]]),_result}var _this$options2=this.options,location=_this$options2.location,distance=_this$options2.distance,threshold=_this$options2.threshold,findAllMatches=_this$options2.findAllMatches,minMatchCharLength=_this$options2.minMatchCharLength,ignoreLocation=_this$options2.ignoreLocation,allIndices=[],totalScore=0,hasMatches=!1;this.chunks.forEach((function(_ref2){var pattern=_ref2.pattern,alphabet=_ref2.alphabet,startIndex=_ref2.startIndex,_search=search(text,pattern,alphabet,{location:location+startIndex,distance:distance,threshold:threshold,findAllMatches:findAllMatches,minMatchCharLength:minMatchCharLength,includeMatches:includeMatches,ignoreLocation:ignoreLocation}),isMatch=_search.isMatch,score=_search.score,indices=_search.indices;isMatch&&(hasMatches=!0),totalScore+=score,isMatch&&indices&&(allIndices=[].concat(_toConsumableArray(allIndices),_toConsumableArray(indices)))}));var result={isMatch:hasMatches,score:hasMatches?totalScore/this.chunks.length:1};return hasMatches&&includeMatches&&(result.indices=allIndices),result}}]),BitapSearch}(),BaseMatch=function(){function BaseMatch(pattern){_classCallCheck(this,BaseMatch),this.pattern=pattern}return _createClass(BaseMatch,[{key:"search",value:function search(){}}],[{key:"isMultiMatch",value:function isMultiMatch(pattern){return getMatch(pattern,this.multiRegex)}},{key:"isSingleMatch",value:function isSingleMatch(pattern){return getMatch(pattern,this.singleRegex)}}]),BaseMatch}();function getMatch(pattern,exp){var matches=pattern.match(exp);return matches?matches[1]:null}var ExactMatch=function(_BaseMatch){_inherits(ExactMatch,_BaseMatch);var _super=_createSuper(ExactMatch);function ExactMatch(pattern){return _classCallCheck(this,ExactMatch),_super.call(this,pattern)}return _createClass(ExactMatch,[{key:"search",value:function search(text){var isMatch=text===this.pattern;return{isMatch:isMatch,score:isMatch?0:1,indices:[0,this.pattern.length-1]}}}],[{key:"type",get:function get(){return"exact"}},{key:"multiRegex",get:function get(){return/^="(.*)"$/}},{key:"singleRegex",get:function get(){return/^=(.*)$/}}]),ExactMatch}(BaseMatch),InverseExactMatch=function(_BaseMatch){_inherits(InverseExactMatch,_BaseMatch);var _super=_createSuper(InverseExactMatch);function InverseExactMatch(pattern){return _classCallCheck(this,InverseExactMatch),_super.call(this,pattern)}return _createClass(InverseExactMatch,[{key:"search",value:function search(text){var index,isMatch=-1===text.indexOf(this.pattern);return{isMatch:isMatch,score:isMatch?0:1,indices:[0,text.length-1]}}}],[{key:"type",get:function get(){return"inverse-exact"}},{key:"multiRegex",get:function get(){return/^!"(.*)"$/}},{key:"singleRegex",get:function get(){return/^!(.*)$/}}]),InverseExactMatch}(BaseMatch),PrefixExactMatch=function(_BaseMatch){_inherits(PrefixExactMatch,_BaseMatch);var _super=_createSuper(PrefixExactMatch);function PrefixExactMatch(pattern){return _classCallCheck(this,PrefixExactMatch),_super.call(this,pattern)}return _createClass(PrefixExactMatch,[{key:"search",value:function search(text){var isMatch=text.startsWith(this.pattern);return{isMatch:isMatch,score:isMatch?0:1,indices:[0,this.pattern.length-1]}}}],[{key:"type",get:function get(){return"prefix-exact"}},{key:"multiRegex",get:function get(){return/^\^"(.*)"$/}},{key:"singleRegex",get:function get(){return/^\^(.*)$/}}]),PrefixExactMatch}(BaseMatch),InversePrefixExactMatch=function(_BaseMatch){_inherits(InversePrefixExactMatch,_BaseMatch);var _super=_createSuper(InversePrefixExactMatch);function InversePrefixExactMatch(pattern){return _classCallCheck(this,InversePrefixExactMatch),_super.call(this,pattern)}return _createClass(InversePrefixExactMatch,[{key:"search",value:function search(text){var isMatch=!text.startsWith(this.pattern);return{isMatch:isMatch,score:isMatch?0:1,indices:[0,text.length-1]}}}],[{key:"type",get:function get(){return"inverse-prefix-exact"}},{key:"multiRegex",get:function get(){return/^!\^"(.*)"$/}},{key:"singleRegex",get:function get(){return/^!\^(.*)$/}}]),InversePrefixExactMatch}(BaseMatch),SuffixExactMatch=function(_BaseMatch){_inherits(SuffixExactMatch,_BaseMatch);var _super=_createSuper(SuffixExactMatch);function SuffixExactMatch(pattern){return _classCallCheck(this,SuffixExactMatch),_super.call(this,pattern)}return _createClass(SuffixExactMatch,[{key:"search",value:function search(text){var isMatch=text.endsWith(this.pattern);return{isMatch:isMatch,score:isMatch?0:1,indices:[text.length-this.pattern.length,text.length-1]}}}],[{key:"type",get:function get(){return"suffix-exact"}},{key:"multiRegex",get:function get(){return/^"(.*)"\$$/}},{key:"singleRegex",get:function get(){return/^(.*)\$$/}}]),SuffixExactMatch}(BaseMatch),InverseSuffixExactMatch=function(_BaseMatch){_inherits(InverseSuffixExactMatch,_BaseMatch);var _super=_createSuper(InverseSuffixExactMatch);function InverseSuffixExactMatch(pattern){return _classCallCheck(this,InverseSuffixExactMatch),_super.call(this,pattern)}return _createClass(InverseSuffixExactMatch,[{key:"search",value:function search(text){var isMatch=!text.endsWith(this.pattern);return{isMatch:isMatch,score:isMatch?0:1,indices:[0,text.length-1]}}}],[{key:"type",get:function get(){return"inverse-suffix-exact"}},{key:"multiRegex",get:function get(){return/^!"(.*)"\$$/}},{key:"singleRegex",get:function get(){return/^!(.*)\$$/}}]),InverseSuffixExactMatch}(BaseMatch),FuzzyMatch=function(_BaseMatch){_inherits(FuzzyMatch,_BaseMatch);var _super=_createSuper(FuzzyMatch);function FuzzyMatch(pattern){var _this,_ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$location=_ref.location,location=void 0===_ref$location?Config.location:_ref$location,_ref$threshold=_ref.threshold,threshold=void 0===_ref$threshold?Config.threshold:_ref$threshold,_ref$distance=_ref.distance,distance=void 0===_ref$distance?Config.distance:_ref$distance,_ref$includeMatches=_ref.includeMatches,includeMatches=void 0===_ref$includeMatches?Config.includeMatches:_ref$includeMatches,_ref$findAllMatches=_ref.findAllMatches,findAllMatches=void 0===_ref$findAllMatches?Config.findAllMatches:_ref$findAllMatches,_ref$minMatchCharLeng=_ref.minMatchCharLength,minMatchCharLength=void 0===_ref$minMatchCharLeng?Config.minMatchCharLength:_ref$minMatchCharLeng,_ref$isCaseSensitive=_ref.isCaseSensitive,isCaseSensitive=void 0===_ref$isCaseSensitive?Config.isCaseSensitive:_ref$isCaseSensitive,_ref$ignoreLocation=_ref.ignoreLocation,ignoreLocation=void 0===_ref$ignoreLocation?Config.ignoreLocation:_ref$ignoreLocation;return _classCallCheck(this,FuzzyMatch),(_this=_super.call(this,pattern))._bitapSearch=new BitapSearch(pattern,{location:location,threshold:threshold,distance:distance,includeMatches:includeMatches,findAllMatches:findAllMatches,minMatchCharLength:minMatchCharLength,isCaseSensitive:isCaseSensitive,ignoreLocation:ignoreLocation}),_this}return _createClass(FuzzyMatch,[{key:"search",value:function search(text){return this._bitapSearch.searchIn(text)}}],[{key:"type",get:function get(){return"fuzzy"}},{key:"multiRegex",get:function get(){return/^"(.*)"$/}},{key:"singleRegex",get:function get(){return/^(.*)$/}}]),FuzzyMatch}(BaseMatch),IncludeMatch=function(_BaseMatch){_inherits(IncludeMatch,_BaseMatch);var _super=_createSuper(IncludeMatch);function IncludeMatch(pattern){return _classCallCheck(this,IncludeMatch),_super.call(this,pattern)}return _createClass(IncludeMatch,[{key:"search",value:function search(text){for(var location=0,index,indices=[],patternLen=this.pattern.length;(index=text.indexOf(this.pattern,location))>-1;)location=index+patternLen,indices.push([index,location-1]);var isMatch=!!indices.length;return{isMatch:isMatch,score:isMatch?0:1,indices:indices}}}],[{key:"type",get:function get(){return"include"}},{key:"multiRegex",get:function get(){return/^'"(.*)"$/}},{key:"singleRegex",get:function get(){return/^'(.*)$/}}]),IncludeMatch}(BaseMatch),searchers=[ExactMatch,IncludeMatch,PrefixExactMatch,InversePrefixExactMatch,InverseSuffixExactMatch,SuffixExactMatch,InverseExactMatch,FuzzyMatch],searchersLen=searchers.length,SPACE_RE=/ +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/,OR_TOKEN="|";function parseQuery(pattern){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return pattern.split("|").map((function(item){for(var query=item.trim().split(SPACE_RE).filter((function(item){return item&&!!item.trim()})),results=[],i=0,len=query.length;i<len;i+=1){for(var queryItem=query[i],found=!1,idx=-1;!found&&++idx<searchersLen;){var searcher=searchers[idx],token=searcher.isMultiMatch(queryItem);token&&(results.push(new searcher(token,options)),found=!0)}if(!found)for(idx=-1;++idx<searchersLen;){var _searcher=searchers[idx],_token=_searcher.isSingleMatch(queryItem);if(_token){results.push(new _searcher(_token,options));break}}}return results}))}var MultiMatchSet=new Set([FuzzyMatch.type,IncludeMatch.type]),ExtendedSearch=function(){function ExtendedSearch(pattern){var _ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$isCaseSensitive=_ref.isCaseSensitive,isCaseSensitive=void 0===_ref$isCaseSensitive?Config.isCaseSensitive:_ref$isCaseSensitive,_ref$includeMatches=_ref.includeMatches,includeMatches=void 0===_ref$includeMatches?Config.includeMatches:_ref$includeMatches,_ref$minMatchCharLeng=_ref.minMatchCharLength,minMatchCharLength=void 0===_ref$minMatchCharLeng?Config.minMatchCharLength:_ref$minMatchCharLeng,_ref$ignoreLocation=_ref.ignoreLocation,ignoreLocation=void 0===_ref$ignoreLocation?Config.ignoreLocation:_ref$ignoreLocation,_ref$findAllMatches=_ref.findAllMatches,findAllMatches=void 0===_ref$findAllMatches?Config.findAllMatches:_ref$findAllMatches,_ref$location=_ref.location,location=void 0===_ref$location?Config.location:_ref$location,_ref$threshold=_ref.threshold,threshold=void 0===_ref$threshold?Config.threshold:_ref$threshold,_ref$distance=_ref.distance,distance=void 0===_ref$distance?Config.distance:_ref$distance;_classCallCheck(this,ExtendedSearch),this.query=null,this.options={isCaseSensitive:isCaseSensitive,includeMatches:includeMatches,minMatchCharLength:minMatchCharLength,findAllMatches:findAllMatches,ignoreLocation:ignoreLocation,location:location,threshold:threshold,distance:distance},this.pattern=isCaseSensitive?pattern:pattern.toLowerCase(),this.query=parseQuery(this.pattern,this.options)}return _createClass(ExtendedSearch,[{key:"searchIn",value:function searchIn(text){var query=this.query;if(!query)return{isMatch:!1,score:1};var _this$options=this.options,includeMatches=_this$options.includeMatches,isCaseSensitive;text=_this$options.isCaseSensitive?text:text.toLowerCase();for(var numMatches=0,allIndices=[],totalScore=0,i=0,qLen=query.length;i<qLen;i+=1){var searchers=query[i];allIndices.length=0,numMatches=0;for(var j=0,pLen=searchers.length;j<pLen;j+=1){var searcher=searchers[j],_searcher$search=searcher.search(text),isMatch=_searcher$search.isMatch,indices=_searcher$search.indices,score=_searcher$search.score;if(!isMatch){totalScore=0,numMatches=0,allIndices.length=0;break}if(numMatches+=1,totalScore+=score,includeMatches){var type=searcher.constructor.type;MultiMatchSet.has(type)?allIndices=[].concat(_toConsumableArray(allIndices),_toConsumableArray(indices)):allIndices.push(indices)}}if(numMatches){var result={isMatch:!0,score:totalScore/numMatches};return includeMatches&&(result.indices=allIndices),result}}return{isMatch:!1,score:1}}}],[{key:"condition",value:function condition(_,options){return options.useExtendedSearch}}]),ExtendedSearch}(),registeredSearchers=[];function register(){registeredSearchers.push.apply(registeredSearchers,arguments)}function createSearcher(pattern,options){for(var i=0,len=registeredSearchers.length;i<len;i+=1){var searcherClass=registeredSearchers[i];if(searcherClass.condition(pattern,options))return new searcherClass(pattern,options)}return new BitapSearch(pattern,options)}var LogicalOperator_AND="$and",LogicalOperator_OR="$or",KeyType_PATH="$path",KeyType_PATTERN="$val",isExpression=function isExpression(query){return!(!query[LogicalOperator_AND]&&!query[LogicalOperator_OR])},isPath=function isPath(query){return!!query[KeyType_PATH]},isLeaf=function isLeaf(query){return!isArray(query)&&isObject(query)&&!isExpression(query)},convertToExplicit=function convertToExplicit(query){return _defineProperty({},LogicalOperator_AND,Object.keys(query).map((function(key){return _defineProperty({},key,query[key])})))};function parse(query,options){var _ref3=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},_ref3$auto=_ref3.auto,auto=void 0===_ref3$auto||_ref3$auto,next=function next(query){var keys=Object.keys(query),isQueryPath=isPath(query);if(!isQueryPath&&keys.length>1&&!isExpression(query))return next(convertToExplicit(query));if(isLeaf(query)){var key=isQueryPath?query[KeyType_PATH]:keys[0],pattern=isQueryPath?query[KeyType_PATTERN]:query[key];if(!isString(pattern))throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));var obj={keyId:createKeyId(key),pattern:pattern};return auto&&(obj.searcher=createSearcher(pattern,options)),obj}var node={children:[],operator:keys[0]};return keys.forEach((function(key){var value=query[key];isArray(value)&&value.forEach((function(item){node.children.push(next(item))}))})),node};return isExpression(query)||(query=convertToExplicit(query)),next(query)}function computeScore(results,_ref){var _ref$ignoreFieldNorm=_ref.ignoreFieldNorm,ignoreFieldNorm=void 0===_ref$ignoreFieldNorm?Config.ignoreFieldNorm:_ref$ignoreFieldNorm;results.forEach((function(result){var totalScore=1;result.matches.forEach((function(_ref2){var key=_ref2.key,norm=_ref2.norm,score=_ref2.score,weight=key?key.weight:null;totalScore*=Math.pow(0===score&&weight?Number.EPSILON:score,(weight||1)*(ignoreFieldNorm?1:norm))})),result.score=totalScore}))}function transformMatches(result,data){var matches=result.matches;data.matches=[],isDefined(matches)&&matches.forEach((function(match){if(isDefined(match.indices)&&match.indices.length){var indices,value,obj={indices:match.indices,value:match.value};match.key&&(obj.key=match.key.src),match.idx>-1&&(obj.refIndex=match.idx),data.matches.push(obj)}}))}function transformScore(result,data){data.score=result.score}function format(results,docs){var _ref=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},_ref$includeMatches=_ref.includeMatches,includeMatches=void 0===_ref$includeMatches?Config.includeMatches:_ref$includeMatches,_ref$includeScore=_ref.includeScore,includeScore=void 0===_ref$includeScore?Config.includeScore:_ref$includeScore,transformers=[];return includeMatches&&transformers.push(transformMatches),includeScore&&transformers.push(transformScore),results.map((function(result){var idx=result.idx,data={item:docs[idx],refIndex:idx};return transformers.length&&transformers.forEach((function(transformer){transformer(result,data)})),data}))}var Fuse$1=function(){function Fuse(docs){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},index=arguments.length>2?arguments[2]:void 0;_classCallCheck(this,Fuse),this.options=_objectSpread2(_objectSpread2({},Config),options),this.options.useExtendedSearch,this._keyStore=new KeyStore(this.options.keys),this.setCollection(docs,index)}return _createClass(Fuse,[{key:"setCollection",value:function setCollection(docs,index){if(this._docs=docs,index&&!(index instanceof FuseIndex))throw new Error(INCORRECT_INDEX_TYPE);this._myIndex=index||createIndex(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}},{key:"add",value:function add(doc){isDefined(doc)&&(this._docs.push(doc),this._myIndex.add(doc))}},{key:"remove",value:function remove(){for(var predicate=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){return!1},results=[],i=0,len=this._docs.length;i<len;i+=1){var doc=this._docs[i];predicate(doc,i)&&(this.removeAt(i),i-=1,len-=1,results.push(doc))}return results}},{key:"removeAt",value:function removeAt(idx){this._docs.splice(idx,1),this._myIndex.removeAt(idx)}},{key:"getIndex",value:function getIndex(){return this._myIndex}},{key:"search",value:function search(query){var _ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$limit=_ref.limit,limit=void 0===_ref$limit?-1:_ref$limit,_this$options=this.options,includeMatches=_this$options.includeMatches,includeScore=_this$options.includeScore,shouldSort=_this$options.shouldSort,sortFn=_this$options.sortFn,ignoreFieldNorm=_this$options.ignoreFieldNorm,results=isString(query)?isString(this._docs[0])?this._searchStringList(query):this._searchObjectList(query):this._searchLogical(query);return computeScore(results,{ignoreFieldNorm:ignoreFieldNorm}),shouldSort&&results.sort(sortFn),isNumber(limit)&&limit>-1&&(results=results.slice(0,limit)),format(results,this._docs,{includeMatches:includeMatches,includeScore:includeScore})}},{key:"_searchStringList",value:function _searchStringList(query){var searcher=createSearcher(query,this.options),records=this._myIndex.records,results=[];return records.forEach((function(_ref2){var text=_ref2.v,idx=_ref2.i,norm=_ref2.n;if(isDefined(text)){var _searcher$searchIn=searcher.searchIn(text),isMatch=_searcher$searchIn.isMatch,score=_searcher$searchIn.score,indices=_searcher$searchIn.indices;isMatch&&results.push({item:text,idx:idx,matches:[{score:score,value:text,norm:norm,indices:indices}]})}})),results}},{key:"_searchLogical",value:function _searchLogical(query){var _this=this,expression=parse(query,this.options),evaluate=function evaluate(node,item,idx){if(!node.children){var keyId=node.keyId,searcher=node.searcher,matches=_this._findMatches({key:_this._keyStore.get(keyId),value:_this._myIndex.getValueForItemAtKeyId(item,keyId),searcher:searcher});return matches&&matches.length?[{idx:idx,item:item,matches:matches}]:[]}for(var res=[],i=0,len=node.children.length;i<len;i+=1){var child,result=evaluate(node.children[i],item,idx);if(result.length)res.push.apply(res,_toConsumableArray(result));else if(node.operator===LogicalOperator_AND)return[]}return res},records=this._myIndex.records,resultMap={},results=[];return records.forEach((function(_ref3){var item=_ref3.$,idx=_ref3.i;if(isDefined(item)){var expResults=evaluate(expression,item,idx);expResults.length&&(resultMap[idx]||(resultMap[idx]={idx:idx,item:item,matches:[]},results.push(resultMap[idx])),expResults.forEach((function(_ref4){var _resultMap$idx$matche,matches=_ref4.matches;(_resultMap$idx$matche=resultMap[idx].matches).push.apply(_resultMap$idx$matche,_toConsumableArray(matches))})))}})),results}},{key:"_searchObjectList",value:function _searchObjectList(query){var _this2=this,searcher=createSearcher(query,this.options),_this$_myIndex=this._myIndex,keys=_this$_myIndex.keys,records=_this$_myIndex.records,results=[];return records.forEach((function(_ref5){var item=_ref5.$,idx=_ref5.i;if(isDefined(item)){var matches=[];keys.forEach((function(key,keyIndex){matches.push.apply(matches,_toConsumableArray(_this2._findMatches({key:key,value:item[keyIndex],searcher:searcher})))})),matches.length&&results.push({idx:idx,item:item,matches:matches})}})),results}},{key:"_findMatches",value:function _findMatches(_ref6){var key=_ref6.key,value=_ref6.value,searcher=_ref6.searcher;if(!isDefined(value))return[];var matches=[];if(isArray(value))value.forEach((function(_ref7){var text=_ref7.v,idx=_ref7.i,norm=_ref7.n;if(isDefined(text)){var _searcher$searchIn2=searcher.searchIn(text),isMatch=_searcher$searchIn2.isMatch,score=_searcher$searchIn2.score,indices=_searcher$searchIn2.indices;isMatch&&matches.push({score:score,key:key,value:text,idx:idx,norm:norm,indices:indices})}}));else{var text=value.v,norm=value.n,_searcher$searchIn3=searcher.searchIn(text),isMatch=_searcher$searchIn3.isMatch,score=_searcher$searchIn3.score,indices=_searcher$searchIn3.indices;isMatch&&matches.push({score:score,key:key,value:text,norm:norm,indices:indices})}return matches}}]),Fuse}(),Fuse;return Fuse$1.version="6.5.3",Fuse$1.createIndex=createIndex,Fuse$1.parseIndex=parseIndex,Fuse$1.config=Config,Fuse$1.parseQuery=parse,register(ExtendedSearch),Fuse$1}));
/*!
 * redux v4.1.2 from https://redux.js.org  |  AXUI增加了window变量，取消了isCrushed函数
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e=window||e||self).Redux={})}(this,(function(e){"use strict";var t="function"==typeof Symbol&&Symbol.observable||"@@observable",r=function(){return Math.random().toString(36).substring(7).split("").join(".")},n={INIT:"@@redux/INIT"+r(),REPLACE:"@@redux/REPLACE"+r(),PROBE_UNKNOWN_ACTION:function(){return"@@redux/PROBE_UNKNOWN_ACTION"+r()}};function o(e){if("object"!=typeof e||null===e)return!1;for(var t=e;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}function i(e){if(void 0===e)return"undefined";if(null===e)return"null";var t=typeof e;switch(t){case"boolean":case"string":case"number":case"symbol":case"function":return t}if(Array.isArray(e))return"array";if(function(e){return e instanceof Date||"function"==typeof e.toDateString&&"function"==typeof e.getDate&&"function"==typeof e.setDate}(e))return"date";if(function(e){return e instanceof Error||"string"==typeof e.message&&e.constructor&&"number"==typeof e.constructor.stackTraceLimit}(e))return"error";var r=function(e){return"function"==typeof e.constructor?e.constructor.name:null}(e);switch(r){case"Symbol":case"Promise":case"WeakMap":case"WeakSet":case"Map":case"Set":return r}return t.slice(8,-1).toLowerCase().replace(/\s/g,"")}function u(e){return i(e)}function a(e){"undefined"!=typeof console&&"function"==typeof console.error&&console.error(e);try{throw new Error(e)}catch(e){}}function c(e,t){return function(){return t(e.apply(this,arguments))}}function s(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function f(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function d(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?f(Object(r),!0).forEach((function(t){s(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):f(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return 0===t.length?function(e){return e}:1===t.length?t[0]:t.reduce((function(e,t){return function(){return e(t.apply(void 0,arguments))}}))}function p(){}"string"==typeof p.name&&p.name,e.__DO_NOT_USE__ActionTypes=n,e.applyMiddleware=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return function(e){return function(){var r=e.apply(void 0,arguments),n=function(){throw new Error("Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.")},o={getState:r.getState,dispatch:function(){return n.apply(void 0,arguments)}},i=t.map((function(e){return e(o)}));return n=l.apply(void 0,i)(r.dispatch),d(d({},r),{},{dispatch:n})}}},e.bindActionCreators=function(e,t){if("function"==typeof e)return c(e,t);if("object"!=typeof e||null===e)throw new Error("bindActionCreators expected an object or a function, but instead received: '"+u(e)+'\'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');var r={};for(var n in e){var o=e[n];"function"==typeof o&&(r[n]=c(o,t))}return r},e.combineReducers=function(e){for(var t=Object.keys(e),r={},i=0;i<t.length;i++){var c=t[i];void 0===e[c]&&a('No reducer provided for key "'+c+'"'),"function"==typeof e[c]&&(r[c]=e[c])}var s,f,d=Object.keys(r);s={};try{!function(e){Object.keys(e).forEach((function(t){var r=e[t];if(void 0===r(void 0,{type:n.INIT}))throw new Error('The slice reducer for key "'+t+"\" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.");if(void 0===r(void 0,{type:n.PROBE_UNKNOWN_ACTION()}))throw new Error('The slice reducer for key "'+t+"\" returned undefined when probed with a random type. Don't try to handle '"+n.INIT+'\' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.')}))}(r)}catch(e){f=e}return function(e,t){if(void 0===e&&(e={}),f)throw f;var i=function(e,t,r,i){var a=Object.keys(t),c=r&&r.type===n.INIT?"preloadedState argument passed to createStore":"previous state received by the reducer";if(0===a.length)return"Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";if(!o(e))return"The "+c+' has unexpected type of "'+u(e)+'". Expected argument to be an object with the following keys: "'+a.join('", "')+'"';var s=Object.keys(e).filter((function(e){return!t.hasOwnProperty(e)&&!i[e]}));return s.forEach((function(e){i[e]=!0})),r&&r.type===n.REPLACE?void 0:s.length>0?"Unexpected "+(s.length>1?"keys":"key")+' "'+s.join('", "')+'" found in '+c+'. Expected to find one of the known reducer keys instead: "'+a.join('", "')+'". Unexpected keys will be ignored.':void 0}(e,r,t,s);i&&a(i);for(var c=!1,l={},p=0;p<d.length;p++){var h=d[p],y=r[h],b=e[h],w=y(b,t);if(void 0===w){var v=t&&t.type;throw new Error("When called with an action of type "+(v?'"'+String(v)+'"':"(unknown type)")+', the slice reducer for key "'+h+'" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.')}l[h]=w,c=c||w!==b}return(c=c||d.length!==Object.keys(e).length)?l:e}},e.compose=l,e.createStore=function e(r,i,a){var c;if("function"==typeof i&&"function"==typeof a||"function"==typeof a&&"function"==typeof arguments[3])throw new Error("It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");if("function"==typeof i&&void 0===a&&(a=i,i=void 0),void 0!==a){if("function"!=typeof a)throw new Error("Expected the enhancer to be a function. Instead, received: '"+u(a)+"'");return a(e)(r,i)}if("function"!=typeof r)throw new Error("Expected the root reducer to be a function. Instead, received: '"+u(r)+"'");var s=r,f=i,d=[],l=d,p=!1;function h(){l===d&&(l=d.slice())}function y(){if(p)throw new Error("You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");return f}function b(e){if("function"!=typeof e)throw new Error("Expected the listener to be a function. Instead, received: '"+u(e)+"'");if(p)throw new Error("You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");var t=!0;return h(),l.push(e),function(){if(t){if(p)throw new Error("You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");t=!1,h();var r=l.indexOf(e);l.splice(r,1),d=null}}}function w(e){if(!o(e))throw new Error("Actions must be plain objects. Instead, the actual type was: '"+u(e)+"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");if(void 0===e.type)throw new Error('Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');if(p)throw new Error("Reducers may not dispatch actions.");try{p=!0,f=s(f,e)}finally{p=!1}for(var t=d=l,r=0;r<t.length;r++){(0,t[r])()}return e}function v(e){if("function"!=typeof e)throw new Error("Expected the nextReducer to be a function. Instead, received: '"+u(e));s=e,w({type:n.REPLACE})}function g(){var e,r=b;return(e={subscribe:function(e){if("object"!=typeof e||null===e)throw new Error("Expected the observer to be an object. Instead, received: '"+u(e)+"'");function t(){e.next&&e.next(y())}return t(),{unsubscribe:r(t)}}})[t]=function(){return this},e}return w({type:n.INIT}),(c={dispatch:w,subscribe:b,getState:y,replaceReducer:v})[t]=g,c},Object.defineProperty(e,"__esModule",{value:!0})}));
/*!
 * 全局变量，至于ax.js头部，可全站使用
 */
'use strict';
/**
 * 定义常用错误提示 
 */
const axError = {
    formatError: 'This is not a valid data format!',
    paraError: 'The parameters do not meet the requirements!',
    arrayRequired: 'The value must be an array type!',
    noNode: 'This page can not find the node!',
    required: 'Required field is missing!',
    notExist: 'The program cannot be executed because the object does not exist!',
}
/**
 * 定义判断是否是移动端函数，返回true或false 
 */
const axIsMobi = () => {
    let userAgentInfo = navigator.userAgent;
    let mobileAgents = ["Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod"];
    for (let v = 0; v < mobileAgents.length; v++) {
        if (userAgentInfo.indexOf(mobileAgents[v]) > 0) {
            return true;
        } else {
            return false;
        }
    }
}
/**
 * 判断字符串是否为日期格式，返回true或false 
 * 2021-2-5,2021/2/5,2021,2021-2,2-5
 */
const axIsDate = (str) => {
    return isNaN(str) && !isNaN(Date.parse(str));
}
/**
 * 定义客户端函数，通过屏幕宽度判断是什么终端
 */
const axClient = () => {
    let screenWidth = window.screen.width;
    if (screenWidth < 500) {
        return 'phone';
    } else if (screenWidth > 500 && screenWidth < 900) {
        return 'pad';
    } else if (screenWidth > 900 && screenWidth < 1200) {
        return 'padflip';
    } else if (screenWidth > 1200 && screenWidth < 1500) {
        return 'padpro';
    } else {
        return 'pc';
    }
}
/**
 * 判断对象类型
 */
const axTypeIs = (type, obj) => {
    return obj !== undefined &&
        obj !== null &&
        Object.prototype.toString.call(obj).slice(8, -1) === type;
};
/**
 * 获得对象真正的类型
 * 可检测出Array,Object,Function,String,Number,Boolean,Date,Null,Undefined,HTMLDivElement(Dom节点都包含HTML)等
 */
const axType = (obj) => Object.prototype.toString.call(obj).slice(8, -1);
/**
 * 定义判断为空函数，可判断function(){}，0，''，[]，{}，undefined，null
 */
const axIsEmpty = (data) => {
    let type = axType(data);
    if (!data) {
        return true;
    } else if (type === 'Function') {
        return (data.toString().replace(/\s+/g, '').match(/{.*}/g)[0] == '{}');
    } else if (type === 'Array') {
        return data.join('') == '';
    } else if (type === 'Object') {
        return (Object.keys(data).length === 0)
    } else {
        return false;
    }
}
/**
 * 判断是否是虚拟节点，也就是仅存在内存当中并没有append到页面里
*/
const axIsVnode = (elem) => {
    return !getComputedStyle(elem).display;
}
/**
 * 阻止默认事件
*/
const axPreventDefault = (event) => {
    if (event.preventDefault) {
        event.preventDefault();
    } else {
        event.returnValue = false;
    }
}
/**
 * 取字符串，可向前取或向后取
*/
const axStrEnd = (str, key, type = 'afterend', inside = true) => {
    if (!str || !key) {
        return false;
    }
    str = str.trim();
    if (str.includes(key)) {
        let index, result, len = key.length;
        if (type === 'beforebegin') {
            index = str.indexOf(key);
            inside ? index += len : null;
            result = str.substring(0, index);
        } else if (type === 'afterbegin') {
            index = str.indexOf(key);
            !inside ? index += len : null;
            result = str.substring(index, str.length);
        } else if (type === 'beforeend') {
            index = str.lastIndexOf(key);
            inside ? index += len : null;
            result = str.substring(0, index);
        } else if (type === 'afterend') {
            index = str.lastIndexOf(key);
            !inside ? index += len : null;
            result = str.substring(index, str.length);
        } else {
            result = '';
        }
        return result;
    } else {
        return '';
    }
}
/**
 * 判断选择器类型
*/
const axStrType = (str) => {
    if (typeof str !== 'string') {
        console.error('Argument must be a string!')
        return false;
    }
    str = str.trim(),
        isUpperCase = (letter) => {
            if (letter >= 'A' && letter <= 'Z') {
                return true;
            }
        },
        type = '';
    if (str) {
        if (str.includes(' ')) {
            type = 'level';
        } else {
            if (str.startsWith('#')) {
                type = 'id';
            } else if (str.startsWith('.')) {
                type = 'class';
            } else if (str.startsWith('[') && str.endsWith(']')) {
                type = 'name';
            } else if ([...str].every(i => isUpperCase(i))) {
                type = 'node';
            }
        }
    }
    return type;
}
/**
 * 将字符串转成DOM对象，诸如<div>...</div>的字符串
 */
const axStrToDom = (str) => {
    if (typeof str != 'string') {
        return false;
    }
    str = str.trim();
    let wrapper;
    if (str.startsWith("<tr") || str.endsWith("</tr>")) {
        wrapper = document.createElement('tr');
        wrapper.innerHTML = str;
        return wrapper;
    } else {
        wrapper = document.createElement('div');
        wrapper.innerHTML = str;
        return wrapper.firstElementChild;
    }
}
/**
 * 将#id转成DOM，插件中常用
 */
const axIdToDom = (elem) => {
    let type = axType(elem);
    if (!elem) {
        console.warning('Node selector is empty!');
        return false;
    } else if (type === 'String') {
        let trim = elem.trim();
        if (axStrType(trim)) {
            if (axStrType(trim) === 'name' && !trim.includes('=')) {
                trim = trim.slice(0, 1) + 'name=' + trim.slice(1);
            }
            return document.querySelector(trim);
        } else {
            console.warning('No node is found with this string!');
            return false;
        }
    } else if (type.includes('HTML')) {
        return elem;
    } else {
        return false;
    }
}
/**
 * 将多种形态的字符串，对象等都转成数组格式
 * obj='a'/'a,b,c'/'a b c'/{}/0/1/[]
 */
const axValueToArr = (obj) => {
    let arr = [];
    if (!axIsEmpty(obj)) {
        if (Array.isArray(obj)) {
            arr = obj;
        } else if (typeof obj === 'string') {
            let str = obj.trim(),
                separator = obj.includes(',') ? ',' : ' ';
            if (str.includes(separator)) {
                arr = str.split(separator);
            } else {
                arr.push(obj);
            }
        } else {
            arr.push(obj);
        }
    }
    return arr;
}
/**
 * 对DOM节点进行class操作，支持get、add和remove三个方法
 */
const axClass = {
    get: function (classes) {
        return axValueToArr(classes);
    },
    add: function (obj, classes) {
        let dom = axIdToDom(obj),
            arr = this.get(classes);
        if (!dom || arr.length === 0) {
            return false;
        }
        arr.forEach(k => {
            dom.classList.add(k);
        });
        return this;
    },
    del: function (obj, classes) {
        let dom = axIdToDom(obj),
            arr = this.get(classes);
        if (!dom || arr.length === 0) {
            return false;
        }
        arr.forEach(k => {
            dom.classList.remove(k);
        });
        return this;
    }
}
/**
 * 将字符串转成数组继而转成Dom，诸如"#xxx,,yyy,DIV"这类参数型的字符串
 */
const axArrToDom = (str, parent) => {
    let arr = str.split(","),
        doms = [],
        reg = /^[0-9]*$/,
        _parent = '';
    if ((typeof parent) === 'string') {
        _parent = document.querySelector(parent);
    } else {
        _parent = parent;
    }
    arr.forEach(item => {
        if (reg.test(item.substr(0, 1))) {
            return;
        } else if (axStrType(item) == 'class') {
            if (_parent) {
                doms = doms.concat([..._parent.querySelectorAll(item)]);
            } else {
                doms = doms.concat([...document.querySelectorAll(item)]);
            }
        } else if (axStrType(item) == 'id') {
            doms.push(document.querySelector(item));
        } else if (item) {
            let nodes = document.querySelectorAll(item);
            if (nodes) {
                if (_parent) {
                    doms = doms.concat([..._parent.querySelectorAll(item)]);
                } else {
                    doms = doms.concat([...document.querySelectorAll(item)]);
                }
            }
        } else {
            return doms;
        }
    })
    return doms;
}
/**
 * 将带children属性的多维数组拍平为一维数组
*/
const axArrToFlat = (arr) => {
    let result = [],
        data = [...arr];
    data.forEach(i => {
        if (i.children) {
            result = [...result, i, ...axArrToFlat(i.children)];
        } else {
            result.push(i);
        }
    });
    return result;
}
/**
 * 根据现有数组获得新项目的ID（数组最大id或索引+1）
*/
const axIncreaseId = (data, hasId = true) => {
    let ids = [],
        newId;
    if (hasId) {
        data.forEach(i => {
            ids.push(i.id);
        });
        newId = Math.max(...ids) + 1;
    } else {
        newId = data.length;
    }
    return newId;
}
/**
 * 从表单控件取值，用于校验判断，适合的控件：checkbox、radio、select-multiple和file
*/
const axMultiValues = (name, type = 'checkbox', format = 'array', form, separator = ',') => {
    let inputs,
        values = [],
        parent = form ? axIdToDom(form) : '';
    if (axType(name) == 'NodeList' || axType(name) == 'Array') {
        if (type.includes('select') || type == 'file') {
            console.warn('Can not be an node array in this type!');
            return false;
        }
        inputs = name;
    } else if (typeof name == 'object' || (axStrType(name) && axStrType(name) !== 'name')) {
        let dom = axIdToDom(name);
        if (type.includes('select') || name.nodeName == 'SELECT') {
            type = 'select';
            inputs = dom.options;
        } else if (type == 'file' || dom.type == 'file') {
            type = 'file';
            inputs = [dom];
        } else {
            inputs = [...dom.querySelectorAll('input')];
        }
    } else {
        let selector = '';
        if (axStrType(name) === 'name') {
            selector = name.replace('[', '[name=');
        } else {
            selector = `[name=${name}]`;
        }
        if (type.includes('select')) {
            inputs = parent ? parent.querySelector(selector).options : document.querySelector(selector).options;
        } else if (type == 'file') {
            inputs = parent ? [parent.querySelector(selector)] : [document.querySelector(selector)];
        } else {
            inputs = parent ? [...parent.querySelectorAll(selector)] : [...document.querySelectorAll(selector)];
        }
    }
    for (let i = 0; i < inputs.length; i++) {
        let condition,
            item = inputs[i];
        if (type.includes('select')) {
            condition = item.selected;
        } else {
            condition = item.checked;
        }
        if (type == 'file') {
            values = [...item.files];
        } else {
            if (condition) {
                values.push(item.value);
            }
        }
    }
    if (format == 'string') {
        values = values.join(separator)
    }
    return values;
}
/**
 * 防抖函数
 * 使用表现：持续输入后延迟执行
*/
const axDebounce = (fn, delay = 200) => {
    let timer = null,
        handle = function () {
            if (timer) clearTimeout(timer);
            let _this = this,
                _arguments = arguments;
            timer = setTimeout(function () {
                fn.apply(_this, _arguments);
            }, delay);
        }
    handle.cancel = function () {
        if (timer) clearTimeout(timer);
    }
    return handle;
}
/**
 * 节流函数
 * 使用表现：持续点击多次也只会按固定间隔时间执行
*/
const axThrottle = (fn, interval = 500) => {
    let last = 0,
        timer = null,
        handle = function () {
            let _this = this,
                _arguments = arguments,
                now = new Date().getTime();
            if (now - last > interval) {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                fn.apply(_this, _arguments);
                last = now;
            } else if (timer === null) {
                timer = setTimeout(function () {
                    timer = null;
                    fn.apply(_this, _arguments);
                }, interval);
            }
        }
    handle.cancel = function () {
        clearTimeout(timer);
        timer = null;
    }
    return handle;
}
/**
 * 数组元素移动位置
 */
const axMoveArr = (arr, from, to) => {
    if (from > arr.length || to > arr.length || from < 0 || to < 0) {
        console.error('Exceeded array length!');
        return false;
    }
    let obj = arr[from];
    arr.splice(from, 1);
    arr.splice(to, 0, obj);
    return arr;
}
/**
 * 判断元素以及其父元素是否可见
 */
const axIsVisible = (element) => {
    let elem = axIdToDom(element),
        loopable = true,
        visible = getComputedStyle(elem).display != 'none' && getComputedStyle(elem).visibility != 'hidden';
    while (loopable && visible) {
        elem = elem.parentNode;
        if (elem && elem != document.body) {
            visible = getComputedStyle(elem).display != 'none' && getComputedStyle(elem).visibility != 'hidden';
        } else {
            loopable = false;
        }
    }
    return visible;
}
/**
 * 在某div中使用滚轮，整个页面不滚动
 */
const axPreventScroll = (preventDom, scrollDom) => {
    let prevent = preventDom ? axIdToDom(preventDom) : null,
        scroll = scrollDom ? axIdToDom(scrollDom) : null;
    if (navigator.userAgent.indexOf("Firefox") > 0) {
        prevent.addEventListener('DOMMouseScroll', (e) => {
            e.preventDefault();
        }, false);
        if (!scroll) {
            if (preventDom && preventDom.scrollHeight > preventDom.clientHeight) {
                preventDom.addEventListener('DOMMouseScroll', (e) => {
                    preventDom.scrollTop += e.detail > 0 ? 60 : -60;
                }, false);
            }
        } else {
            if (scroll && scroll.scrollHeight > scroll.clientHeight) {
                scroll.addEventListener('DOMMouseScroll', (e) => {
                    scroll.scrollTop += e.detail > 0 ? 60 : -60;
                }, false);
            }
        }
    } else {
        prevent.addEventListener('mousewheel', (e) => {
            e = e || window.event;
            e.returnValue = false;
        }, false);
        if (!scroll) {
            if (preventDom && preventDom.scrollHeight > preventDom.clientHeight) {
                preventDom.addEventListener('mousewheel', (e) => {
                    preventDom.scrollTop += e.wheelDelta > 0 ? -60 : 60;
                }, false);
            }
        } else {
            if (scroll && scroll.scrollHeight > scroll.clientHeight) {
                scroll.addEventListener('mousewheel', (e) => {
                    scroll.scrollTop += e.wheelDelta > 0 ? -60 : 60;
                }, false);
            }
        }
    }
    return this;
}
/**
 * 创建带前缀的随机Id
 */
const axCreateId = (prefix, type, elem) => {
    let dom = elem ? axIdToDom(elem) : null;
    let generateChars = (length) => {
        length = length || 32;
        let chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678',
            maxLen = chars.length,
            string = '';
        for (let i = 0; i < length; i++) {
            string += chars.charAt(Math.floor(Math.random() * maxLen));
        }
        return string;
    };
    let time = new Date().getTime();
    let id = elem ? dom.id.replace(/(:|\.|\[|\]|,)/g, '') : null;
    if (type) {
        if (!isNaN(type)) {
            return prefix + "-" + generateChars(type);
        } else if (id && type == 'id') {
            return prefix + "-" + id;
        } else {
            return prefix + "-" + time;
        }
    } else {
        return prefix + "-" + time;
    }
};
/**
 * 用日期创建文件名
 */
const axDateToName = (prefix = '', suffix = '', end = 'random') => {
    let now = new Date(),
        year = now.getFullYear(),
        month = now.getMonth() + 1,
        day = now.getDate(),
        hour = now.getHours(),
        minuite = now.getMinutes(),
        second = now.getSeconds(),
        dataStr = '' + year + month + day + hour + minuite + second,
        rand = (Math.floor(Math.random() * 9999) + 1000).toString(),
        name = '';
    prefix ? name += prefix : null;
    name += dataStr;
    end === 'random' ? name += rand : name += end;
    suffix ? name += suffix : null;
    return name;
}
const axUlToArr = (element, start = 1, hold) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element),
        newId = start;
    let getChild = () => {
        let data = [];
        axChildren(elem, 'li').forEach(item => {
            data.push(getJson(item, newId++));
        });
        return data;
    }
    let getJson = (elem, index) => {
        let obj = {},
            nodeValue = '',
            nodeLabel = elem.firstElementChild.textContent.trim();
        if (elem.firstElementChild.getAttribute('value')) {
            nodeValue = elem.firstElementChild.getAttribute('value').trim();
            obj = { id: index, label: nodeLabel, value: nodeValue };
        } else {
            if (hold) {
                obj = { id: index, label: nodeLabel };
            } else {
                obj = { id: index, value: nodeLabel };
            }
        }
        if (elem.querySelector('ul')) {
            [...elem.querySelector('ul').children].forEach(item => {
                if (!obj.children) {
                    obj.children = [];
                }
                obj.children.push(getJson(item, newId++));
            });
        }
        return obj;
    }
    return getChild();
}
/**
 * 将下拉菜单Dom树转成对象数组格式：[{"value":""},{"value":""},"value":""]
 */
const axSelectToArr = (element, start = 1) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element),
        newId = start;
    let getChild = () => {
        let data = [];
        [...elem.children].forEach(item => {
            data.push(getJson(item, newId++));
        });
        return data;
    }
    let getJson = (elem, index) => {
        let value = '',
            name = '',
            obj = {};
        if (elem.nodeName == 'OPTGROUP') {
            name = elem.getAttribute('label').trim();
            value = name;
        } else {
            name = elem.textContent.trim();
            elem.getAttribute('value') ? value = elem.getAttribute('value').trim() : null;
        }
        obj = { "id": index, "name": name, "value": value };
        if (elem.querySelector('option')) {
            [...elem.children].forEach(item => {
                if (!obj.children) {
                    obj.children = [];
                }
                obj.children.push(getJson(item, newId++));
            });
        }
        return obj;
    }
    return getChild();
}
/**
 * 从table数据转成二维数组格式：[['','',...],...]
 * element为table标签
 */
const axTableToJson = (element) => {
    let elem = axIdToDom(element),
        tbody = elem.querySelector('tbody'),
        rows = tbody.rows,
        rowArr = [];
    [...rows].forEach((i) => {
        let tds = i.cells,
            tdArr = [];
        [...tds].forEach((k) => {
            tdArr.push(k.innerText.trim());
        });
        rowArr.push(tdArr);
    });
    return rowArr;
}
/**
 * 从datalist中获取对象数组格式：[{"value":""},{"value":""}]
 */
const axListToArr = (element, start = 1) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element),
        newId = start;
    let getChild = () => {
        let data = [];
        [...elem.children].forEach(item => {
            data.push(getJson(item, newId++));
        });
        return data;
    }
    let getJson = (elem, index) => {
        let value = '',
            name = '',
            obj = {};
        name = elem.textContent.trim();
        value = elem.getAttribute('value') ? elem.getAttribute('value').trim() : name;
        obj = { "id": index, "name": name, "value": value };
        if (!axIsEmpty(elem.dataset)) {
            Object.assign(obj, elem.dataset)
        }
        return obj;
    }
    return getChild();
}
/**
 * 一维数组转tree数组，root为顶级id，通常是0
 */
const axArrToTree = (arr, start) => {
    let root = start ? start : 0;
    arr.forEach(k => {
        let children = arr.filter(i => k.id === i.pId);
        if (children.length) {
            k.children = children;
        }
    });
    arr = arr.filter(k => k.pId == root);
    return arr;
}
/**
 * 使用任意值找到一项，可以是一个对象、数字、字符串或节点
 */
const axFindItem = (obj, data, map = { string: 'label', number: 'id', header: 'headerDom', wrapper: 'wrapperDom' }) => {
    let type = axType(obj),
        result;
    if (type === 'Object' || type === 'Array') {
        result = data.find(k => k === obj);
    } else if (type === 'Number') {
        if (data[0].hasOwnProperty(map.number)) {
            result = data.find(k => k[map.number] === obj);
        } else {
            result = data[obj];
        }
    } else if (type === 'String') {
        if (obj.startsWith('#')) {
            result = data.find(k => '#' + k[map.wrapper].id === obj || '#' + k[map.header].id === obj);
        } else {
            result = data.find(k => k[map.string] === obj);
        }
    } else if (type.includes('HTML')) {
        result = data.find(k => k[map.header] === obj);
    } else {
        result = false;
    }
    return result;
}
/**
 * 将创建tree的数据对象push到数组里和节点里
 */
const axTreeMethod = {
    addPath: (data, firstFloor = -1, idStart = 0) => {
        if (!Array.isArray(data) || data.length === 0) {
            return false;
        }
        let maxFloor = 0,
            maxId = 0,
            hasId = data[0].hasOwnProperty('id') ? true : false,
            index = idStart,
            each = (data, floor, path = firstFloor) => {
                data.forEach(item => {
                    !hasId ? item.id = index : null;
                    item.floor = floor;
                    item.pId = item.pId || item.pId === 0 ? item.pId : firstFloor;
                    floor >= maxFloor ? maxFloor = floor : null;
                    item.id >= maxId ? maxId = item.id : null;
                    index++;
                    if (item.children && item.children.length > 0) {
                        let nextPath = path.toString() + '>' + item.id.toString();
                        item.children.forEach(k => {
                            k.path = nextPath + '>' + k.id;
                            k.pId = item.id;
                        });
                        each(item.children, floor + 1, nextPath);
                    }
                    if (!item.path) {
                        item.path = item.pId + '>' + item.id;
                    }
                });
            }
        each(data, 1);
        return { data: data, maxFloor: maxFloor, maxId: maxId };
    },
    remove: (item, flat, tree, callback) => {
        if (item.floor !== 1) {
            let parent = flat.find(k => k.id == item.pId),
                children = parent.children,
                index = children.indexOf(item);
            children.splice(index, 1);
        } else {
            tree = tree.filter(k => k != item);
        }
        flat = flat.filter(k => k !== item && !k.path.includes('>' + item.id + '>'));
        item.wrapperDom.remove();
        callback && callback(item, flat);
        return { flat: flat, tree: tree };
    },
    createData: (source, target, flat, isChild) => {
        let obj = {},
            sourceType = axType(source),
            newId = axIncreaseId(flat),
            newLabel = sourceType === 'String' ? source : '新节点' + newId;
        if (sourceType === 'Object') {
            let attrs = isChild ? {
                path: target.path + '>' + source.id,
                floor: target.floor + 1
            } : {
                path: target.path.replace(new RegExp('(.*)' + target.id), '$1' + source.id),
                floor: target.floor
            };
            !source.hasOwnProperty('id') ? source.id = newId : null;
            obj = Object.assign(source, attrs);
        } else {
            obj = isChild ? {
                id: newId,
                label: newLabel,
                pId: target.id,
                path: target.path + '>' + newId,
                floor: target.floor + 1
            } : {
                id: newId,
                label: newLabel,
                pId: target.pId,
                path: target.path.replace(new RegExp('(.*)' + target.id), '$1' + newId),
                floor: target.floor
            };
        }
        return obj;
    },
    existChildPush: (source, target, isFront = true) => {
        if (isFront) {
            target.children.unshift(source);
            target.bodyDom.insertAdjacentElement('afterBegin', source.wrapperDom);
        } else {
            target.children.push(source);
            target.bodyDom.insertAdjacentElement('beforeEnd', source.wrapperDom);
        }
    },
    noExistChildPush: (source, target, toParent) => {
        target.children = [];
        target.children.push(source);
        target = toParent(target);
        target.bodyDom.appendChild(source.wrapperDom);
        target.wrapperDom.appendChild(target.bodyDom);
    },
}
/**
 * 判断是否在元素矩形区域之外
 */
const axIsOutside = (ev, id, ox, oy) => {
    if (!id) { return true }
    let elem = axIdToDom(id);
    if (!elem) { return true }
    let x = ev.clientX,
        y = ev.clientY,
        x1, y1, x2, y2;
    ox ? x1 = ox : x1 = elem.getBoundingClientRect().left;
    oy ? y1 = oy : y1 = elem.getBoundingClientRect().top;
    x2 = x1 + elem.offsetWidth;
    y2 = y1 + elem.offsetHeight;
    return (x < x1 || x > x2 || y < y1 || y > y2) ? true : false;
}
/**
 * 封装getComputedStyle方法
 */
const axStyle = (elem, pseudo) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    return document.defaultView.getComputedStyle(element, pseudo);
}
/**
 * 筛选某实例数组中id=value的实例
 */
/* const axInstance = (json, value) => {
    if (axIsEmpty(json)) {
        console.error('Instance is destroyed!');
    }
    return json.filter((obj) => {
        return obj.name == value;
    })[0].instance;
} */
/**
 * 定义模板引擎
 */
const axTplEngine = (html, data) => {
    if (!html) { console.error('No html!'); return false; }
    let re = /<#([^#>]+)?#>/g,
        reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g,
        code = 'let r=[];\n',
        cursor = 0;
    let match;
    let add = (line, js) => {
        js ? (code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n') :
            (code += line != '' ? 'r.push("' + line.replace(/"/g, '\\"') + '");\n' : '');
        return add;
    }
    while (match = re.exec(html)) {
        add(html.slice(cursor, match.index))(match[1], true);
        cursor = match.index + match[0].length;
    }
    add(html.substr(cursor, html.length - cursor));
    code += 'return r.join("");';
    return new Function(code.replace(/[\r\t\n]/g, '')).apply(data);
}
/**
 * 定义深度拷贝函数
 */
const axClone = (data) => {
    let cloneObj = (obj) => {
        if (obj === null) {
            return null;
        } else if (typeof obj !== 'object') {
            return obj;
        } else if (obj.constructor === Date) {
            return new Date(obj);
        } else {
            let newObj = {};
            for (let k in obj) {
                if (obj[k] == null) {
                    newObj[k] = null;
                } else if ((typeof obj[k]) == 'object' && !obj[k].nodeType) {
                    newObj[k] = axClone(obj[k]);
                    if (obj[k] instanceof Array) {
                        let newArray = [];
                        for (let i of obj[k]) {
                            newArray.push(axClone(i));
                        }
                        newObj[k] = newArray;
                    }
                } else {
                    newObj[k] = obj[k];
                }
            }
            return newObj;
        }
    }
    if (Array.isArray(data)) {
        return data.map(k => cloneObj(k));
    } else {
        return cloneObj(data);
    }
};
/**
 * 定义合并属性递归函数
 */
const axMerge = (target, source, option = { arrAppend: false, clone: false, attrAppend: true }) => {
    if (typeof target != 'object' || typeof source != 'object') {
        return source;
    }
    if (!source) {
        return target;
    }
    let obj = option.copy ? axClone(target) : target;
    for (let k in source) {
        if (source.hasOwnProperty(k) && obj.hasOwnProperty(k)) {
            if (axType(source[k]) != 'Array') {
                obj[k] = axMerge(obj[k], source[k], option);
            } else {
                if (option.arrAppend) {
                    obj[k].push(...source[k]);
                } else {
                    obj[k] = source[k];
                }
            }
        } else if (source.hasOwnProperty(k) && !obj.hasOwnProperty(k) && option.attrAppend) {
            obj[k] = source[k];
        }
    }
    return obj;
}
/**
 * 字符串转成数组，'[]'，'{"":""},{"":""}'，'a,b,c'均转成数组
 */
const axStrToArr = (string, dftAttr, dftValue) => {
    let array = [],
        dft = {};
    if (!axIsEmpty(dftAttr)) {
        dftAttr.forEach((item, index) => {
            dft[item] = !axIsEmpty(dftValue) ? dftValue[index] : '';
        })
    }
    if (string.substr(0, 1) == '[' && string.substr(-1) == ']') {
        array = JSON.parse(string);
    } else if (string.replace(/\s*/g, "").indexOf('},{') != -1) {
        array = JSON.parse('[' + string + ']');
    } else if (string.replace(/\s*/g, "").substr(0, 1) == '{' && string.replace(/\s*/g, "").substr(-1) == '}') {
        array = JSON.parse('[' + string + ']');
    } else {
        array = string.split(',');
        array.forEach((item, index) => {
            item = item.trim();
            if (typeof item == 'string' && !axIsEmpty(dftAttr)) {
                let obj = {};
                dftAttr.forEach((str, i) => {
                    if (i == 0) {
                        obj[str] = item;
                    } else {
                        obj[str] = '';
                    }
                });
                array.splice(index, 1, obj)
            }
        });
    }
    array.forEach(item => {
        if (!axIsEmpty(dft)) {
            for (let k in dft) {
                if (!item.hasOwnProperty(k)) {
                    item[k] = dft[k] ? dft[k] : '';
                } else if (item.hasOwnProperty(k) && !item[k]) {
                    item[k] = dft[k];
                }
            }
        }
    })
    return array;
}
/**
 * HTML模板转成数组，支持列表循环
 */
const axTplToArr = (template, roles, keys, itemNode, dft) => {
    let tplDom = axIdToDom(template),
        data = [];
    if (itemNode) {
        let items = tplDom.querySelectorAll(itemNode);
        items.forEach(item => {
            let obj = {};
            roles.forEach((i, index) => {
                let child = item.querySelector('[' + i + ']');
                if (child) {
                    obj[keys[index]] = child.getAttribute(i) ? child.getAttribute(i).trim() : child.innerHTML.trim();
                } else {
                    obj[keys[index]] = dft[index] || '';
                }
            })
            data.push(obj);
        })
    } else {
        let obj = {};
        roles.forEach((i, index) => {
            let child = tplDom.querySelector('[' + i + ']');
            if (child) {
                obj[keys[index]] = child.getAttribute(i) ? child.getAttribute(i).trim() : child.innerHTML.trim();
            } else {
                obj[keys[index]] = dft[index] || '';
            }
        })
        data.push(obj);
    }
    return data;
}
/**
 * 将元素data-*属性与对象合并为新对象；
 * 1、先将对象obj复制保存为copy；
 * 2、将复制的对象name全转成小写；
 * 3、将data-*属性存为三层结构的对象，name均为小写并与copy合并；
 * 4、将合并后的copy与原obj对照还原大写name，并最终输出合并后的obj
 */
const axDataset = (element, obj) => {
    let elem = element ? axIdToDom(element) : null;
    let integer = /^\d+(\.\d+)?$/; 
    let float = /^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/; 
    if (elem) {
        let attrs = [...elem.attributes].filter((child) => {
            return child.name.indexOf('data-') == 0;
        });
        if (!axIsEmpty(attrs)) {
            let lowerDft = axClone(obj);
            let loopLow = (arg) => {
                for (let k in arg) {
                    let lower = k.toLowerCase();
                    arg[lower] = arg[k];
                    if (axTypeIs('Object', arg[k])) {
                        loopLow(arg[k]);
                    }
                    if (lower != k) {
                        delete arg[k];
                    }
                }
            }
            loopLow(lowerDft);
            for (let k = 0; k < attrs.length; k++) {
                let value = attrs[k].value.trim(),
                    name = attrs[k].name;
                if (value == 'true') {
                    value = JSON.parse('true');
                } else if (value == 'false') {
                    value = JSON.parse('false');
                } else if (value == 'null') {
                    value = null;
                } else if (value.substr(0, 1) == '[' && value.substr(-1) == ']') {
                    value = JSON.parse(value);
                } else if (value.replace(/\s*/g, "").indexOf('},{') != -1) {
                    value = JSON.parse('[' + value + ']');
                }
                if (typeof value == 'string' && (integer.test(value) || float.test(value))) {
                    value = Number(value);
                }
                let split = name.split('-');
                if (split.length - 1 == 1) {
                    lowerDft[split[1]] = value
                } else if (split.length - 1 == 2) {
                    lowerDft[split[1]][split[2]] = value
                } else if (split.length - 1 == 3) {
                    lowerDft[split[1]][split[2]][split[3]] = value
                } else {
                    console.error('Three levels are supported!');
                }
            }
            let loopBack = (arg, opt) => {
                for (let k in arg) {
                    let lower = k.toLowerCase();
                    if (axTypeIs('Object', arg[k])) {
                        loopBack(arg[k], opt[lower]);
                    } else {
                        arg[k] = opt[lower];
                    }
                }
            }
            loopBack(obj, lowerDft);
        }
    }
    return obj;
}
/**
 * 将元素ax*属性值得字符串形式转为对象形式
 */
const axAttrToJson = (elem, attr) => {
    let dom = axIdToDom(elem);
    if (!dom) {
        console.warn('The attribute node does not exist!');
        return {};
    }
    let domAttr = dom.getAttribute(attr);
    if (!attr || !domAttr) {
        return {};
    }
    if (!domAttr.includes(':')) {
        return {};
    }
    let text = domAttr.trim();
    if (!text.startsWith('{')) {
        text = '{' + text + '}';
    }
    return new Function('return ' + text)();
}
/* let obj = {
    name: 'Mick',
    sex: 'male',
    school: {
        no: 'NO.5665',
        city: 'shenzhen',
        tel: '13800138000',
        zip: '518000'
    },
    teachers: {
        mathematics: {
            name: 'Lily',
            age: 29,
            sex: 'female',
        },
        physics: {
            name: 'Bob',
            age: 33,
            sex: 'male',
        },
    },
    callback: () => { },
} */
/**
 * 定义对象扩展
 * user属性可覆盖dft属性，并自动合并为新的dft 
 * DOM的data-*属性级别最高，使用短横“-”区分属性层级，最多允许使用三个短横
 * 举例说明： <button data-name="" data-school="" data-teachers-mathematics-name=""></button>
 */
const axExtend = (dft, user, element, attr) => {
    if (!dft) { console.error(axError.notExist); return false; }
    let elem = element ? axIdToDom(element) : null;
    axMerge(dft, user);
    elem ? axMerge(dft, axAttrToJson(elem, attr)) : null;
    return dft;
}
/**
 * 定义监听事件函数(观察者模式)
 */
const axAddPlan = (type, handler, instance) => {
    if (!(type in instance.handlers)) {
        instance.handlers[type] = [];
    }
    let strHandle = handler.toString().replace(/\s/g, '').replace(/\;/g, '').match(/{(\S*)}/)[1],
        strHandles = instance.handlers[type].toString().replace(/\s/g, '').replace(/\;/g, '');
    strHandles.indexOf(strHandle) > -1 ? null : instance.handlers[type].push(handler);
}
const axExePlan = (type, instance, ...params) => {
    if (!(type in instance.handlers)) {
        return console.error('The event is not registered!');
    }
    instance.handlers[type].forEach(handler => {
        handler.call(instance, ...params);
    });
}
const axDelPlan = (type, handler, instance) => {
    if (!(type in instance.handlers)) {
        return console.error('Invalid event!');
    }
    if (!handler) {
        delete instance.handlers[type];
    } else {
        let index = instance.handlers[type].findIndex(elem => elem === handler)
        if (index === undefined) {
            return console.error('This event is not bound!');
        }
        instance.handlers[type].splice(index, 1);
        if (instance.handlers[type].length === 0) {
            delete instance.handlers[type];
        }
    }
}
/**
 * 新增一个节点元素
 */
const axAddElem = (node, options, content) => {
    node.toLowerCase();
    let _node = document.createElement(node);
    if (options) {
        for (k in options) {
            _node.setAttribute(k, options[k])
        }
    }
    let loop = function (node, content) {
        if (!content) {
            return false;
        }
        if (Array.isArray(content)) {
            if (content.length > 0) {
                content.forEach(i => {
                    loop(node, i);
                });
            }
        } else {
            if (typeof content == 'object') {
                node.appendChild(content);
            } else {
                node.insertAdjacentHTML('beforeEnd', content);
            }
        }
    }
    loop(_node, content);
    return _node;
}
/**
 * 给子元素新增父层元素，将其包裹住
 */
const axAddWrap = (elem, wrap, node, options, content) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem),
        wrapper = '';
    if (wrap) {
        wrapper = axIdToDom(wrap);
    } else if (!wrapper && node) {
        wrapper = axAddElem(node, options, content);
    }
    if (element.nextSibling) {
        if (element.parentNode !== wrapper) {
            element.parentNode.insertBefore(wrapper, element.nextSibling);
        }
    } else {
        if (element.parentNode !== wrapper) {
            element.parentNode.appendChild(wrapper);
        }
    }
    return wrapper.appendChild(element);
};
/**
 * 字符串转筛选语句返回筛选结果
 */
const axStrToFilter = (str, source, callback) => {
    let text = `source.filter(item =>${str})`,
        result = new Function('source', 'return ' + text)(source);
    callback && callback(result);
    return result;
}
/**
 * 替换字符串某位置的字符
 */
const axRangeReplace = (originText, replaceText, indexStart, indexStop, n) => {
    if (typeof originText !== 'string') {
        originText = JSON.stringify(originText);
    }
    if (typeof replaceText !== 'string') {
        originText = JSON.stringify(replaceText);
    }
    let result = '';
    if (!indexStart && !indexStop) {
        result = replaceText;
    } else if (!indexStop) {
        if (n) {
            result = originText.substring(0, indexStart) + replaceText + originText.substring(indexStart + n);
        } else {
            result = originText.substring(0, indexStart) + replaceText;
        }
    } else if (!indexStart) {
        if (n) {
            result = originText.substring(indexStop - n) + replaceText + originText.substring(0, indexStart);
        } else {
            result = replaceText + originText.substring(indexStop);
        }
    } else {
        result = originText.substring(0, indexStart) + replaceText + originText.substring(indexStop);
    }
    return result;
}
const axArrange = (origin, n, index = 0, splice = [], result = []) => {
    let arrayLen = origin.length
    if (index + n > arrayLen) {
        return;
    }
    for (let i = index; i < arrayLen; i++) {
        if (n === 1) {
            result.push([...splice, origin[i]])
            i + 1 < arrayLen && axArrange(origin, n, i + 1, splice, result)
            break;
        }
        axArrange(origin, n - 1, i + 1, [...splice, origin[i]], result)
    }
    return result;
}
const axCleanString = value => {
    if (typeof value !== 'string') {
        return value;
    }
    return value.replace(/&/g, '&amp;').replace(/>/g, '&rt;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
};
/**
 * 获取隐藏元素的高度、宽度、左边距和上边距
 */
const axHideSize = (parent, attrName, child) => {
    let _parent = axIdToDom(parent),
        _child = child ? axIdToDom(child) : null,
        attr = {};
    if (!_child) {
        let display = window.getComputedStyle(_parent).display,
            style = _parent.style.cssText;
        if (display == 'none') {
            _parent.style.cssText = `display:block;visibility:hidden;position:fixed`;
        }
        attr = {
            height: _parent.offsetHeight,
            width: _parent.offsetWidth,
            offsetLeft: _parent.offsetLeft,
            offsetTop: _parent.offsetTop
        }
        if (style) {
            _parent.style.cssText = style
        } else {
            _parent.removeAttribute('style');
        };
    } else {
        let arrStyle = [];
        axParents2(child, parent, true, true).forEach(item => {
            let display = window.getComputedStyle(item).display,
                style = item.style.cssText;
            if (display == 'none') {
                item.style.cssText = `display:block;visibility:hidden;position:fixed`;
            }
            arrStyle.push(style)
        });
        attr = {
            height: _child.offsetHeight,
            width: _child.offsetWidth,
            offsetLeft: _child.offsetLeft,
            offsetTop: _child.offsetTop
        }
        axParents2(child, parent, true, true).forEach((item, index) => {
            if (arrStyle[index]) {
                item.style.cssText = arrStyle[index]
            } else {
                item.removeAttribute('style');
            };
        });
    }
    return attr[attrName]
}
/**
 * 定义AJAX函数，异步获取内容
 */
const axAjax = (option, elem, callback) => {
    if (!option) { console.error('There is no options!'); return false; }
    let label = axAddElem('SPAN', { 'ajax-message': '' }),
        dom = elem ? axIdToDom(elem) : null;
    dom ? dom.appendChild(label) : null;
    let dft = {
        url: '',
        selector: '',
        type: 'post',
        async: true,
        data: {},
        delay: 60000,
        contentType: '',
        headers: {},
        responseType: '',
        abort: () => { dom ? (label.innerHTML = '<i class="ax-color-warning">中止了请求！</i>', dom.setAttribute('ajax-result', 'abort')) : console.error('中止了请求！') },
        timeout: () => { dom ? (label.innerHTML = '<i class="ax-color-danger">请求超时了！</i>', dom.setAttribute('ajax-result', 'timeout')) : console.error('请求超时了！') },
        loading: '<span class="ax-loading"><i></i></span>',
        before: (loading) => { dom ? (label.innerHTML = loading, dom.setAttribute('ajax-result', 'before')) : null },
        downloading: () => { },
        uploading: () => { },
        success: (data) => { dom ? (dom.innerHTML = data, dom.setAttribute('ajax-result', 'success')) : null; },
        error: (data, state) => { dom ? (label.innerHTML = `<i class="ax-color-danger">错误状态：${state}</i>`, dom.setAttribute('ajax-result', 'error')) : console.error(`错误状态：${state}`); },
    };
    for (k in option) {
        dft[k] = option[k];
    }
    let xhr = '';
    if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
    }
    else {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
    }
    let params = '';
    if (axType(dft.data) == 'FormData') {
        params = dft.data;
    } else if (axType(dft.data) == 'Object') {
        if (dft.contentType.includes('json')) {
            params = JSON.stringify(dft.data);
        } else {
            for (k in dft.data) {
                params += '&' + k + '=' + dft.data[k];
            }
            dft.contentType = 'application/x-www-form-urlencoded';
        }
    } else {
        dft.data = dft.data.trim();
        params = !dft.data.startsWith('&') ? dft.data : dft.data.slice(1);
        dft.contentType = 'application/x-www-form-urlencoded';
    }
    dft.headers['Content-Type'] = dft.contentType;
    if (!dft.contentType.includes('urlencoded') && dft.type.toLowerCase() == 'get') {
        console.error('Please request data with post!');
        return false;
    }
    let setHeader = () => {
        for (k in dft.headers) {
            dft.headers[k] ? xhr.setRequestHeader(k, dft.headers[k]) : null;
        }
    },
        timeoutFun;
    xhr.timeout = dft.delay;
    xhr.responseType = dft.responseType;
    let promise = new Promise((resolve, reject) => {
        let progress = (e, callback) => {
            let current = e.loaded,
                total = e.total,
                ratio = 0,
                percent = 0,
                result = '0%',
                timeStamp = (new Date(e.timeStamp)).getTime();
            if (e.lengthComputable) {
                ratio = current / total;
                percent = Math.round(ratio * 100);
                result = percent + '%';
                callback && callback(result, percent, current, total, ratio, timeStamp, dom);
            }
        }
        xhr.upload.onprogress = (e) => {
            progress(e, (result, percent, current, total, ratio, timeStamp, dom) => {
                !axIsEmpty(dft.uploading) ? dft.uploading(result, percent, current, total, ratio, timeStamp, dom) : null;
            });
        }
        xhr.onprogress = (e) => {
            progress(e, (result, percent, current, total, ratio, timeStamp, dom) => {
                !axIsEmpty(dft.downloading) ? dft.downloading(result, percent, current, total, ratio, timeStamp, dom) : null;
            });
        }
        xhr.onerror = (e) => {
            !axIsEmpty(dft.error) ? dft.error(xhr.response, xhr.status, dom) : null;
            reject([xhr.response, xhr.status, dom]);
        }
        timeoutFun = () => {
            dom ? dom.setAttribute('ajax-result', 'timeout') : null;
            !axIsEmpty(dft.timeout) ? dft.timeout(xhr.response, xhr.status, dom) : null;
            reject([xhr.response, xhr.status, dom]);
        };
        xhr.addEventListener('timeout', timeoutFun);
        xhr.onreadystatechange = function () {
            if (xhr.readyState < 4) {
                !axIsEmpty(dft.before) ? dft.before(dft.loading, xhr.status, dom) : null;
                callback && callback(dft.loading, xhr.status, dom);
            } else {
                if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
                    if (!dft.responseType || xhr.responseType == 'text') {
                        let div = document.createElement('div'),
                            content = '',
                            reg = /(<head\b[^<]*(?:(?!<\/head>)<[^<]*)*<\/head>)|(<\/?html.*?>)|(<\!DOCTYPE.*?html.*?>)|(<\/?body.*?>)/gi,
                            strEnd = axStrEnd(dft.url, '#'),
                            selector = dft.selector || strEnd;
                        div.innerHTML = xhr.responseText;
                        if (selector && div.querySelector(selector)) {
                            content = div.querySelector(selector).innerHTML;
                        } else if (selector && !div.querySelector(selector)) {
                            console.warn(`The node of "${dft.selector}" is not exist!`);
                            content = xhr.responseText.replace(reg, '').trim();
                        } else {
                            if (xhr.responseText.trim().substr(0, 1) == "{" || xhr.responseText.trim().substr(0, 1) == "[") {
                                content = JSON.parse(xhr.responseText.trim());
                            } else {
                                content = xhr.responseText.replace(reg, '').trim();
                            }
                        }
                        dom ? dom.setAttribute('ajax-result', 'success') : null;
                        !axIsEmpty(dft.success) ? dft.success(content, xhr.status, dom) : null;
                        resolve([content, xhr.status, dom]);
                    } else {
                        dom ? dom.setAttribute('ajax-result', 'success') : null;
                        !axIsEmpty(dft.success) ? dft.success(xhr.response, xhr.status, dom) : null;
                        resolve([xhr.response, xhr.status, dom]);
                    }
                }
                else {
                    !axIsEmpty(dft.error) ? dft.error(xhr.response, xhr.status, dom) : null;
                    reject([xhr.response, xhr.status, dom]);
                }
            }
        };
        if (dft.type.toLowerCase() == 'get') {
            xhr.open('get', dft.url + '?now=' + new Date().getTime() + '&' + params, true);
            setHeader();
            xhr.send();
        } else if (dft.type.toLowerCase() == 'post') {
            xhr.open('post', dft.url, true);
            setHeader();
            xhr.send(params);
        }
    }).catch(() => { });
    promise.xhr = xhr;
    promise.abort = () => {
        timeoutFun ? xhr.removeEventListener('timeout', timeoutFun) : null;
        xhr.abort();
        !axIsEmpty(dft.abort) ? dft.abort(dom, xhr) : null;
    }
    return promise;
};
/**
 * ajax提交表单封装
 * url是异步提交地址，必填项
 * outer是form表单节点，必填项
 * target是点击的按钮，选填项
 * loadingMode是缓冲加载显示位置，button是指在按钮上转圈（要求填写target），parent是指在form表单上转圈，选填项
 * type是指异步表单提交方式，默认post，可选择get，选填项
 * delay是指多久超时，单位毫秒，默认60秒
 * header是指设定请求头，数组格式，支持两种格式：['content-Type','']和[{name:'',value:''},...]
 * beforeFun是成功返回前的回调函数，选填项
 * successFun是成功返回后的回调函数，选填项
 */
const axAjaxSubmit = (url, outer, target, type = 'post', successFun, loadingMode, delay, beforeFun, errorFun, options = {}) => {
    if (!url) { console.error('Url is required!'); return false; }
    if (!outer) { console.error('Form node is required!'); return false; }
    let parentDom = axIdToDom(outer),
        targetDom = target ? axIdToDom(target) : null,
        targetText = targetDom ? targetDom.innerHTML : '',
        mode = loadingMode || 'button',
        opt = Object.assign(options, {
            formClass: 'ax-form-submitting',
            buttonClass: 'ax-button-submitting',
            buttonText: '正在提交',
            overlayClass: 'ax-form-overlay',
            overlayShowClass: 'ax-show',
            successText: '恭喜！提交成功！',
            errorText: '对不起，提交失败！',
        }),
        overlayDom = parentDom.querySelector('.ax-form-overlay') ? parentDom.querySelector('.ax-form-overlay') : axAddElem('div', { class: 'ax-form-overlay' });
    if (parentDom.classList.contains(opt.formClass)) {
        return false;
    }
    if (targetDom && targetDom.classList.contains(opt.buttonClass)) {
        return false;
    }
    let formData = {}, promise;
    parentDom.querySelectorAll('[name]').forEach(function (item) {
        formData[item.getAttribute('name')] = item.value.trim();
    });
    promise = axAjax({
        url: url,
        data: formData,
        type: type || 'post',
        before: function (loading) {
            parentDom.classList.add(opt.formClass);
            targetDom ? targetDom.classList.add(opt.buttonClass) : null;
            if (mode == 'button' && targetDom) {
                targetDom.innerHTML = opt.buttonText;
                targetDom.insertAdjacentHTML('afterbegin', '<i class="ax-btn-loading"></i>');
            } else {
                overlayDom.innerHTML = loading;
                overlayDom.classList.add(opt.overlayClass);
                if (!parentDom.querySelector('.ax-form-overlay')) {
                    parentDom.appendChild(overlayDom);
                }
            }
            beforeFun && beforeFun(loading);
        },
        success: function (content) {
            setTimeout(() => {
                parentDom.classList.remove(opt.formClass);
                targetDom ? targetDom.classList.remove(opt.buttonClass) : null;
                if (mode == 'button' && targetDom) {
                    targetDom.innerHTML = targetText;
                } else {
                    overlayDom.classList.remove(opt.overlayClass);
                }
                new axMessage({
                    content: opt.successText,
                    result: 'success',
                    iconShow: true,
                });
                successFun && successFun(content);
            }, delay === 0 ? 0 : delay || 1000);
        },
        error: function () {
            if (mode == 'button' && targetDom) {
                targetDom.innerHTML = targetText;
            } else {
                overlayDom.classList.remove(opt.overlayClass);
            }
            new axMessage({
                content: opt.errorText,
                result: 'error',
                iconShow: true,
            });
            errorFun && errorFun(data);
        }
    });
    return promise.xhr;
}
/**
 * 获取距离body的上偏移和左偏移
 */
const axOffset = (elem) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let totalLeft,
        totalTop,
        targetDom = axIdToDom(elem);
    totalLeft = targetDom.getBoundingClientRect().left + document.documentElement.scrollLeft;
    totalTop = targetDom.getBoundingClientRect().top + document.documentElement.scrollTop;
    return {
        left: totalLeft,
        top: totalTop
    }
}
/**
 * 获得元素真实宽度，宽度构成包括：margin、padding、borderWidth、width
 */
const axWidth = (elem, type) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let { width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeftWidth, borderRightWidth } = getComputedStyle(_elem);
    width = parseInt(width, 10);
    paddingLeft = parseInt(paddingLeft, 10);
    paddingRight = parseInt(paddingRight, 10);
    marginLeft = parseInt(marginLeft, 10);
    marginRight = parseInt(marginRight, 10);
    borderLeft = parseInt(borderLeftWidth, 10);
    borderRight = parseInt(borderRightWidth, 10);
    if (type == 'inner') {
        return width + paddingLeft + paddingRight;
    } else if (type == 'outer') {
        return width + paddingLeft + paddingRight + marginLeft + marginRight + borderLeft + borderRight;
    } else {
        return width;
    }
}
/**
 * 获得元素真实高度，宽度构成包括：margin、padding、borderWidth、height
 */
const axHeight = (elem, type) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let { height, paddingTop, paddingBottom, marginTop, marginBottom, borderTopWidth, borderBottomWidth } = getComputedStyle(_elem);
    height = parseInt(height, 10);
    paddingTop = parseInt(paddingTop, 10);
    paddingBottom = parseInt(paddingBottom, 10);
    marginTop = parseInt(marginTop, 10);
    marginBottom = parseInt(marginBottom, 10);
    borderTop = parseInt(borderTopWidth, 10);
    borderBottom = parseInt(borderBottomWidth, 10);
    if (type == 'inner') {
        return height + paddingTop + paddingBottom;
    } else if (type == 'outer') {
        return height + paddingTop + paddingBottom + marginTop + marginBottom + borderTop + borderBottom;
    } else {
        return height;
    }
}
/**
 * 获得元素高度构成部分，包括：height, paddingTop, paddingBottom, marginTop, marginBottom, borderTop, borderBottom
 */
const axArrHeight = (elem) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let { height, paddingTop, paddingBottom, marginTop, marginBottom, borderTopWidth, borderBottomWidth } = getComputedStyle(_elem);
    height = parseInt(height, 10);
    paddingTop = parseInt(paddingTop, 10);
    paddingBottom = parseInt(paddingBottom, 10);
    marginTop = parseInt(marginTop, 10);
    marginBottom = parseInt(marginBottom, 10);
    borderTop = parseInt(borderTopWidth, 10);
    borderBottom = parseInt(borderBottomWidth, 10);
    return { height, paddingTop, paddingBottom, marginTop, marginBottom, borderTop, borderBottom };
};
/**
 * 获得元素宽度构成部分，包括：width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeft, borderRight
 */
/* const axArrWidth = (elem) => {
    let { width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeftWidth, borderRightWidth } = getComputedStyle(elem);
    width = parseInt(width, 10);
    paddingLeft = parseInt(paddingLeft, 10);
    paddingRight = parseInt(paddingRight, 10);
    marginLeft = parseInt(marginLeft, 10);
    marginRight = parseInt(marginRight, 10);
    borderLeft = parseInt(borderLeftWidth, 10);
    borderRight = parseInt(borderRightWidth, 10);
    return { width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeft, borderRight };
}; */
/**
 *  判断是否选择了已知元素 ,返回 ture 或 false
 */
const axSelector = (elem, selector) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let result = true;
    if (selector) {
        selector = String(selector).replace(/\s+/g, '');
        selector = String(selector).split(',');
        for (let i = 0; i < selector.length; i++) {
            if (!selector[i]) {
                result = true;
                break;
            } else if (axStrType(selector[i]) == 'class') {
                let string = selector[i].replace('.', '');
                if (_elem.classList.contains(string)) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            } else if (axStrType(selector[i]) == 'id') {
                let string = selector[i].replace('#', '');
                if (_elem.getAttribute('id') == string) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            } else {
                let string = selector[i].toUpperCase();
                if (_elem.nodeName == string) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            }
        }
    } else {
        result = true;
    }
    return result;
}
/**
 * 判断是否排除了已知元素 ,返回 ture 或 false
 */
const axNot = (elem, selector) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let _elem = axIdToDom(elem);
    let result = true;
    if (selector) {
        selector = String(selector).replace(/\s+/g, '');
        selector = String(selector).split(',');
        for (let i = 0; i < selector.length; i++) {
            if (axStrType(selector[i]) == 'class') {
                let string = selector[i].replace('.', '');
                if (_elem.classList.contains(string)) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            }
            else if (axStrType(selector[i]) == 'id') {
                let string = selector[i].replace('#', '');
                if (_elem.getAttribute('id') == string) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            } else if (selector) {
                let string = selector[i].toUpperCase();
                if (_elem.nodeName == string) {
                    result = true;
                    break;
                } else {
                    result = false;
                }
            } else {
                result = false;
            }
        }
    } else {
        result = false;
    }
    return result;
}
/**
 * 选择兄弟元素
 * element：选择的Dom
 * self：是否包含自己，默认false
 * selector：从指定的选择器中选择兄弟元素
 * ignore：不选择的兄弟元素
 * 举例：axSiblings(elem,'#my','.disabled')
 */
const axSiblings = (element, self, selector, ignore) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    return [...elem.parentNode.children].filter((child) => {
        if (!self) {
            return child !== elem && axSelector(child, selector) && !axNot(child, ignore);
        } else {
            return axSelector(child, selector) && !axNot(child, ignore);
        }
    });
}
/**
 * 选择子元素
 * element：选择的Dom
 * selector：从指定的选择器中选择兄弟元素
 * ignore：不选择的兄弟元素
 * 举例：axChildren(elem,'.item','.disabled')
 */
const axChildren = (element, selector, ignore) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    return [...elem.children].filter((child) => {
        return axSelector(child, selector) && !axNot(child, ignore);
    });
}
/**
 * 定义取得嫡系父层函数。
 * start：根节点
 * end：终节点
 * containStart：是否包含根节点
 * containEnd：是否包含终节点
 * parents：父节点数组
 */
const axParents = (start, end, containStart, containEnd, parents = []) => {
    if (!start) { console.error('No node to start!'); return false; }
    let _start = axIdToDom(start),
        _end = end ? axIdToDom(end) : null;
    if (_start.parentElement.nodeName !== 'BODY') {
        (containStart && parents.indexOf(_start) < 0) ? parents.push(_start) : null;
        if (_end) {
            (containEnd && parents.indexOf(_end) < 0) ? parents.push(_end) : null;
            if (_start.parentElement !== _end) {
                parents.push(_start.parentElement);
                return axParents(_start.parentElement, _end, containStart, containEnd, parents)
            } else {
                return parents;
            }
        } else {
            parents.push(_start.parentElement);
            return axParents(_start.parentElement, _end, containStart, containEnd, parents)
        }
    } else {
        return parents;
    }
}
/**
 * 定义动画曲线
 * 举例：axCurves.easeOutIn(0.3)
 */
const axCurves = {
    linear(t) { return t; },
    easeIn(t) { return t * t * t; },
    easeOut(t) { return (t - 1) * (t - 1) * (t - 1) + 1; },
    easeInOut(t) { return t < 0.5 ? 2 * t * t : -2(t - 1) * (t - 1) + 1; },
    easeOutIn(t) { return t < 0.5 ? Math.sqrt(0.5 * t) : -Math.sqrt(0.5 * (-t + 1)) + 1; }
};
/**
 * 定义axSlideDown动画
 * 举例：axSlideDown(elem,200,'easeOut')
 */
const axSlideDown = (elem, callback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem),
        dftTime = height => height / 3 + 250,
        rawStyle = element.style.cssText;
    if (window.getComputedStyle(element).display === "none") {
        element.style.cssText = `${rawStyle}display: block;`;
        const { height, paddingTop, paddingBottom, marginTop, marginBottom } = axArrHeight(element);
        let time;
        if (duration !== undefined && typeof duration === 'number') {
            time = duration;
        } else {
            time = dftTime(height);
        }
        element.style.cssText = `${rawStyle}display: block; padding-top: 0; padding-bottom: 0;margin-top: 0; margin-bottom: 0;`;
        const initTime = new Date().getTime();
        const repeat = () => {
            const newTime = new Date().getTime() - initTime;
            const timestep = newTime / time;
            const timefactor = axCurves[curve](timestep);
            const step = 0 + height * timefactor;
            const stepPaddingT = 0 + (paddingTop * timefactor);
            const stepPaddingB = 0 + (paddingBottom * timefactor);
            const stepMarginT = 0 + (marginTop * timefactor);
            const stepMarginB = 0 + (marginBottom * timefactor);
            if (newTime <= time && Math.ceil(step) < height) {
                element.style.cssText = `${rawStyle}overflow:hidden;display: block; padding-top: ${stepPaddingT}px; padding-bottom: ${stepPaddingB}px;margin-top: ${stepMarginT}px; margin-bottom: ${stepMarginB}px; height: ${step}px`;
            } else {
                element.style.cssText = `${rawStyle}display: block;`;
            }
            const repeatLoop = requestAnimationFrame(repeat);
            if (Math.ceil(step) >= height || !height) {
                cancelAnimationFrame(repeatLoop);
                callback && callback();
            }
        };
        repeat();
    }
    return element;
};
/**
 * 不判断元素是否隐藏的下拉展开动画
 */
const axHeightDown = (elem, arrHeight, callback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem),
        dftTime = height => height / 3 + 250;
    const height = (arrHeight && arrHeight.height) ? arrHeight.height : axArrHeight(element).height,
        paddingTop = (arrHeight && arrHeight.paddingTop) ? arrHeight.paddingTop : axArrHeight(element).paddingTop,
        paddingBottom = (arrHeight && arrHeight.paddingBottom) ? arrHeight.paddingBottom : axArrHeight(element).paddingBottom,
        marginTop = (arrHeight && arrHeight.marginTop) ? arrHeight.marginTop : axArrHeight(element).marginTop,
        marginBottom = (arrHeight && arrHeight.marginBottom) ? arrHeight.marginBottom : axArrHeight(element).marginBottom;
    let time;
    if (duration !== undefined && typeof duration === 'number') {
        time = duration;
    } else {
        time = dftTime(height);
    }
    element.style.overflow = 'hidden';
    element.style.height = 0;
    paddingTop ? element.style.paddingTop = 0 : null;
    paddingBottom ? element.style.paddingBottom = 0 : null;
    marginTop ? element.style.marginTop = 0 : null;
    marginBottom ? element.style.marginBottom = 0 : null;
    const initTime = new Date().getTime();
    const repeat = () => {
        const newTime = new Date().getTime() - initTime;
        const timestep = newTime / time;
        const timefactor = axCurves[curve](timestep);
        const step = 0 + height * timefactor;
        const stepPaddingT = 0 + (paddingTop * timefactor);
        const stepPaddingB = 0 + (paddingBottom * timefactor);
        const stepMarginT = 0 + (marginTop * timefactor);
        const stepMarginB = 0 + (marginBottom * timefactor);
        if (newTime <= time && Math.ceil(step) < height) {
            element.style.height = step + 'px';
            paddingTop ? element.style.paddingTop = stepPaddingT + 'px' : null;
            paddingBottom ? element.style.paddingBottom = stepPaddingB + 'px' : null;
            marginTop ? element.style.marginTop = stepMarginT + 'px' : null;
            marginBottom ? element.style.marginBottom = stepMarginB + 'px' : null;
        } else {
            element.style.height = height + 'px';
            paddingTop ? element.style.paddingTop = paddingTop + 'px' : null;
            paddingBottom ? element.style.paddingBottom = paddingBottom + 'px' : null;
            marginTop ? element.style.marginTop = marginTop + 'px' : null;
            marginBottom ? element.style.marginBottom = marginBottom + 'px' : null;
        }
        const repeatLoop = requestAnimationFrame(repeat);
        if (Math.ceil(step) >= height || !height) {
            cancelAnimationFrame(repeatLoop);
            callback && callback();
        }
    };
    repeat();
    return element;
};
/**
 * 定义axSlideUp动画
 * 举例：axSlideUp(elem,200,'easeOut')
 */
const axSlideUp = (elem, callback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem),
        dftTime = height => height / 3 + 250,
        rawStyle = element.style.cssText;
    if (window.getComputedStyle(element).display !== "none") {
        const { height, paddingTop, paddingBottom, marginTop, marginBottom } = axArrHeight(element);
        let time;
        if (duration !== undefined && typeof duration === 'number') {
            time = duration;
        } else {
            time = dftTime(height);
        }
        element.style.cssText = `${rawStyle}display: block; padding-top: 0; padding-bottom: 0;margin-top: 0; margin-bottom: 0;`;
        const initTime = new Date().getTime();
        const repeat = () => {
            const newTime = new Date().getTime() - initTime;
            const timestep = newTime / time;
            const timefactor = axCurves[curve](timestep);
            const step = height + -height * timefactor;
            const stepPaddingT = paddingTop + (-paddingTop * timefactor);
            const stepPaddingB = paddingBottom + (-paddingBottom * timefactor);
            const stepMarginT = marginTop + (-marginTop * timefactor);
            const stepMarginB = marginBottom + (-marginBottom * timefactor);
            if (newTime <= time && Math.floor(step) > 0) {
                element.style.cssText = `${rawStyle}overflow:hidden;display: block; padding-top: ${stepPaddingT}px; padding-bottom: ${stepPaddingB}px;margin-top: ${stepMarginT}px; margin-bottom: ${stepMarginB}px; height: ${step}px`;
            } else {
                element.style.cssText = `${rawStyle}display: none`;
            }
            const repeatLoop = requestAnimationFrame(repeat);
            if (Math.floor(step) <= 0 || !height) {
                cancelAnimationFrame(repeatLoop);
                callback && callback();
            }
        };
        repeat();
    }
    return element;
};
/**
 * 不判断元素是否隐藏的上拉隐藏动画
 */
const axHeightUp = (elem, arrHeight, callback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    let dftTime = height => height / 3 + 250;
    const height = (arrHeight && arrHeight.height) ? arrHeight.height : axArrHeight(element).height,
        paddingTop = (arrHeight && arrHeight.paddingTop) ? arrHeight.paddingTop : axArrHeight(element).paddingTop,
        paddingBottom = (arrHeight && arrHeight.paddingBottom) ? arrHeight.paddingBottom : axArrHeight(element).paddingBottom,
        marginTop = (arrHeight && arrHeight.marginTop) ? arrHeight.marginTop : axArrHeight(element).marginTop,
        marginBottom = (arrHeight && arrHeight.marginBottom) ? arrHeight.marginBottom : axArrHeight(element).marginBottom;
    let time;
    if (duration !== undefined && typeof duration === 'number') {
        time = duration;
    } else {
        time = dftTime(height);
    }
    element.style.overflow = 'hidden';
    const initTime = new Date().getTime();
    const repeat = () => {
        const newTime = new Date().getTime() - initTime;
        const timestep = newTime / time;
        const timefactor = axCurves[curve](timestep);
        const step = height + -height * timefactor;
        const stepPaddingT = paddingTop + (-paddingTop * timefactor);
        const stepPaddingB = paddingBottom + (-paddingBottom * timefactor);
        const stepMarginT = marginTop + (-marginTop * timefactor);
        const stepMarginB = marginBottom + (-marginBottom * timefactor);
        if (newTime <= time && Math.floor(step) > 0) {
            element.style.height = step + 'px';
            paddingTop ? element.style.paddingTop = stepPaddingT + 'px' : null;
            paddingBottom ? element.style.paddingBottom = stepPaddingB + 'px' : null;
            marginTop ? element.style.marginTop = stepMarginT + 'px' : null;
            marginBottom ? element.style.marginBottom = stepMarginB + 'px' : null;
        } else {
            element.style.height = 0;
            paddingTop ? element.style.paddingTop = 0 : null;
            paddingBottom ? element.style.paddingBottom = 0 : null;
            marginTop ? element.style.marginTop = 0 : null;
            marginBottom ? element.style.marginBottom = 0 : null;
        }
        const repeatLoop = requestAnimationFrame(repeat);
        if (Math.floor(step) <= 0 || !height) {
            cancelAnimationFrame(repeatLoop);
            callback && callback();
        }
    };
    repeat();
    return element;
};
/**
 * 定义axSlideToggle动画
 * 举例：axSlideToggle(elem,200,'easeOut')
 */
const axSlideToggle = (elem, downCallback, upCallback, duration, curve = 'easeOut') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    if (window.getComputedStyle(element).display === 'none') {
        axSlideDown(element, downCallback, duration, curve);
    } else {
        axSlideUp(element, upCallback, duration, curve);
    }
    return element;
}
/**
 * 定义axFadeIn动画
 * 举例：axFadeIn(elem,200,'linear')
 */
const axFadeIn = (elem, dis, callback, duration = 200, curve = 'linear') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    if (element) {
        let display = window.getComputedStyle(element).display,
            opacity = window.getComputedStyle(element).opacity;
        if (display === 'none') {
            element.style.display = !dis ? 'block' : dis;
            element.style.opacity = 0;
            let initTime = new Date().getTime();
            let repeat = () => {
                let newTime = new Date().getTime() - initTime,
                    timestep = newTime / duration,
                    step = axCurves[curve](timestep);
                if (newTime <= duration && step <= 1) {
                    element.style.display = !dis ? 'block' : dis;
                    element.style.opacity = step;
                } else {
                    element.style.display = !dis ? 'block' : dis;
                    element.style.opacity = 1;
                }
                let repeatLoop = requestAnimationFrame(repeat);
                if (step >= 1) {
                    cancelAnimationFrame(repeatLoop);
                }
            };
            repeat();
        } else if (display !== 'none' && Number(opacity) !== 1) {
            let initTime = new Date().getTime();
            let repeat = () => {
                let newTime = new Date().getTime() - initTime,
                    timestep = newTime / duration,
                    step = axCurves[curve](timestep) + Number(opacity);
                if (newTime <= duration && step <= 1) {
                    element.style.display = display;
                    element.style.opacity = step;
                } else {
                    element.style.display = display;
                    element.style.opacity = 1;
                }
                let repeatLoop = requestAnimationFrame(repeat);
                if (step >= 1) {
                    cancelAnimationFrame(repeatLoop);
                }
            };
            repeat();
        }
    }
    callback && callback();
    return element;
};
/**
 * 定义axFadeOut动画
 * 举例：axFadeOut(elem,200,'linear')
 */
const axFadeOut = (elem, callback, duration = 200, curve = 'linear') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    if (element) {
        let display = window.getComputedStyle(element).display,
            opacity = window.getComputedStyle(element).opacity;
        if (display !== 'none' || Number(opacity) !== 0) {
            element.style.opacity = opacity;
            let initTime = new Date().getTime();
            let repeat = () => {
                let newTime = new Date().getTime() - initTime,
                    timestep = newTime / duration,
                    step = Number(opacity) - axCurves[curve](timestep);
                if (newTime <= duration && step > 0) {
                    element.style.opacity = step;
                } else {
                    element.style.opacity = 0;
                    element.style.display = 'none';
                }
                let repeatLoop = requestAnimationFrame(repeat);
                if (step <= 0) {
                    cancelAnimationFrame(repeatLoop);
                }
            };
            repeat();
        }
    }
    callback && callback();
    return element;
};
/**
 * 定义axFadeToggle动画
 * 举例：axFadeToggle(elem,200,'linear')
 */
const axFadeToggle = (elem, dis, inCallback, outCallback, duration = 200, curve = 'linear') => {
    if (!elem) { console.error(axError.notExist); return false; }
    let element = axIdToDom(elem);
    if (element) {
        let display = window.getComputedStyle(element).display;
        let opacity = window.getComputedStyle(element).opacity;
        if (display === 'none') {
            axFadeIn(element, dis, inCallback, duration, curve);
        } else if (Number(opacity) <= 0.5) {
            axFadeIn(element, dis, inCallback, duration, curve);
        } else if (Number(opacity) > 0.5) {
            axFadeOut(element, outCallback, duration, curve);
        } else {
            axFadeOut(element, outCallback, duration, curve);
        }
    }
    return element;
}
/**
 * 定义axShow动画（元素显示），因为有些元素显示方式可以是inline-block、block、visible或box，所以需要使用show来设定，如果不填则优先使用block
 * 举例：axShow(elem,show,callback)
 */
const axShow = (element, show, callback) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    if (show == 'visible') {
        elem.style.visibility = 'visible';
    } else if (show) {
        elem.style.display = show;
    } else {
        elem.style.display = 'block';
    }
    callback && callback();
}
/**
 * 定义axHide动画(元素隐藏)，根据实际情况选择隐藏方式来设置hide参数，可选none和hidden，如果不填则优先使用none
 * 举例：axHide(elem,hide,callback)
 */
const axHide = (element, hide, callback) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    if (hide == 'hidden') {
        elem.style.visibility = 'hidden';
    } else {
        elem.style.display = 'none';
    }
    callback && callback();
}
/**
 * 元素显示隐藏切换，show和hide参数如上面两个函数所述
 * 举例: axToggle(elem,show,hide)
 */
const axToggle = (element, show, hide, showCallback, hideCallback) => {
    if (!element) { console.error(axError.notExist); return false; }
    let elem = axIdToDom(element);
    axIsVisible(elem) ? axHide(elem, hide, hideCallback) : axShow(elem, show, showCallback);
}
/**
 * 页面锚记滚动
 * 举例：axScrollTo(elem,target,2000,'easeOut')
 */
const axScrollTo = (element, duration, curve = 'easeOut') => {
    let offsetScrolled = document.documentElement.scrollTop,
        initTime = new Date().getTime(),
        offsetClient = element ? axIdToDom(element).getBoundingClientRect().top : -offsetScrolled;
    if (!duration || typeof duration !== 'number') {
        duration = Math.abs(offsetClient) / 4 + 1000;
    }
    let repeat = () => {
        let newTime = new Date().getTime() - initTime,
            timestep = newTime / duration,
            step = offsetScrolled + offsetClient * axCurves[curve](timestep);
        window.scrollTo(0, step);
        repeat.timer = requestAnimationFrame(repeat);
        if (newTime >= duration) {
            window.scrollTo(0, step);
            cancelAnimationFrame(repeat.timer);
        }
    };
    repeat();
    return element;
};
/**
 * 定义常用图标
 */
const axIcon = {
    font: {
        success: '<i class="ax-iconfont ax-icon-check-o"></i>',
        error: '<i class="ax-iconfont ax-icon-close-o"></i>',
        warning: '<i class="ax-iconfont ax-icon-warning-o"></i>',
        info: '<i class="ax-iconfont ax-icon-info-o"></i>',
        question: '<i class="ax-iconfont ax-icon-question-o"></i>',
        successFill: '<i class="ax-iconfont ax-icon-check-o-f"></i>',
        errorFill: '<i class="ax-iconfont ax-icon-close-o-f"></i>',
        warningFill: '<i class="ax-iconfont ax-icon-warning-o-f"></i>',
        infoFill: '<i class="ax-iconfont ax-icon-info-o-f"></i>',
        questionFill: '<i class="ax-iconfont ax-icon-question-o-f"></i>',
    },
    svg: {
        success: '<svg class="svg-success" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-in-1" d="M26.316,42.859L37.9984,54.5414L60.3826,32.1572"></path></svg>',
        error: '<svg class="svg-error" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-in-1" d="M28.774,57.9246L57.9247,28.7739"></path><path class="svg-line svg-in-2" d="M57.9246,57.9246L28.7739,28.7739"></path></svg>',
        warning: '<svg class="svg-warning" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M43.4611 7.24c2.8081,0.0924 4.39,1.7 5.3045,3.1159l17.4543 29.9414 17.3445 29.7538c0.5448,1.0193 1.596,4.0544 0.1109,6.4168 -1.4849,2.3626 -3.6815,2.9155 -5.3768,2.992l-34.9082 0.0002 -34.6892 -0.0002c-1.1636,-0.0421 -4.3433,-0.6583 -5.6666,-3.1131 -1.3232,-2.4549 -0.7085,-4.6157 0.0723,-6.1078l17.454 -29.9417 17.3449 -29.7537c0.6185,-0.977 2.7471,-3.396 5.5554,-3.3036z"></path><path class="svg-line svg-out" d="M43.4611 7.24c2.8081,0.0924 4.39,1.7 5.3045,3.1159l17.4543 29.9414 17.3445 29.7538c0.5448,1.0193 1.596,4.0544 0.1109,6.4168 -1.4849,2.3626 -3.6815,2.9155 -5.3768,2.992l-34.9082 0.0002 -34.6892 -0.0002c-1.1636,-0.0421 -4.3433,-0.6583 -5.6666,-3.1131 -1.3232,-2.4549 -0.7085,-4.6157 0.0723,-6.1078l17.454 -29.9417 17.3449 -29.7537c0.6185,-0.977 2.7471,-3.396 5.5554,-3.3036z"></path><path class="svg-line svg-in-1" d="M43.3493,27.8713L43.3493,57.2858"></path><circle class="svg-circle svg-in-2" cx="43.3492" cy="64.3337" r="2.1166"></circle></svg>',
        info: '<svg class="svg-info" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-in-1" d="M43.3493,65.0602L43.3493,30.9723"></path><circle class="svg-circle svg-in-2" cx="43.3492" cy="23.5856" r="2.1166"></circle></svg>',
        question: '<svg class="svg-question" xmlns="http://www.w3.org/2000/svg" width="86.6986mm" height="86.6986mm" viewBox="0 0 86.6986 86.6986"><path class="svg-line svg-bg" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path><path class="svg-line svg-in-1" d="M32.3757 35.7255c-0.2203,-11.823 12.5789,-14.1087 18.4056,-9.4189 5.4663,4.3995 4.7426,12.804 -3.1088,17.9938 -3.0015,1.9839 -3.0003,3.8403 -3.0003,10.1707"></path><circle class="svg-circle svg-in-2" cx="44.6612" cy="60.5502" r="2.1166"></circle></svg>',
    },
};
/**
 * 定义常用图片
 */
const axImage = {
    loadSvg: getComputedStyle(document.documentElement).getPropertyValue('--load-svg').trim().split('"')[1],
    loadSvgW: getComputedStyle(document.documentElement).getPropertyValue('--load-svg-w').trim().split('"')[1],
    loadGif: getComputedStyle(document.documentElement).getPropertyValue('--load-gif').trim().split('"')[1],
    imgAvatar: 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iMTYwcHgiIGhlaWdodD0iMTYwcHgiIHZpZXdCb3g9IjAgMCAxNjAgMTYwIj4NCjxyZWN0IHk9IjAiIGZpbGw9IiNGRkZGRkYiIHdpZHRoPSI4MCIgaGVpZ2h0PSIxNjAiLz4NCjxyZWN0IHg9IjgwIiBmaWxsPSIjRjRGNEY0IiB3aWR0aD0iODAiIGhlaWdodD0iMTYwIi8+DQo8cGF0aCBmaWxsPSIjQjJCMkIyIiBkPSJNOTguOTE2LDk3LjI1MmMxMC4zOTMtNi4zODIsMTcuMzQtMTcuODUxLDE3LjM0LTMwLjkxNmMwLTE5Ljk5Mi0xNi4yNjYtMzYuMjU1LTM2LjI1Ny0zNi4yNTUNCgljLTE5Ljk5MiwwLTM2LjI1NSwxNi4yNjMtMzYuMjU1LDM2LjI1NWMwLDEzLjA2NCw2Ljk0NiwyNC41MzQsMTcuMzM4LDMwLjkxNkMzNC4xMTQsMTA1LjM3MSwxNC40NjcsMTMwLjM4NywxNC40NjcsMTYwaDEzMS4wNjYNCglDMTQ1LjUzMywxMzAuMzg3LDEyNS44ODUsMTA1LjM3MSw5OC45MTYsOTcuMjUyeiIvPg0KPC9zdmc+DQo=',
    imgNone: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciICB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2MHB4IiBoZWlnaHQ9IjE2MHB4IiB2aWV3Qm94PSIwIDAgMTYwIDE2MCI+DQo8cmVjdCBmaWxsPSIjRkZGRkZGIiB3aWR0aD0iMTYwIiBoZWlnaHQ9IjE2MCIvPg0KPGc+DQoJPGc+DQoJCTxnPg0KCQkJPHBhdGggZmlsbD0iI0M5Q0FDQSIgZD0iTTc5LjA4Nyw4Ny44Nkg2MS45ODNjLTEuNzE3LDAtMy4xMDgtMS4yMjMtMy4xMDktMi43M3YtMi4xMTFsOS4xNjMtNi45NThsMy4yODQsMi44NDENCgkJCQljMS43MDgsMS40ODYsNC40MjIsMS41ODUsNi4yNjIsMC4yMjhMOTMuMDcsNjcuNjI1bDYuMjI2LDUuNDc5YzAuNjI4LDAuNTkxLDAuODkyLDAuODU4LDEuNTgsMC44NTgNCgkJCQljMC40OTMsMCwwLjkwNC0wLjI0NCwxLjIxOS0wLjU4N2MwLjMzMy0wLjM2MywwLjMxMS0xLjIzOCwwLjMxMS0xLjY3MlY1Ny44MWMwLTMuMDE4LTIuNzgzLTUuNDY1LTYuMjE4LTUuNDY1SDYxLjk4Mw0KCQkJCWMtMy40MzUsMC02LjIxOCwyLjQ0Ny02LjIxOCw1LjQ2NXYyNy4zMmMwLDEuNDQ4LDAuNjU1LDIuODM5LDEuODIxLDMuODYzYzEuMTY3LDEuMDIzLDIuNzQ5LDEuNjAxLDQuMzk3LDEuNjAxaDE3LjA3MQ0KCQkJCWMwLjc5NSwwLDEuNTI1LTAuNTY3LDEuNTgyLTEuMjY1YzAuMDY1LTAuOC0wLjY1My0xLjQ2Ny0xLjU0Ny0xLjQ2N0w3OS4wODcsODcuODZ6IE01OC44NzUsNTcuODENCgkJCQljMC0xLjUwOSwxLjM5Mi0yLjczMiwzLjEwOS0yLjczMmgzNC4yMDNjMS43MTgsMCwzLjEwOSwxLjIyMywzLjEwOSwyLjczMnYxMS40MzRsLTQuMTIzLTMuNjI5DQoJCQkJYy0xLjE1Mi0wLjg1Ny0yLjg0LTAuODYtMy45OTYtMC4wMDhMNzUuNTg3LDc3LjAyOWMtMC42MTMsMC40NDktMS41MTMsMC40MTctMi4wODItMC4wNzVsLTMuMjg3LTIuODQNCgkJCQljLTEuMTU5LTAuOTkzLTIuOTg5LTEuMDQ0LTQuMjE2LTAuMTIxbC03LjEyNyw1LjQyTDU4Ljg3NSw1Ny44MUw1OC44NzUsNTcuODF6IE02Ny4wMDQsNjQuMjE1YzAsMS42NTgsMC45OTksMy4xNTMsMi41MywzLjc4Nw0KCQkJCWMxLjUzMiwwLjYzNSwzLjI5NSwwLjI4NSw0LjQ2Ny0wLjg4OGMxLjE3My0xLjE3MiwxLjUyMi0yLjkzNSwwLjg4OS00LjQ2NmMtMC42MzUtMS41MzEtMi4xMjktMi41MzEtMy43ODctMi41MzENCgkJCQljLTEuMDg3LDAtMi4xMywwLjQzMi0yLjg5OCwxLjJDNjcuNDM2LDYyLjA4Niw2Ny4wMDQsNjMuMTI3LDY3LjAwNCw2NC4yMTVMNjcuMDA0LDY0LjIxNXogTTEwMi4zMzgsNzkuNzM3DQoJCQkJYzMuNzM3LDMuNzMzLDMuNzM3LDkuNzg2LDAsMTMuNTJjLTMuNzM1LDMuNzM1LTkuNzg5LDMuNzM2LTEzLjUyMywwYy0zLjY4Mi0zLjc0NC0zLjY1NS05Ljc1NCwwLjA1Ny0xMy40NjMNCgkJCQlDOTIuNTgzLDc2LjA4Miw5OC41OTUsNzYuMDU2LDEwMi4zMzgsNzkuNzM3TDEwMi4zMzgsNzkuNzM3eiBNOTAuNzQ1LDkxLjMyNWMyLjI5NSwyLjI5NCw1Ljg4NiwyLjY1Nyw4LjU5MywwLjg2OWwtOS40NjItOS40NjQNCgkJCQljLTEuNzg3LDIuNzA2LTEuNDI0LDYuMjk4LDAuODY5LDguNTkyVjkxLjMyNXogTTEwMS4yNzIsOTAuMjU5YzEuNzgyLTIuNzA4LDEuNDE2LTYuMjk1LTAuODc1LTguNTg1DQoJCQkJYy0yLjI5My0yLjI5LTUuODc5LTIuNjU3LTguNTg3LTAuODc1TDEwMS4yNzIsOTAuMjU5eiBNMTAxLjI3Miw5MC4yNTkiLz4NCgkJPC9nPg0KCTwvZz4NCgk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDU0LjgyMzcgMTEwLjU1MDgpIiBmaWxsPSIjQzlDQUNBIiBmb250LWZhbWlseT0iJ01pY3Jvc29mdFlhSGVpJyIgZm9udC1zaXplPSIxMi41ODc3Ij7mmoLml6Dlm77niYc8L3RleHQ+DQo8L2c+DQo8L3N2Zz4NCg==',
    empty: 'data:image/svg+xml;base64,PHN2ZyB0PSIxNTg5ODk5NTI1MTA0IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBwLWlkPSIyNTI5IiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTExOC44MjY5NzEgMTM4LjQwOTE0M2E3Ljk2ODA0MSA3Ljk2ODA0MSAwIDAgMCA3LjkyMDYxMi03LjkyMDYxMlYxMTEuMzUxMDAzYTcuOTIwNjEyIDcuOTIwNjEyIDAgMSAwLTE1Ljg0MTIyNSAwdjE5LjE3MzA5OWE3Ljk2ODA0MSA3Ljk2ODA0MSAwIDAgMCA3LjkyMDYxMyA3LjkyMDYxM3ogbTE0LjU5NjIxOCAxNC41OTYyMThoMTkuMTg0OTU2YTcuOTIwNjEyIDcuOTIwNjEyIDAgMSAwIDAtMTUuODQxMjI0SDEzMy40MzUwNDZhNy45MjA2MTIgNy45MjA2MTIgMCAxIDAgMCAxNS44NDEyMjR6IG0tMjkuMTkyNDM3LTE1Ljc4MTkzOEg4NS4wNTc2NTNhNy45MjA2MTIgNy45MjA2MTIgMCAwIDAgMCAxNS44NDEyMjRoMTkuMTczMDk5YTcuOTIwNjEyIDcuOTIwNjEyIDAgMCAwIDAtMTUuODQxMjI0eiBtMTQuNTk2MjE5IDE0LjU4NDM2MWE3Ljk2ODA0MSA3Ljk2ODA0MSAwIDAgMC03LjkyMDYxMyA3LjkyMDYxMnYxOS4xNzMwOTlhNy45MjA2MTIgNy45MjA2MTIgMCAwIDAgMTUuODQxMjI1IDB2LTE5LjE0OTM4NWE3Ljk2ODA0MSA3Ljk2ODA0MSAwIDAgMC03LjkyMDYxMi03LjkyMDYxMnogbTc4OC41MDQwNyAxMTguMjc1NjFhMzguNzI1NjI4IDM4LjcyNTYyOCAwIDEgMCAzOC43MjU2MjggMzguNzI1NjI5IDM4LjY3ODIgMzguNjc4MiAwIDAgMC0zOC43NjEyLTM4Ljc4NDkxNXogbTAgNjEuNDkxNDZhMjIuODg0NDA0IDIyLjg4NDQwNCAwIDEgMSAyMi44ODQ0MDMtMjIuODg0NDAzIDIyLjkxOTk3NSAyMi45MTk5NzUgMCAwIDEtMjIuODg0NDAzIDIyLjg4NDQwM3pNNjkyLjUyNTkzMiA0Ny44NzkzOWEyMy41MDA5NzggMjMuNTAwOTc4IDAgMSAwLTIzLjUwMDk3OS0yMy41MDA5NzggMjMuNTAwOTc4IDIzLjUwMDk3OCAwIDAgMCAyMy41MDA5NzkgMjMuNTAwOTc4eiBtMC0zMS4zMDMwMTlhNy42NzE2MTEgNy42NzE2MTEgMCAxIDEtNy42NzE2MTEgNy42NzE2MTEgNy43MDcxODMgNy43MDcxODMgMCAwIDEgNy42NzE2MTEtNy42NzE2MTF6IG0wIDAiIGZpbGw9IiNlNmU2ZTYiIHAtaWQ9IjI1MzAiPjwvcGF0aD48cGF0aCBkPSJNMjc1Ljc2ODkyMyA5OTIuODE1NTUzYzAgMTEuMTQ1NzcyIDM4LjE1NjQ4MyAyMS4zNDI5NjcgOTkuODQ5NTE2IDI2Ljk2MzI4MmExMTk3LjE4NjMyMyAxMTk3LjE4NjMyMyAwIDAgMCAxOTkuOTEyNDYgMGM2MS45MDY0NjItNS41NzI4ODYgOTkuODQ5NTE1LTE1LjgxNzUxIDk5Ljg0OTUxNi0yNi45NjMyODJzLTM4LjE1NjQ4My0yMS4zNDI5NjctOTkuODQ5NTE2LTI2Ljk2MzI4MmExMTk3LjAyMDMyMiAxMTk3LjAyMDMyMiAwIDAgMC0xOTkuOTEyNDYgMGMtNjEuNjU3NDYxIDUuNTcyODg2LTk5Ljg0OTUxNSAxNS44MTc1MS05OS44NDk1MTYgMjYuOTYzMjgyeiBtMCAwIiBmaWxsPSIjZjBmMGYwIiBwLWlkPSIyNTMxIj48L3BhdGg+PHBhdGggZD0iTTU3MS4wMjUxNjIgNDgyLjg5NjQ5M2E3Ljc2NjQ2OSA3Ljc2NjQ2OSAwIDAgMC0xMS4xMzM5MTUgMGwtMTEuOTk5NDkgMTEuOTk5NDktMTEuOTk5NDkxLTExLjk5OTQ5YTcuODczMTgzIDcuODczMTgzIDAgMSAwLTExLjEzMzkxNCAxMS4xMzM5MTRsMTEuOTk5NDkgMTEuOTk5NDkxLTExLjk5OTQ5IDExLjk5OTQ5YTcuOTU2MTg0IDcuOTU2MTg0IDAgMSAwIDExLjI1MjQ4NiAxMS4yNTI0ODdsMTEuOTk5NDkxLTExLjk5OTQ5MSAxMS45OTk0OSAxMS45OTk0OTFhNy43NzgzMjYgNy43NzgzMjYgMCAwIDAgNS41NzI4ODYgMi4zNzE0NDEgNy41NzY3NTMgNy41NzY3NTMgMCAwIDAgNS41NzI4ODYtMi4zNzE0NDEgNy43NjY0NjkgNy43NjY0NjkgMCAwIDAgMC0xMS4xMzM5MTVsLTExLjk5OTQ5LTExLjk5OTQ5IDExLjk5OTQ5LTExLjk5OTQ5MWE4LjExMDMyOCA4LjExMDMyOCAwIDAgMC0wLjExODU3Mi0xMS4yNTI0ODZ6IG0tMTU0LjkwMjUxNCA0Ni4zOTcyMzlhNy44NzMxODMgNy44NzMxODMgMCAwIDAgNS41NzI4ODYgMi4zNzE0NDEgNy44NzMxODMgNy44NzMxODMgMCAwIDAgNS41NzI4ODYtMTMuNDgxNjQxbC0xMS45OTk0OTEtMTEuOTk5NDkxIDExLjk5OTQ5MS0xMS45OTk0OWE3Ljc2NjQ2OSA3Ljc2NjQ2OSAwIDAgMCAwLTExLjEzMzkxNSA3Ljk5MTc1NiA3Ljk5MTc1NiAwIDAgMC0xMS4yNjQzNDQgMGwtMTEuOTk5NDkxIDExLjk5OTQ5MS0xMS45OTk0OS0xMS45OTk0OTFhNy45OTE3NTYgNy45OTE3NTYgMCAwIDAtMTEuMjY0MzQ0IDAgNy43NjY0NjkgNy43NjY0NjkgMCAwIDAgMCAxMS4xMzM5MTVsMTEuOTk5NDkxIDExLjk5OTQ5LTExLjk5OTQ5MSAxMS45OTk0OTFhNy43NjY0NjkgNy43NjY0NjkgMCAwIDAgMCAxMS4xMzM5MTUgNy43NzgzMjYgNy43NzgzMjYgMCAwIDAgNS41NzI4ODYgMi4zNzE0NCA3LjU3Njc1MyA3LjU3Njc1MyAwIDAgMCA1LjU3Mjg4Ni0yLjM3MTQ0bDExLjk5OTQ5LTExLjk5OTQ5MXogbTU5Ljg3ODg4IDgzLjM5MTcxNmExMDcuMzkwNjk3IDEwNy4zOTA2OTcgMCAwIDAtNzcuNDUxMjU2IDMyLjY1NDc0IDcuOTU2MTg0IDcuOTU2MTg0IDAgMCAwIDAuMTE4NTcyIDExLjEzMzkxNSA3LjgzNzYxMiA3LjgzNzYxMiAwIDAgMCAxMS4xMzM5MTQtMC4xMTg1NzIgOTIuNjE2NjIxIDkyLjYxNjYyMSAwIDAgMSAxMzIuMzg1Njg0IDAgOC4xNTc3NTYgOC4xNTc3NTYgMCAwIDAgNS42OTE0NTcgMi4zNzE0NDEgNy44MjU3NTUgNy44MjU3NTUgMCAwIDAgNy4zMDQwMzgtNC44MjU4ODIgOC4wMTU0NyA4LjAxNTQ3IDAgMCAwLTEuNjEyNTgtOC42NTU3NTkgMTA3Ljc1ODI3MSAxMDcuNzU4MjcxIDAgMCAwLTc3LjU2OTgyOS0zMi41MzYxNjh6IG0wIDAiIGZpbGw9IiNkYmRiZGIiIHAtaWQ9IjI1MzIiPjwvcGF0aD48cGF0aCBkPSJNNzY4LjYwMTc1MyAzMTMuODcyMDQ5bC04Mi4xNDY3MS05MS42Nzk5MDJhOTQuMjI5MjAxIDk0LjIyOTIwMSAwIDAgMC03MC4xNDcyMTktMzEuMzAzMDE5SDI0Ni41MDUzNDRhODUuOTA1NDQzIDg1LjkwNTQ0MyAwIDAgMC04NS44NTgwMTUgODUuODU4MDE1djU2NC42NTE5MTRhODUuOTA1NDQzIDg1LjkwNTQ0MyAwIDAgMCA4NS44NTgwMTUgODUuODU4MDE1aDQ1OS40OTAzNzJhODUuOTA1NDQzIDg1LjkwNTQ0MyAwIDAgMCA4NS44NTgwMTQtODUuODU4MDE1VjM3NC42MTY1MDVhOTEuMDYzMzI3IDkxLjA2MzMyNyAwIDAgMC0yMy4yNjM4MzQtNjAuNzQ0NDU2eiBtLTk0LjAyNzYyOC04MS4xNjI1NjJsODIuMTQ2NzEgOTEuNjc5OTAyYTc3LjQyNzU0MyA3Ny40Mjc1NDMgMCAwIDEgMTQuMjI4NjQ1IDIzLjI2MzgzNGgtODUuNDkwNDQyYTM4Ljk2Mjc3MyAzOC45NjI3NzMgMCAwIDEtMzguOTc0NjMtMzguOTc0NjN2LTk1Ljg3NzM1MmE3Ny4yODUyNTYgNzcuMjg1MjU2IDAgMCAxIDI4LjA4OTcxNyAxOS45MjAxMDN6IG0xMDEuNDUwMjM4IDYwOC43MDE0MjhhNzAuMTIzNTA1IDcwLjEyMzUwNSAwIDAgMS03MC4wMjg2NDcgNzAuMDI4NjQ3SDI0Ni41MDUzNDRhNzAuMTIzNTA1IDcwLjEyMzUwNSAwIDAgMS03MC4wMjg2NDctNzAuMDI4NjQ3VjI3Ni43NDcxNDNhNzAuMTIzNTA1IDcwLjEyMzUwNSAwIDAgMSA3MC4wMjg2NDctNzAuMDI4NjQ3aDM2OS44MDI0OGE3OS40NDMyNjcgNzkuNDQzMjY3IDAgMCAxIDE0LjM0NzIxNyAxLjM2MzU3OHYxMDAuNTg0NjYyYTU0LjkxMDcxMiA1NC45MTA3MTIgMCAwIDAgNTQuODAzOTk3IDU0LjgwMzk5N2g4OS42OTk3NDlhODQuMzUyMTUgODQuMzUyMTUgMCAwIDEgMC44NjU1NzYgMTEuMTMzOTE1djQ2Ni43OTQ0MDl6IG0wIDAiIGZpbGw9IiNkYmRiZGIiIHAtaWQ9IjI1MzMiPjwvcGF0aD48L3N2Zz4=',
}
/**
 * 定义结果函数
 */
const axResult = (elem, state) => {
    if (!elem) { console.error(axError.notExist); return false; }
    let dom = axIdToDom(elem),
        svg = '';
    switch (state) {
        case 'success':
            svg = `<path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path>
            <path class="svg-line svg-in-1" d="M26.316,42.859L37.9984,54.5414L60.3826,32.1572"></path>`;
            dom.querySelector('svg').classList.add('svg-success');
            break;
        case 'error':
            svg = `<path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path>
            <path class="svg-line svg-in-1" d="M28.774,57.9246L57.9247,28.7739"></path>
            <path class="svg-line svg-in-2" d="M57.9246,57.9246L28.7739,28.7739"></path>`;
            dom.querySelector('svg').classList.add('svg-error');
            break;
        case 'question':
            svg = `<path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path>
            <path class="svg-line svg-in-1" d="M32.3757 35.7255c-0.2203,-11.823 12.5789,-14.1087 18.4056,-9.4189 5.4663,4.3995 4.7426,12.804 -3.1088,17.9938 -3.0015,1.9839 -3.0003,3.8403 -3.0003,10.1707"></path>
            <circle class="svg-circle svg-in-2" cx="44.6612" cy="60.5502" r="2.1166"></circle>`;
            dom.querySelector('svg').classList.add('svg-question');
            break;
        case 'info':
            svg = `<path class="svg-line svg-out" d="M7.238500000000002,43.3493A36.1108,36.1108 0,1,1 79.4601,43.3493A36.1108,36.1108 0,1,1 7.238500000000002,43.3493"></path>
            <path class="svg-line svg-in-1" d="M43.3493,65.0602L43.3493,30.9723"></path>
            <circle class="svg-circle svg-in-2" cx="43.3492" cy="23.5856" r="2.1166"></circle>`;
            dom.querySelector('svg').classList.add('svg-info');
            break;
    }
    dom.classList.add('ax-result-show');
    if (dom.querySelector('svg').innerHTML.indexOf('svg-in-1') == -1) {
        dom.querySelector('svg').insertAdjacentHTML('beforeend', svg);
    }
}
/**
 * 获取主体内容，适用于dialog|drawer|popup
 */
const axCreateContent = (options, instance, type = 'post', callback) => {
    let html = options.content, promise;
    if (options.type == 'html' && typeof options.content === 'string' && axStrType(options.content) == 'id') {
        options.content = document.querySelector(options.content).innerHTML;
    } else if (options.type == 'html' && typeof options.content === 'function') {
        options.content = options.content.call(instance);
    } else if (options.type == 'async' && options.url) {
        if (axStrType(options.url) == 'id') {
            let ajaxUrl = options.url.match(/(\S*)\#/)[1],
                ajaxSelector = '#' + options.url.match(/\#(\S*)/)[1],
                content = options.content;
            promise = axAjax({
                url: ajaxUrl,
                type: type || 'post',
                selector: ajaxSelector,
                before: (loading) => {
                    options.content = loading;
                },
                success: (data) => {
                    options.content = data;
                    if (typeof content === 'function') {
                        instance.content.innerHTML = content(data);
                    } else {
                        instance.content.innerHTML = data;
                    }
                    callback && callback();
                }
            });
        } else {
            let content = options.content;
            promise = axAjax({
                url: options.url,
                type: type || 'post',
                before: (loading) => {
                    options.content = loading;
                },
                success: (data) => {
                    options.content = data;
                    if (typeof content === 'function') {
                        instance.content.innerHTML = content(data);
                    } else {
                        instance.content.innerHTML = data;
                    }
                    callback && callback();
                }
            });
        }
    } else if (options.type == 'iframe' && options.url) {
        options.content = `<iframe src="${options.url}" frameborder="0" width="100%" height="100%"></iframe>`;
        options.footerShow = false;
    } else if (options.content) {
        options.content = options.content;
    } else {
        options.content = '没有任何内容！';
    }
    if (options.type == 'picture' && options.url) {
        options.content = `
        <div class="ax-media-container"><img src="${options.url}" /></div>
        <div class="ax-media-title">${options.name}</div>
        ${html}
        `;
    } else if (options.type == 'video' && options.url) {
        options.content = `
        <div class="ax-media-container"><video src="${options.url}" controls="controls" ></video></div>
        <div class="ax-media-title">${options.name}</div>
        ${html}
        `;
    } else if (options.type == 'audio' && options.url) {
        options.content = `
        <div class="ax-media-container"><audio src="${options.url}" controls="controls" ></audio></div>
        <div class="ax-media-title">${options.name}</div>
        ${html}
        `;
    }
    return { content: options.content, xhr: promise ? promise.xhr : null };
}
/**
 * 获取底部内容，适用于dialog|drawer|popup
 */
const axFooterBtns = (options, instance) => {
    let lineBreak = options.footerBreak ? `<div class="ax-break-line"></div>` : '';
    let footer = '';
    options.note ? options.note = `<div class="ax-note">${options.note}</div>` : null
    if (!options.footerShow) {
        footer = '';
    } else if (options.footerType == 'right') {
        let btnCancel = '',
            btnConfirm = '',
            btnDiy = '';
        options.confirm.text ? btnConfirm = `<a href="###" class="ax-btn ax-primary ${options.confirm.classname}"  confirm>${options.confirm.icon}${options.confirm.text}</a>` : null;
        options.cancel.text ? btnCancel = `<a href="###" class="ax-btn ax-text ax-ignore ${options.cancel.classname}"  cancel>${options.cancel.icon}${options.cancel.text}</a>` : null;
        if (options.diy.text && options.diy.callback) {
            btnDiy = `<a href="###" class="ax-btn ax-text ${options.diy.classname}"  diy>${options.diy.icon}${options.diy.text}</a>`;
        } else if (options.diy.text && !options.diy.callback) {
            btnDiy = `<a href="${options.diy.url}" target="${options.diy.url}" class="ax-btn ax-text ${options.diy.classname}"  diy>${options.diy.icon}${options.diy.text}</a>`;
        }
        footer = `
                                        ${lineBreak}
                                        <div class="ax-padding">
                                              <div class="ax-row">
                                                  <div class="ax-col">
                                                  ${options.note}
                                                  </div>
                                                  <div class="ax-btns">${btnDiy}${btnCancel}${btnConfirm}</div>
                                              </div>
                                          </div>
                          `;
    } else if (options.footerType == 'line') {
        let btnCancel = '',
            btnConfirm = '',
            btnDiy = '';
        options.confirm.text ? btnConfirm = `<a href="###" class="ax-col ax-col-12 ${options.confirm.classname}"  confirm>${options.confirm.icon}${options.confirm.text}</a>` : null;
        options.cancel.text ? btnCancel = `<a href="###" class="ax-col ax-col-12 ${options.cancel.classname}"  cancel>${options.cancel.icon}${options.cancel.text}</a><span class="ax-gutter-line"></span>` : null;
        if (options.diy.text && options.diy.callback) {
            btnDiy = `<a href="###" class="ax-col ax-col-12 ${options.diy.classname}"  diy>${options.diy.icon}${options.diy.text}</a><span class="ax-gutter-line"></span>`;
        } else if (options.diy.text && !options.diy.callback) {
            btnDiy = `<a href="${options.diy.url}" target="${options.diy.url}" class="ax-col ax-col-12 ${options.diy.classname}"  diy>${options.diy.icon}${options.diy.text}</a><span class="ax-gutter-line"></span>`;
        }
        footer = `
                          <div class="ax-break-line"></div>
                          <div class="ax-row">${btnDiy}${btnCancel}${btnConfirm}</div>${options.note}
                          `
    } else {
        let btnCancel = '',
            btnConfirm = '',
            btnDiy = '';
        options.confirm.text ? btnConfirm = `<a href="###" class="ax-btn ax-primary ${options.confirm.classname}"  confirm>${options.confirm.icon}${options.confirm.text}</a>` : null;
        options.cancel.text ? btnCancel = `<a href="###" class="ax-btn ax-ignore ${options.cancel.classname}" cancel>${options.cancel.icon}${options.cancel.text}</a>` : null;
        if (options.diy.text && options.diy.callback) {
            btnDiy = `<a href="###" class="ax-btn ${options.diy.classname}" diy>${options.diy.icon}${options.diy.text}</a>`;
        } else if (options.diy.text && !options.diy.callback) {
            btnDiy = `<a href="${options.diy.url}" target="${options.diy.url}" class="ax-btn ${options.diy.classname}" diy>${options.diy.icon}${options.diy.text}</a>`;
        }
        footer = `
                                        ${lineBreak}
                                         <div class="ax-padding ax-align-center">${btnDiy}${btnCancel}${btnConfirm}</div>
                                         <div class="ax-break"></div>${options.note}
                         `
    }
    return footer;
}
/**
 * 日期时间均转成本地时间戳
 * 类似2021-1-12和2021-01-12字符“-”均转成“/”分隔
 * axLocalTime('2070-1-20') - new Date(axLocalTime('2070-1-20')).getTimezoneOffset() * 60000) % 86400000 = 0 （能整除）
 * new Date('2070-01-20 12:11:13').getTime() == new Date('2070-1-20 12:11:13').getTime() == axLocalTime('2070-1-20 12:11:13')
 * new Date('2070/1/20').getTime() == new Date('2070-01-20').getTime() == axLocalTime('2070-1-20',true)
 * new Date('2070-1-20').getTime() == axLocalTime('2070-1-20')
 * axLocalTime('2070-1-20')和new Date(axLocalTime('2070-1-20'))可以互转
*/
const axLocalTime = (date, utc) => {
    let para, localDate, flag, loacalTime, localOffset;
    if (date) {
        date = date.trim();
        localDate = new Date(date);
        flag = localDate instanceof Date && !isNaN(localDate.getTime());
        if (!flag) {
            return console.error('Date format must be "YYYY-MM-DD" or "YYYY/MM/DD"');
        }
        para = date.replace(/-/g, "/");
        loacalTime = new Date(para).getTime();
        if (para.indexOf(':') !== -1) {
            localOffset = 0
        } else {
            localOffset = new Date(para).getTimezoneOffset() * 60000;
        }
    } else {
        loacalTime = new Date().getTime();
        localOffset = 0;
    }
    if (utc) {
        return loacalTime - localOffset;
    } else {
        return loacalTime;
    }
}
/**
 * 将元素内容转成数组[{x:'',y:'',z:''}],主要用于axLightbox
 */
const axCreateData = (
    src,
    roles = ['src', 'cover', 'caption', 'type'],
    keys = ['media', 'cover', 'caption', 'type'],
    node = 'figure',
    dft = ['', '', '', 'image'],
    callback
) => {
    let data = [],
        string = '';
    /* 
        if (axTypeIs('Array', src)) {
            string = JSON.stringify(src);
        } else if (axTypeIs('Object', src)) {
            string = JSON.stringify(src)
        } else if (axTypeIs('String', src)) {
            if (src.substr(0, 1) == '#') {
                data = axTplToArr(src, roles, keys, node, dft)
            } else {
                data = axStrToArr(src, keys, dft);
            }
        } */
    if (axTypeIs('String', src) && axStrType(src) == 'id') {
        data = axTplToArr(src, roles, keys, node, dft);
    } else {
        if (axTypeIs('Array', src) || axTypeIs('Object', src)) {
            string = JSON.stringify(src);
        } else if (axTypeIs('String', src)) {
            string = src;
        }
        data = axStrToArr(string, keys, dft);
    }
    data = data.filter(i => i[keys[0]]);
    callback && callback(data);
    return data;
}
/**
 * 数组多重排序，已用在axList和axSheet插件中
*/
const axSort = (data, sorts, type) => {
    let sortsArr = [];
    if (!Array.isArray(sorts)) {
        sorts.order ? sortsArr.push(sorts) : null;
    } else {
        sortsArr = sorts.filter(k => k.order);
    }
    let orders = (a, b, fields) => {
        if (fields.length == 0) {
            return 0;
        }
        let field = fields.shift(),
            col = field.col,
            order = field.order,
            attr = field.attr || 'label',
            flag,
            left,
            right;
        if (type == 'table') {
            if (typeof col == 'number') {
                left = a.children.filter(i => i.index === col)[0][attr];
                right = b.children.filter(i => i.index === col)[0][attr];
            } else {
                left = a.children.find(i => i.name === col)[attr];
                right = b.children.find(i => i.name === col)[attr];
            }
        } else {
            left = a[col];
            right = b[col]
        }
        if (isNaN(left - right)) {
            flag = (order === 'desc') ? right.localeCompare(left, 'zh-CN-u-kf-lower') : left.localeCompare(right, 'zh-CN-u-kf-lower');
        } else {
            flag = (order === 'desc') ? right - left : left - right;
        }
        return left === right ? orders(a, b, fields) : flag;
    }
    return data.sort((a, b) => {
        return orders(a, b, [...sortsArr]);
    });
}
/*!
 * 插件：表单序列化；使用方法：new axSerialize('#id')
 * 支持将表单值序列化为以“&”连接的字符串，和对象数组[{name:'',value:''},...]
 */
const axSerialize = (element, type = "string", separator = ',') => {
    let inputs,
        items = [],
        output;
    if (Array.isArray(element)) {
        inputs = element;
    } else {
        inputs = [...axIdToDom(element).querySelectorAll('[name]')].filter(i => ['INPUT', 'SELECT', 'TEXTAREA'].includes(i.nodeName) && i.name && !i.name.includes('_ax_alt'));
    }
    inputs.forEach(i => {
        let have = items.find(k => k.name == i.name);
        if (have) {
            if (i.type == 'checkbox' || i.type == 'radio') {
                have.dom.push(i);
            }
        } else {
            items.push({ name: i.name, type: i.type, dom: [i] })
        }
    });
    items.forEach(i => {
        if (i.type == 'file') {
            i.value = axMultiValues(i.dom[0], 'file', 'array');
        } else if (i.type == 'checkbox') {
            i.value = axMultiValues(i.dom, 'checkbox', 'string', '', separator);
        } else if (i.type == 'radio') {
            i.value = axMultiValues(i.dom, 'radio', 'string');
        } else if (i.type.includes('select')) {
            i.value = axMultiValues(i.dom[0], 'select', 'string', '', separator);
        } else {
            i.value = i.dom[0].value;
        }
    });
    if (type == 'string') {
        let str = '';
        items.forEach(k => {
            str += '&' + k.name + '=' + k.value;
        });
        output = str;
    } else if (type == 'json') {
        let obj = {}
        items.forEach(k => {
            obj[k.name] = k.value;
        });
        output = obj;
    } else if (type == 'array') {
        items.forEach(k => {
            delete k.type;
            delete k.dom;
        })
        output = items;
    }
    return output;
}
/*!
 * 轮播插件axSwipe，使用方法：new axSwipe('#id',{参数})。源自Swiper v8.1.4 from https://swiperjs.com | AXUI做了部分修改
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.axSwiper = factory());
    document.querySelectorAll('[axSwiper]').forEach(element => {
        new axSwiper(element,axAttrToJson(element, 'axSwiper'));
    });
})(this, (function () {
    'use strict';
    /**
     * SSR Window 4.0.2
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2021, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: December 13, 2021
     */
    /* eslint-disable no-param-reassign */
    function isObject$1(obj) {
        return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
    }
    function extend$1(target, src) {
        if (target === void 0) {
            target = {};
        }
        if (src === void 0) {
            src = {};
        }
        Object.keys(src).forEach(key => {
            if (typeof target[key] === 'undefined') target[key] = src[key]; else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
                extend$1(target[key], src[key]);
            }
        });
    }
    const ssrDocument = {
        body: {},
        addEventListener() { },
        removeEventListener() { },
        activeElement: {
            blur() { },
            nodeName: ''
        },
        querySelector() {
            return null;
        },
        querySelectorAll() {
            return [];
        },
        getElementById() {
            return null;
        },
        createEvent() {
            return {
                initEvent() { }
            };
        },
        createElement() {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute() { },
                getElementsByTagName() {
                    return [];
                }
            };
        },
        createElementNS() {
            return {};
        },
        importNode() {
            return null;
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: ''
        }
    };
    function getDocument() {
        const doc = typeof document !== 'undefined' ? document : {};
        extend$1(doc, ssrDocument);
        return doc;
    }
    const ssrWindow = {
        document: ssrDocument,
        navigator: {
            userAgent: ''
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: ''
        },
        history: {
            replaceState() { },
            pushState() { },
            go() { },
            back() { }
        },
        CustomEvent: function CustomEvent() {
            return this;
        },
        addEventListener() { },
        removeEventListener() { },
        getComputedStyle() {
            return {
                getPropertyValue() {
                    return '';
                }
            };
        },
        Image() { },
        Date() { },
        screen: {},
        setTimeout() { },
        clearTimeout() { },
        matchMedia() {
            return {};
        },
        requestAnimationFrame(callback) {
            if (typeof setTimeout === 'undefined') {
                callback();
                return null;
            }
            return setTimeout(callback, 0);
        },
        cancelAnimationFrame(id) {
            if (typeof setTimeout === 'undefined') {
                return;
            }
            clearTimeout(id);
        }
    };
    function getWindow() {
        const win = typeof window !== 'undefined' ? window : {};
        extend$1(win, ssrWindow);
        return win;
    }
    /**
     * Dom7 4.0.4
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2022, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: January 11, 2022
     */
    /* eslint-disable no-proto */
    function makeReactive(obj) {
        const proto = obj.__proto__;
        Object.defineProperty(obj, '__proto__', {
            get() {
                return proto;
            },
            set(value) {
                proto.__proto__ = value;
            }
        });
    }
    class Dom7 extends Array {
        constructor(items) {
            if (typeof items === 'number') {
                super(items);
            } else {
                super(...(items || []));
                makeReactive(this);
            }
        }
    }
    function arrayFlat(arr) {
        if (arr === void 0) {
            arr = [];
        }
        const res = [];
        arr.forEach(el => {
            if (Array.isArray(el)) {
                res.push(...arrayFlat(el));
            } else {
                res.push(el);
            }
        });
        return res;
    }
    function arrayFilter(arr, callback) {
        return Array.prototype.filter.call(arr, callback);
    }
    function arrayUnique(arr) {
        const uniqueArray = [];
        for (let i = 0; i < arr.length; i += 1) {
            if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
        }
        return uniqueArray;
    }
    function qsa(selector, context) {
        if (typeof selector !== 'string') {
            return [selector];
        }
        const a = [];
        const res = context.querySelectorAll(selector);
        for (let i = 0; i < res.length; i += 1) {
            a.push(res[i]);
        }
        return a;
    }
    function $(selector, context) {
        const window = getWindow();
        const document = getDocument();
        let arr = [];
        if (!context && selector instanceof Dom7) {
            return selector;
        }
        if (!selector) {
            return new Dom7(arr);
        }
        if (typeof selector === 'string') {
            const html = selector.trim();
            if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                let toCreate = 'div';
                if (html.indexOf('<li') === 0) toCreate = 'ul';
                if (html.indexOf('<tr') === 0) toCreate = 'tbody';
                if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
                if (html.indexOf('<tbody') === 0) toCreate = 'table';
                if (html.indexOf('<option') === 0) toCreate = 'select';
                const tempParent = document.createElement(toCreate);
                tempParent.innerHTML = html;
                for (let i = 0; i < tempParent.childNodes.length; i += 1) {
                    arr.push(tempParent.childNodes[i]);
                }
            } else {
                arr = qsa(selector.trim(), context || document);
            } 
        } else if (selector.nodeType || selector === window || selector === document) {
            arr.push(selector);
        } else if (Array.isArray(selector)) {
            if (selector instanceof Dom7) return selector;
            arr = selector;
        }
        return new Dom7(arrayUnique(arr));
    }
    $.fn = Dom7.prototype; 
    function addClass() {
        for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
            classes[_key] = arguments[_key];
        }
        const classNames = arrayFlat(classes.map(c => c.split(' ')));
        this.forEach(el => {
            el.classList.add(...classNames);
        });
        return this;
    }
    function removeClass() {
        for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            classes[_key2] = arguments[_key2];
        }
        const classNames = arrayFlat(classes.map(c => c.split(' ')));
        this.forEach(el => {
            el.classList.remove(...classNames);
        });
        return this;
    }
    function toggleClass() {
        for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            classes[_key3] = arguments[_key3];
        }
        const classNames = arrayFlat(classes.map(c => c.split(' ')));
        this.forEach(el => {
            classNames.forEach(className => {
                el.classList.toggle(className);
            });
        });
    }
    function hasClass() {
        for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            classes[_key4] = arguments[_key4];
        }
        const classNames = arrayFlat(classes.map(c => c.split(' ')));
        return arrayFilter(this, el => {
            return classNames.filter(className => el.classList.contains(className)).length > 0;
        }).length > 0;
    }
    function attr(attrs, value) {
        if (arguments.length === 1 && typeof attrs === 'string') {
            if (this[0]) return this[0].getAttribute(attrs);
            return undefined;
        } 
        for (let i = 0; i < this.length; i += 1) {
            if (arguments.length === 2) {
                this[i].setAttribute(attrs, value);
            } else {
                for (const attrName in attrs) {
                    this[i][attrName] = attrs[attrName];
                    this[i].setAttribute(attrName, attrs[attrName]);
                }
            }
        }
        return this;
    }
    function removeAttr(attr) {
        for (let i = 0; i < this.length; i += 1) {
            this[i].removeAttribute(attr);
        }
        return this;
    }
    function transform(transform) {
        for (let i = 0; i < this.length; i += 1) {
            this[i].style.transform = transform;
        }
        return this;
    }
    function transition$1(duration) {
        for (let i = 0; i < this.length; i += 1) {
            this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
        }
        return this;
    }
    function on() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
        }
        let [eventType, targetSelector, listener, capture] = args;
        if (typeof args[1] === 'function') {
            [eventType, listener, capture] = args;
            targetSelector = undefined;
        }
        if (!capture) capture = false;
        function handleLiveEvent(e) {
            const target = e.target;
            if (!target) return;
            const eventData = e.target.dom7EventData || [];
            if (eventData.indexOf(e) < 0) {
                eventData.unshift(e);
            }
            if ($(target).is(targetSelector)) listener.apply(target, eventData); else {
                const parents = $(target).parents(); 
                for (let k = 0; k < parents.length; k += 1) {
                    if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
                }
            }
        }
        function handleEvent(e) {
            const eventData = e && e.target ? e.target.dom7EventData || [] : [];
            if (eventData.indexOf(e) < 0) {
                eventData.unshift(e);
            }
            listener.apply(this, eventData);
        }
        const events = eventType.split(' ');
        let j;
        for (let i = 0; i < this.length; i += 1) {
            const el = this[i];
            if (!targetSelector) {
                for (j = 0; j < events.length; j += 1) {
                    const event = events[j];
                    if (!el.dom7Listeners) el.dom7Listeners = {};
                    if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
                    el.dom7Listeners[event].push({
                        listener,
                        proxyListener: handleEvent
                    });
                    el.addEventListener(event, handleEvent, capture);
                }
            } else {
                for (j = 0; j < events.length; j += 1) {
                    const event = events[j];
                    if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
                    if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
                    el.dom7LiveListeners[event].push({
                        listener,
                        proxyListener: handleLiveEvent
                    });
                    el.addEventListener(event, handleLiveEvent, capture);
                }
            }
        }
        return this;
    }
    function off() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
        }
        let [eventType, targetSelector, listener, capture] = args;
        if (typeof args[1] === 'function') {
            [eventType, listener, capture] = args;
            targetSelector = undefined;
        }
        if (!capture) capture = false;
        const events = eventType.split(' ');
        for (let i = 0; i < events.length; i += 1) {
            const event = events[i];
            for (let j = 0; j < this.length; j += 1) {
                const el = this[j];
                let handlers;
                if (!targetSelector && el.dom7Listeners) {
                    handlers = el.dom7Listeners[event];
                } else if (targetSelector && el.dom7LiveListeners) {
                    handlers = el.dom7LiveListeners[event];
                }
                if (handlers && handlers.length) {
                    for (let k = handlers.length - 1; k >= 0; k -= 1) {
                        const handler = handlers[k];
                        if (listener && handler.listener === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (!listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        }
                    }
                }
            }
        }
        return this;
    }
    function trigger() {
        const window = getWindow();
        for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
            args[_key9] = arguments[_key9];
        }
        const events = args[0].split(' ');
        const eventData = args[1];
        for (let i = 0; i < events.length; i += 1) {
            const event = events[i];
            for (let j = 0; j < this.length; j += 1) {
                const el = this[j];
                if (window.CustomEvent) {
                    const evt = new window.CustomEvent(event, {
                        detail: eventData,
                        bubbles: true,
                        cancelable: true
                    });
                    el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
                    el.dispatchEvent(evt);
                    el.dom7EventData = [];
                    delete el.dom7EventData;
                }
            }
        }
        return this;
    }
    function transitionEnd$1(callback) {
        const dom = this;
        function fireCallBack(e) {
            if (e.target !== this) return;
            callback.call(this, e);
            dom.off('transitionend', fireCallBack);
        }
        if (callback) {
            dom.on('transitionend', fireCallBack);
        }
        return this;
    }
    function outerWidth(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                const styles = this.styles();
                return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
            }
            return this[0].offsetWidth;
        }
        return null;
    }
    function outerHeight(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                const styles = this.styles();
                return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
            }
            return this[0].offsetHeight;
        }
        return null;
    }
    function offset() {
        if (this.length > 0) {
            const window = getWindow();
            const document = getDocument();
            const el = this[0];
            const box = el.getBoundingClientRect();
            const body = document.body;
            const clientTop = el.clientTop || body.clientTop || 0;
            const clientLeft = el.clientLeft || body.clientLeft || 0;
            const scrollTop = el === window ? window.scrollY : el.scrollTop;
            const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
            return {
                top: box.top + scrollTop - clientTop,
                left: box.left + scrollLeft - clientLeft
            };
        }
        return null;
    }
    function styles() {
        const window = getWindow();
        if (this[0]) return window.getComputedStyle(this[0], null);
        return {};
    }
    function css(props, value) {
        const window = getWindow();
        let i;
        if (arguments.length === 1) {
            if (typeof props === 'string') {
                if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
            } else {
                for (i = 0; i < this.length; i += 1) {
                    for (const prop in props) {
                        this[i].style[prop] = props[prop];
                    }
                }
                return this;
            }
        }
        if (arguments.length === 2 && typeof props === 'string') {
            for (i = 0; i < this.length; i += 1) {
                this[i].style[props] = value;
            }
            return this;
        }
        return this;
    }
    function each(callback) {
        if (!callback) return this;
        this.forEach((el, index) => {
            callback.apply(el, [el, index]);
        });
        return this;
    }
    function filter(callback) {
        const result = arrayFilter(this, callback);
        return $(result);
    }
    function html(html) {
        if (typeof html === 'undefined') {
            return this[0] ? this[0].innerHTML : null;
        }
        for (let i = 0; i < this.length; i += 1) {
            this[i].innerHTML = html;
        }
        return this;
    }
    function text(text) {
        if (typeof text === 'undefined') {
            return this[0] ? this[0].textContent.trim() : null;
        }
        for (let i = 0; i < this.length; i += 1) {
            this[i].textContent = text;
        }
        return this;
    }
    function is(selector) {
        const window = getWindow();
        const document = getDocument();
        const el = this[0];
        let compareWith;
        let i;
        if (!el || typeof selector === 'undefined') return false;
        if (typeof selector === 'string') {
            if (el.matches) return el.matches(selector);
            if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
            if (el.msMatchesSelector) return el.msMatchesSelector(selector);
            compareWith = $(selector);
            for (i = 0; i < compareWith.length; i += 1) {
                if (compareWith[i] === el) return true;
            }
            return false;
        }
        if (selector === document) {
            return el === document;
        }
        if (selector === window) {
            return el === window;
        }
        if (selector.nodeType || selector instanceof Dom7) {
            compareWith = selector.nodeType ? [selector] : selector;
            for (i = 0; i < compareWith.length; i += 1) {
                if (compareWith[i] === el) return true;
            }
            return false;
        }
        return false;
    }
    function index() {
        let child = this[0];
        let i;
        if (child) {
            i = 0; 
            while ((child = child.previousSibling) !== null) {
                if (child.nodeType === 1) i += 1;
            }
            return i;
        }
        return undefined;
    }
    function eq(index) {
        if (typeof index === 'undefined') return this;
        const length = this.length;
        if (index > length - 1) {
            return $([]);
        }
        if (index < 0) {
            const returnIndex = length + index;
            if (returnIndex < 0) return $([]);
            return $([this[returnIndex]]);
        }
        return $([this[index]]);
    }
    function append() {
        let newChild;
        const document = getDocument();
        for (let k = 0; k < arguments.length; k += 1) {
            newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];
            for (let i = 0; i < this.length; i += 1) {
                if (typeof newChild === 'string') {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = newChild;
                    while (tempDiv.firstChild) {
                        this[i].appendChild(tempDiv.firstChild);
                    }
                } else if (newChild instanceof Dom7) {
                    for (let j = 0; j < newChild.length; j += 1) {
                        this[i].appendChild(newChild[j]);
                    }
                } else {
                    this[i].appendChild(newChild);
                }
            }
        }
        return this;
    }
    function prepend(newChild) {
        const document = getDocument();
        let i;
        let j;
        for (i = 0; i < this.length; i += 1) {
            if (typeof newChild === 'string') {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = newChild;
                for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
                    this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                }
            } else if (newChild instanceof Dom7) {
                for (j = 0; j < newChild.length; j += 1) {
                    this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                }
            } else {
                this[i].insertBefore(newChild, this[i].childNodes[0]);
            }
        }
        return this;
    }
    function next(selector) {
        if (this.length > 0) {
            if (selector) {
                if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
                    return $([this[0].nextElementSibling]);
                }
                return $([]);
            }
            if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
            return $([]);
        }
        return $([]);
    }
    function nextAll(selector) {
        const nextEls = [];
        let el = this[0];
        if (!el) return $([]);
        while (el.nextElementSibling) {
            const next = el.nextElementSibling; 
            if (selector) {
                if ($(next).is(selector)) nextEls.push(next);
            } else nextEls.push(next);
            el = next;
        }
        return $(nextEls);
    }
    function prev(selector) {
        if (this.length > 0) {
            const el = this[0];
            if (selector) {
                if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
                    return $([el.previousElementSibling]);
                }
                return $([]);
            }
            if (el.previousElementSibling) return $([el.previousElementSibling]);
            return $([]);
        }
        return $([]);
    }
    function prevAll(selector) {
        const prevEls = [];
        let el = this[0];
        if (!el) return $([]);
        while (el.previousElementSibling) {
            const prev = el.previousElementSibling; 
            if (selector) {
                if ($(prev).is(selector)) prevEls.push(prev);
            } else prevEls.push(prev);
            el = prev;
        }
        return $(prevEls);
    }
    function parent(selector) {
        const parents = []; 
        for (let i = 0; i < this.length; i += 1) {
            if (this[i].parentNode !== null) {
                if (selector) {
                    if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
                } else {
                    parents.push(this[i].parentNode);
                }
            }
        }
        return $(parents);
    }
    function parents(selector) {
        const parents = []; 
        for (let i = 0; i < this.length; i += 1) {
            let parent = this[i].parentNode; 
            while (parent) {
                if (selector) {
                    if ($(parent).is(selector)) parents.push(parent);
                } else {
                    parents.push(parent);
                }
                parent = parent.parentNode;
            }
        }
        return $(parents);
    }
    function closest(selector) {
        let closest = this; 
        if (typeof selector === 'undefined') {
            return $([]);
        }
        if (!closest.is(selector)) {
            closest = closest.parents(selector).eq(0);
        }
        return closest;
    }
    function find(selector) {
        const foundElements = [];
        for (let i = 0; i < this.length; i += 1) {
            const found = this[i].querySelectorAll(selector);
            for (let j = 0; j < found.length; j += 1) {
                foundElements.push(found[j]);
            }
        }
        return $(foundElements);
    }
    function children(selector) {
        const children = []; 
        for (let i = 0; i < this.length; i += 1) {
            const childNodes = this[i].children;
            for (let j = 0; j < childNodes.length; j += 1) {
                if (!selector || $(childNodes[j]).is(selector)) {
                    children.push(childNodes[j]);
                }
            }
        }
        return $(children);
    }
    function remove() {
        for (let i = 0; i < this.length; i += 1) {
            if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
        }
        return this;
    }
    const Methods = {
        addClass,
        removeClass,
        hasClass,
        toggleClass,
        attr,
        removeAttr,
        transform,
        transition: transition$1,
        on,
        off,
        trigger,
        transitionEnd: transitionEnd$1,
        outerWidth,
        outerHeight,
        styles,
        offset,
        css,
        each,
        html,
        text,
        is,
        index,
        eq,
        append,
        prepend,
        next,
        nextAll,
        prev,
        prevAll,
        parent,
        parents,
        closest,
        find,
        children,
        filter,
        remove
    };
    Object.keys(Methods).forEach(methodName => {
        Object.defineProperty($.fn, methodName, {
            value: Methods[methodName],
            writable: true
        });
    });
    function deleteProps(obj) {
        const object = obj;
        Object.keys(object).forEach(key => {
            try {
                object[key] = null;
            } catch (e) {
            }
            try {
                delete object[key];
            } catch (e) {
            }
        });
    }
    function nextTick(callback, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setTimeout(callback, delay);
    }
    function now() {
        return Date.now();
    }
    function getComputedStyle$1(el) {
        const window = getWindow();
        let style;
        if (window.getComputedStyle) {
            style = window.getComputedStyle(el, null);
        }
        if (!style && el.currentStyle) {
            style = el.currentStyle;
        }
        if (!style) {
            style = el.style;
        }
        return style;
    }
    function getTranslate(el, axis) {
        if (axis === void 0) {
            axis = 'x';
        }
        const window = getWindow();
        let matrix;
        let curTransform;
        let transformMatrix;
        const curStyle = getComputedStyle$1(el);
        if (window.WebKitCSSMatrix) {
            curTransform = curStyle.transform || curStyle.webkitTransform;
            if (curTransform.split(',').length > 6) {
                curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
            } 
            transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
        } else {
            transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
            matrix = transformMatrix.toString().split(',');
        }
        if (axis === 'x') {
            if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; 
            else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); 
            else curTransform = parseFloat(matrix[4]);
        }
        if (axis === 'y') {
            if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; 
            else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); 
            else curTransform = parseFloat(matrix[5]);
        }
        return curTransform || 0;
    }
    function isObject(o) {
        return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }
    function isNode(node) {
        if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
            return node instanceof HTMLElement;
        }
        return node && (node.nodeType === 1 || node.nodeType === 11);
    }
    function extend() {
        const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
        const noExtend = ['__proto__', 'constructor', 'prototype'];
        for (let i = 1; i < arguments.length; i += 1) {
            const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
            if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
                const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
                for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                    const nextKey = keysArray[nextIndex];
                    const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                    if (desc !== undefined && desc.enumerable) {
                        if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                            if (nextSource[nextKey].__swiper__) {
                                to[nextKey] = nextSource[nextKey];
                            } else {
                                extend(to[nextKey], nextSource[nextKey]);
                            }
                        } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                            to[nextKey] = {};
                            if (nextSource[nextKey].__swiper__) {
                                to[nextKey] = nextSource[nextKey];
                            } else {
                                extend(to[nextKey], nextSource[nextKey]);
                            }
                        } else {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
        }
        return to;
    }
    function setCSSProperty(el, varName, varValue) {
        el.style.setProperty(varName, varValue);
    }
    function animateCSSModeScroll(_ref) {
        let {
            swiper,
            targetPosition,
            side
        } = _ref;
        const window = getWindow();
        const startPosition = -swiper.translate;
        let startTime = null;
        let time;
        const duration = swiper.params.speed;
        swiper.wrapperEl.style.scrollSnapType = 'none';
        window.cancelAnimationFrame(swiper.cssModeFrameID);
        const dir = targetPosition > startPosition ? 'next' : 'prev';
        const isOutOfBound = (current, target) => {
            return dir === 'next' && current >= target || dir === 'prev' && current <= target;
        };
        const animate = () => {
            time = new Date().getTime();
            if (startTime === null) {
                startTime = time;
            }
            const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
            const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
            let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
            if (isOutOfBound(currentPosition, targetPosition)) {
                currentPosition = targetPosition;
            }
            swiper.wrapperEl.scrollTo({
                [side]: currentPosition
            });
            if (isOutOfBound(currentPosition, targetPosition)) {
                swiper.wrapperEl.style.overflow = 'hidden';
                swiper.wrapperEl.style.scrollSnapType = '';
                setTimeout(() => {
                    swiper.wrapperEl.style.overflow = '';
                    swiper.wrapperEl.scrollTo({
                        [side]: currentPosition
                    });
                });
                window.cancelAnimationFrame(swiper.cssModeFrameID);
                return;
            }
            swiper.cssModeFrameID = window.requestAnimationFrame(animate);
        };
        animate();
    }
    let support;
    function calcSupport() {
        const window = getWindow();
        const document = getDocument();
        return {
            smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
            touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
            passiveListener: function checkPassiveListener() {
                let supportsPassive = false;
                try {
                    const opts = Object.defineProperty({}, 'passive', {
                        get() {
                            supportsPassive = true;
                        }
                    });
                    window.addEventListener('testPassiveListener', null, opts);
                } catch (e) {
                }
                return supportsPassive;
            }(),
            gestures: function checkGestures() {
                return 'ongesturestart' in window;
            }()
        };
    }
    function getSupport() {
        if (!support) {
            support = calcSupport();
        }
        return support;
    }
    let deviceCached;
    function calcDevice(_temp) {
        let {
            userAgent
        } = _temp === void 0 ? {} : _temp;
        const support = getSupport();
        const window = getWindow();
        const platform = window.navigator.platform;
        const ua = userAgent || window.navigator.userAgent;
        const device = {
            ios: false,
            android: false
        };
        const screenWidth = window.screen.width;
        const screenHeight = window.screen.height;
        const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); 
        let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
        const windows = platform === 'Win32';
        let macos = platform === 'MacIntel'; 
        const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
        if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
            ipad = ua.match(/(Version)\/([\d.]+)/);
            if (!ipad) ipad = [0, 1, '13_0_0'];
            macos = false;
        } 
        if (android && !windows) {
            device.os = 'android';
            device.android = true;
        }
        if (ipad || iphone || ipod) {
            device.os = 'ios';
            device.ios = true;
        } 
        return device;
    }
    function getDevice(overrides) {
        if (overrides === void 0) {
            overrides = {};
        }
        if (!deviceCached) {
            deviceCached = calcDevice(overrides);
        }
        return deviceCached;
    }
    let browser;
    function calcBrowser() {
        const window = getWindow();
        function isSafari() {
            const ua = window.navigator.userAgent.toLowerCase();
            return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
        }
        return {
            isSafari: isSafari(),
            isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
        };
    }
    function getBrowser() {
        if (!browser) {
            browser = calcBrowser();
        }
        return browser;
    }
    function Resize(_ref) {
        let {
            swiper,
            on,
            emit
        } = _ref;
        const window = getWindow();
        let observer = null;
        let animationFrame = null;
        const resizeHandler = () => {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            emit('beforeResize');
            emit('resize');
        };
        const createObserver = () => {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            observer = new ResizeObserver(entries => {
                animationFrame = window.requestAnimationFrame(() => {
                    const {
                        width,
                        height
                    } = swiper;
                    let newWidth = width;
                    let newHeight = height;
                    entries.forEach(_ref2 => {
                        let {
                            contentBoxSize,
                            contentRect,
                            target
                        } = _ref2;
                        if (target && target !== swiper.el) return;
                        newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                        newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                    });
                    if (newWidth !== width || newHeight !== height) {
                        resizeHandler();
                    }
                });
            });
            observer.observe(swiper.el);
        };
        const removeObserver = () => {
            if (animationFrame) {
                window.cancelAnimationFrame(animationFrame);
            }
            if (observer && observer.unobserve && swiper.el) {
                observer.unobserve(swiper.el);
                observer = null;
            }
        };
        const orientationChangeHandler = () => {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            emit('orientationchange');
        };
        on('init', () => {
            if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
                createObserver();
                return;
            }
            window.addEventListener('resize', resizeHandler);
            window.addEventListener('orientationchange', orientationChangeHandler);
        });
        on('destroy', () => {
            removeObserver();
            window.removeEventListener('resize', resizeHandler);
            window.removeEventListener('orientationchange', orientationChangeHandler);
        });
    }
    function Observer(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const observers = [];
        const window = getWindow();
        const attach = function (target, options) {
            if (options === void 0) {
                options = {};
            }
            const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
            const observer = new ObserverFunc(mutations => {
                if (mutations.length === 1) {
                    emit('observerUpdate', mutations[0]);
                    return;
                }
                const observerUpdate = function observerUpdate() {
                    emit('observerUpdate', mutations[0]);
                };
                if (window.requestAnimationFrame) {
                    window.requestAnimationFrame(observerUpdate);
                } else {
                    window.setTimeout(observerUpdate, 0);
                }
            });
            observer.observe(target, {
                attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
                childList: typeof options.childList === 'undefined' ? true : options.childList,
                characterData: typeof options.characterData === 'undefined' ? true : options.characterData
            });
            observers.push(observer);
        };
        const init = () => {
            if (!swiper.params.observer) return;
            if (swiper.params.observeParents) {
                const containerParents = swiper.$el.parents();
                for (let i = 0; i < containerParents.length; i += 1) {
                    attach(containerParents[i]);
                }
            } 
            attach(swiper.$el[0], {
                childList: swiper.params.observeSlideChildren
            }); 
            attach(swiper.$wrapperEl[0], {
                attributes: false
            });
        };
        const destroy = () => {
            observers.forEach(observer => {
                observer.disconnect();
            });
            observers.splice(0, observers.length);
        };
        extendParams({
            observer: false,
            observeParents: false,
            observeSlideChildren: false
        });
        on('init', init);
        on('destroy', destroy);
    }
    /* eslint-disable no-underscore-dangle */
    var eventsEmitter = {
        on(events, handler, priority) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (typeof handler !== 'function') return self;
            const method = priority ? 'unshift' : 'push';
            events.split(' ').forEach(event => {
                if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                self.eventsListeners[event][method](handler);
            });
            return self;
        },
        once(events, handler, priority) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (typeof handler !== 'function') return self;
            function onceHandler() {
                self.off(events, onceHandler);
                if (onceHandler.__emitterProxy) {
                    delete onceHandler.__emitterProxy;
                }
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }
                handler.apply(self, args);
            }
            onceHandler.__emitterProxy = handler;
            return self.on(events, onceHandler, priority);
        },
        onAny(handler, priority) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (typeof handler !== 'function') return self;
            const method = priority ? 'unshift' : 'push';
            if (self.eventsAnyListeners.indexOf(handler) < 0) {
                self.eventsAnyListeners[method](handler);
            }
            return self;
        },
        offAny(handler) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (!self.eventsAnyListeners) return self;
            const index = self.eventsAnyListeners.indexOf(handler);
            if (index >= 0) {
                self.eventsAnyListeners.splice(index, 1);
            }
            return self;
        },
        off(events, handler) {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (!self.eventsListeners) return self;
            events.split(' ').forEach(event => {
                if (typeof handler === 'undefined') {
                    self.eventsListeners[event] = [];
                } else if (self.eventsListeners[event]) {
                    self.eventsListeners[event].forEach((eventHandler, index) => {
                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                            self.eventsListeners[event].splice(index, 1);
                        }
                    });
                }
            });
            return self;
        },
        emit() {
            const self = this;
            if (!self.eventsListeners || self.destroyed) return self;
            if (!self.eventsListeners) return self;
            let events;
            let data;
            let context;
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
            }
            if (typeof args[0] === 'string' || Array.isArray(args[0])) {
                events = args[0];
                data = args.slice(1, args.length);
                context = self;
            } else {
                events = args[0].events;
                data = args[0].data;
                context = args[0].context || self;
            }
            data.unshift(context);
            const eventsArray = Array.isArray(events) ? events : events.split(' ');
            eventsArray.forEach(event => {
                if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
                    self.eventsAnyListeners.forEach(eventHandler => {
                        eventHandler.apply(context, [event, ...data]);
                    });
                }
                if (self.eventsListeners && self.eventsListeners[event]) {
                    self.eventsListeners[event].forEach(eventHandler => {
                        eventHandler.apply(context, data);
                    });
                }
            });
            return self;
        }
    };
    function updateSize() {
        const swiper = this;
        let width;
        let height;
        const $el = swiper.$el;
        if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
            width = swiper.params.width;
        } else {
            width = $el[0].clientWidth;
        }
        if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
            height = swiper.params.height;
        } else {
            height = $el[0].clientHeight;
        }
        if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
            return;
        } 
        width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
        height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
        if (Number.isNaN(width)) width = 0;
        if (Number.isNaN(height)) height = 0;
        Object.assign(swiper, {
            width,
            height,
            size: swiper.isHorizontal() ? width : height
        });
    }
    function updateSlides() {
        const swiper = this;
        function getDirectionLabel(property) {
            if (swiper.isHorizontal()) {
                return property;
            } 
            return {
                'width': 'height',
                'margin-top': 'margin-left',
                'margin-bottom ': 'margin-right',
                'margin-left': 'margin-top',
                'margin-right': 'margin-bottom',
                'padding-left': 'padding-top',
                'padding-right': 'padding-bottom',
                'marginRight': 'marginBottom'
            }[property];
        }
        function getDirectionPropertyValue(node, label) {
            return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
        }
        const params = swiper.params;
        const {
            $wrapperEl,
            size: swiperSize,
            rtlTranslate: rtl,
            wrongRTL
        } = swiper;
        const isVirtual = swiper.virtual && params.virtual.enabled;
        const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
        const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
        const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
        let snapGrid = [];
        const slidesGrid = [];
        const slidesSizesGrid = [];
        let offsetBefore = params.slidesOffsetBefore;
        if (typeof offsetBefore === 'function') {
            offsetBefore = params.slidesOffsetBefore.call(swiper);
        }
        let offsetAfter = params.slidesOffsetAfter;
        if (typeof offsetAfter === 'function') {
            offsetAfter = params.slidesOffsetAfter.call(swiper);
        }
        const previousSnapGridLength = swiper.snapGrid.length;
        const previousSlidesGridLength = swiper.slidesGrid.length;
        let spaceBetween = params.spaceBetween;
        let slidePosition = -offsetBefore;
        let prevSlideSize = 0;
        let index = 0;
        if (typeof swiperSize === 'undefined') {
            return;
        }
        if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
            spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
        }
        swiper.virtualSize = -spaceBetween; 
        if (rtl) slides.css({
            marginLeft: '',
            marginBottom: '',
            marginTop: ''
        }); else slides.css({
            marginRight: '',
            marginBottom: '',
            marginTop: ''
        }); 
        if (params.centeredSlides && params.cssMode) {
            setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
            setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
        }
        const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
        if (gridEnabled) {
            swiper.grid.initSlides(slidesLength);
        } 
        let slideSize;
        const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
            return typeof params.breakpoints[key].slidesPerView !== 'undefined';
        }).length > 0;
        for (let i = 0; i < slidesLength; i += 1) {
            slideSize = 0;
            const slide = slides.eq(i);
            if (gridEnabled) {
                swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
            }
            if (slide.css('display') === 'none') continue; 
            if (params.slidesPerView === 'auto') {
                if (shouldResetSlideSize) {
                    slides[i].style[getDirectionLabel('width')] = ``;
                }
                const slideStyles = getComputedStyle(slide[0]);
                const currentTransform = slide[0].style.transform;
                const currentWebKitTransform = slide[0].style.webkitTransform;
                if (currentTransform) {
                    slide[0].style.transform = 'none';
                }
                if (currentWebKitTransform) {
                    slide[0].style.webkitTransform = 'none';
                }
                if (params.roundLengths) {
                    slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
                } else {
                    const width = getDirectionPropertyValue(slideStyles, 'width');
                    const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
                    const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
                    const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
                    const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
                    const boxSizing = slideStyles.getPropertyValue('box-sizing');
                    if (boxSizing && boxSizing === 'border-box') {
                        slideSize = width + marginLeft + marginRight;
                    } else {
                        const {
                            clientWidth,
                            offsetWidth
                        } = slide[0];
                        slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                    }
                }
                if (currentTransform) {
                    slide[0].style.transform = currentTransform;
                }
                if (currentWebKitTransform) {
                    slide[0].style.webkitTransform = currentWebKitTransform;
                }
                if (params.roundLengths) slideSize = Math.floor(slideSize);
            } else {
                slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                if (params.roundLengths) slideSize = Math.floor(slideSize);
                if (slides[i]) {
                    slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
                }
            }
            if (slides[i]) {
                slides[i].swiperSlideSize = slideSize;
            }
            slidesSizesGrid.push(slideSize);
            if (params.centeredSlides) {
                slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
                if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                slidesGrid.push(slidePosition);
            } else {
                if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                slidesGrid.push(slidePosition);
                slidePosition = slidePosition + slideSize + spaceBetween;
            }
            swiper.virtualSize += slideSize + spaceBetween;
            prevSlideSize = slideSize;
            index += 1;
        }
        swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
        if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
            $wrapperEl.css({
                width: `${swiper.virtualSize + params.spaceBetween}px`
            });
        }
        if (params.setWrapperSize) {
            $wrapperEl.css({
                [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
            });
        }
        if (gridEnabled) {
            swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
        } 
        if (!params.centeredSlides) {
            const newSlidesGrid = [];
            for (let i = 0; i < snapGrid.length; i += 1) {
                let slidesGridItem = snapGrid[i];
                if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
                    newSlidesGrid.push(slidesGridItem);
                }
            }
            snapGrid = newSlidesGrid;
            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
                snapGrid.push(swiper.virtualSize - swiperSize);
            }
        }
        if (snapGrid.length === 0) snapGrid = [0];
        if (params.spaceBetween !== 0) {
            const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
            slides.filter((_, slideIndex) => {
                if (!params.cssMode) return true;
                if (slideIndex === slides.length - 1) {
                    return false;
                }
                return true;
            }).css({
                [key]: `${spaceBetween}px`
            });
        }
        if (params.centeredSlides && params.centeredSlidesBounds) {
            let allSlidesSize = 0;
            slidesSizesGrid.forEach(slideSizeValue => {
                allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
            });
            allSlidesSize -= params.spaceBetween;
            const maxSnap = allSlidesSize - swiperSize;
            snapGrid = snapGrid.map(snap => {
                if (snap < 0) return -offsetBefore;
                if (snap > maxSnap) return maxSnap + offsetAfter;
                return snap;
            });
        }
        if (params.centerInsufficientSlides) {
            let allSlidesSize = 0;
            slidesSizesGrid.forEach(slideSizeValue => {
                allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
            });
            allSlidesSize -= params.spaceBetween;
            if (allSlidesSize < swiperSize) {
                const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                snapGrid.forEach((snap, snapIndex) => {
                    snapGrid[snapIndex] = snap - allSlidesOffset;
                });
                slidesGrid.forEach((snap, snapIndex) => {
                    slidesGrid[snapIndex] = snap + allSlidesOffset;
                });
            }
        }
        Object.assign(swiper, {
            slides,
            snapGrid,
            slidesGrid,
            slidesSizesGrid
        });
        if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
            setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
            setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
            const addToSnapGrid = -swiper.snapGrid[0];
            const addToSlidesGrid = -swiper.slidesGrid[0];
            swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
            swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
        }
        if (slidesLength !== previousSlidesLength) {
            swiper.emit('slidesLengthChange');
        }
        if (snapGrid.length !== previousSnapGridLength) {
            if (swiper.params.watchOverflow) swiper.checkOverflow();
            swiper.emit('snapGridLengthChange');
        }
        if (slidesGrid.length !== previousSlidesGridLength) {
            swiper.emit('slidesGridLengthChange');
        }
        if (params.watchSlidesProgress) {
            swiper.updateSlidesOffset();
        }
        if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
            const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
            const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);
            if (slidesLength <= params.maxBackfaceHiddenSlides) {
                if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
            } else if (hasClassBackfaceClassAdded) {
                swiper.$el.removeClass(backFaceHiddenClass);
            }
        }
    }
    function updateAutoHeight(speed) {
        const swiper = this;
        const activeSlides = [];
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        let newHeight = 0;
        let i;
        if (typeof speed === 'number') {
            swiper.setTransition(speed);
        } else if (speed === true) {
            swiper.setTransition(swiper.params.speed);
        }
        const getSlideByIndex = index => {
            if (isVirtual) {
                return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
            }
            return swiper.slides.eq(index)[0];
        }; 
        if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
            if (swiper.params.centeredSlides) {
                swiper.visibleSlides.each(slide => {
                    activeSlides.push(slide);
                });
            } else {
                for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                    const index = swiper.activeIndex + i;
                    if (index > swiper.slides.length && !isVirtual) break;
                    activeSlides.push(getSlideByIndex(index));
                }
            }
        } else {
            activeSlides.push(getSlideByIndex(swiper.activeIndex));
        } 
        for (i = 0; i < activeSlides.length; i += 1) {
            if (typeof activeSlides[i] !== 'undefined') {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
        } 
        if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);
    }
    function updateSlidesOffset() {
        const swiper = this;
        const slides = swiper.slides;
        for (let i = 0; i < slides.length; i += 1) {
            slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
        }
    }
    function updateSlidesProgress(translate) {
        if (translate === void 0) {
            translate = this && this.translate || 0;
        }
        const swiper = this;
        const params = swiper.params;
        const {
            slides,
            rtlTranslate: rtl,
            snapGrid
        } = swiper;
        if (slides.length === 0) return;
        if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
        let offsetCenter = -translate;
        if (rtl) offsetCenter = translate; 
        slides.removeClass(params.slideVisibleClass);
        swiper.visibleSlidesIndexes = [];
        swiper.visibleSlides = [];
        for (let i = 0; i < slides.length; i += 1) {
            const slide = slides[i];
            let slideOffset = slide.swiperSlideOffset;
            if (params.cssMode && params.centeredSlides) {
                slideOffset -= slides[0].swiperSlideOffset;
            }
            const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
            const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
            const slideBefore = -(offsetCenter - slideOffset);
            const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
            const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
            if (isVisible) {
                swiper.visibleSlides.push(slide);
                swiper.visibleSlidesIndexes.push(i);
                slides.eq(i).addClass(params.slideVisibleClass);
            }
            slide.progress = rtl ? -slideProgress : slideProgress;
            slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
        }
        swiper.visibleSlides = $(swiper.visibleSlides);
    }
    function updateProgress(translate) {
        const swiper = this;
        if (typeof translate === 'undefined') {
            const multiplier = swiper.rtlTranslate ? -1 : 1; 
            translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
        }
        const params = swiper.params;
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        let {
            progress,
            isBeginning,
            isEnd
        } = swiper;
        const wasBeginning = isBeginning;
        const wasEnd = isEnd;
        if (translatesDiff === 0) {
            progress = 0;
            isBeginning = true;
            isEnd = true;
        } else {
            progress = (translate - swiper.minTranslate()) / translatesDiff;
            isBeginning = progress <= 0;
            isEnd = progress >= 1;
        }
        Object.assign(swiper, {
            progress,
            isBeginning,
            isEnd
        });
        if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
        if (isBeginning && !wasBeginning) {
            swiper.emit('reachBeginning toEdge');
        }
        if (isEnd && !wasEnd) {
            swiper.emit('reachEnd toEdge');
        }
        if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
            swiper.emit('fromEdge');
        }
        swiper.emit('progress', progress);
    }
    function updateSlidesClasses() {
        const swiper = this;
        const {
            slides,
            params,
            $wrapperEl,
            activeIndex,
            realIndex
        } = swiper;
        const isVirtual = swiper.virtual && params.virtual.enabled;
        slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
        let activeSlide;
        if (isVirtual) {
            activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
        } else {
            activeSlide = slides.eq(activeIndex);
        } 
        activeSlide.addClass(params.slideActiveClass);
        if (params.loop) {
            if (activeSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
            } else {
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
            }
        } 
        let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
        if (params.loop && nextSlide.length === 0) {
            nextSlide = slides.eq(0);
            nextSlide.addClass(params.slideNextClass);
        } 
        let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
        if (params.loop && prevSlide.length === 0) {
            prevSlide = slides.eq(-1);
            prevSlide.addClass(params.slidePrevClass);
        }
        if (params.loop) {
            if (nextSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
            } else {
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
            }
            if (prevSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
            } else {
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
            }
        }
        swiper.emitSlidesClasses();
    }
    function updateActiveIndex(newActiveIndex) {
        const swiper = this;
        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
        const {
            slidesGrid,
            snapGrid,
            params,
            activeIndex: previousIndex,
            realIndex: previousRealIndex,
            snapIndex: previousSnapIndex
        } = swiper;
        let activeIndex = newActiveIndex;
        let snapIndex;
        if (typeof activeIndex === 'undefined') {
            for (let i = 0; i < slidesGrid.length; i += 1) {
                if (typeof slidesGrid[i + 1] !== 'undefined') {
                    if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
                        activeIndex = i;
                    } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
                        activeIndex = i + 1;
                    }
                } else if (translate >= slidesGrid[i]) {
                    activeIndex = i;
                }
            } 
            if (params.normalizeSlideIndex) {
                if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
            }
        }
        if (snapGrid.indexOf(translate) >= 0) {
            snapIndex = snapGrid.indexOf(translate);
        } else {
            const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
            snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
        }
        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
        if (activeIndex === previousIndex) {
            if (snapIndex !== previousSnapIndex) {
                swiper.snapIndex = snapIndex;
                swiper.emit('snapIndexChange');
            }
            return;
        } 
        const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
        Object.assign(swiper, {
            snapIndex,
            realIndex,
            previousIndex,
            activeIndex
        });
        swiper.emit('activeIndexChange');
        swiper.emit('snapIndexChange');
        if (previousRealIndex !== realIndex) {
            swiper.emit('realIndexChange');
        }
        if (swiper.initialized || swiper.params.runCallbacksOnInit) {
            swiper.emit('slideChange');
        }
    }
    function updateClickedSlide(e) {
        const swiper = this;
        const params = swiper.params;
        const slide = $(e).closest(`.${params.slideClass}`)[0];
        let slideFound = false;
        let slideIndex;
        if (slide) {
            for (let i = 0; i < swiper.slides.length; i += 1) {
                if (swiper.slides[i] === slide) {
                    slideFound = true;
                    slideIndex = i;
                    break;
                }
            }
        }
        if (slide && slideFound) {
            swiper.clickedSlide = slide;
            if (swiper.virtual && swiper.params.virtual.enabled) {
                swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
            } else {
                swiper.clickedIndex = slideIndex;
            }
        } else {
            swiper.clickedSlide = undefined;
            swiper.clickedIndex = undefined;
            return;
        }
        if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
            swiper.slideToClickedSlide();
        }
    }
    var update = {
        updateSize,
        updateSlides,
        updateAutoHeight,
        updateSlidesOffset,
        updateSlidesProgress,
        updateProgress,
        updateSlidesClasses,
        updateActiveIndex,
        updateClickedSlide
    };
    function getSwiperTranslate(axis) {
        if (axis === void 0) {
            axis = this.isHorizontal() ? 'x' : 'y';
        }
        const swiper = this;
        const {
            params,
            rtlTranslate: rtl,
            translate,
            $wrapperEl
        } = swiper;
        if (params.virtualTranslate) {
            return rtl ? -translate : translate;
        }
        if (params.cssMode) {
            return translate;
        }
        let currentTranslate = getTranslate($wrapperEl[0], axis);
        if (rtl) currentTranslate = -currentTranslate;
        return currentTranslate || 0;
    }
    function setTranslate(translate, byController) {
        const swiper = this;
        const {
            rtlTranslate: rtl,
            params,
            $wrapperEl,
            wrapperEl,
            progress
        } = swiper;
        let x = 0;
        let y = 0;
        const z = 0;
        if (swiper.isHorizontal()) {
            x = rtl ? -translate : translate;
        } else {
            y = translate;
        }
        if (params.roundLengths) {
            x = Math.floor(x);
            y = Math.floor(y);
        }
        if (params.cssMode) {
            wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
        } else if (!params.virtualTranslate) {
            $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
        }
        swiper.previousTranslate = swiper.translate;
        swiper.translate = swiper.isHorizontal() ? x : y; 
        let newProgress;
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        if (translatesDiff === 0) {
            newProgress = 0;
        } else {
            newProgress = (translate - swiper.minTranslate()) / translatesDiff;
        }
        if (newProgress !== progress) {
            swiper.updateProgress(translate);
        }
        swiper.emit('setTranslate', swiper.translate, byController);
    }
    function minTranslate() {
        return -this.snapGrid[0];
    }
    function maxTranslate() {
        return -this.snapGrid[this.snapGrid.length - 1];
    }
    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
        if (translate === void 0) {
            translate = 0;
        }
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        if (translateBounds === void 0) {
            translateBounds = true;
        }
        const swiper = this;
        const {
            params,
            wrapperEl
        } = swiper;
        if (swiper.animating && params.preventInteractionOnTransition) {
            return false;
        }
        const minTranslate = swiper.minTranslate();
        const maxTranslate = swiper.maxTranslate();
        let newTranslate;
        if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate; 
        swiper.updateProgress(newTranslate);
        if (params.cssMode) {
            const isH = swiper.isHorizontal();
            if (speed === 0) {
                wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
            } else {
                if (!swiper.support.smoothScroll) {
                    animateCSSModeScroll({
                        swiper,
                        targetPosition: -newTranslate,
                        side: isH ? 'left' : 'top'
                    });
                    return true;
                }
                wrapperEl.scrollTo({
                    [isH ? 'left' : 'top']: -newTranslate,
                    behavior: 'smooth'
                });
            }
            return true;
        }
        if (speed === 0) {
            swiper.setTransition(0);
            swiper.setTranslate(newTranslate);
            if (runCallbacks) {
                swiper.emit('beforeTransitionStart', speed, internal);
                swiper.emit('transitionEnd');
            }
        } else {
            swiper.setTransition(speed);
            swiper.setTranslate(newTranslate);
            if (runCallbacks) {
                swiper.emit('beforeTransitionStart', speed, internal);
                swiper.emit('transitionStart');
            }
            if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onTranslateToWrapperTransitionEnd) {
                    swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
                        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
                        swiper.onTranslateToWrapperTransitionEnd = null;
                        delete swiper.onTranslateToWrapperTransitionEnd;
                        if (runCallbacks) {
                            swiper.emit('transitionEnd');
                        }
                    };
                }
                swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
                swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
            }
        }
        return true;
    }
    var translate = {
        getTranslate: getSwiperTranslate,
        setTranslate,
        minTranslate,
        maxTranslate,
        translateTo
    };
    function setTransition(duration, byController) {
        const swiper = this;
        if (!swiper.params.cssMode) {
            swiper.$wrapperEl.transition(duration);
        }
        swiper.emit('setTransition', duration, byController);
    }
    function transitionEmit(_ref) {
        let {
            swiper,
            runCallbacks,
            direction,
            step
        } = _ref;
        const {
            activeIndex,
            previousIndex
        } = swiper;
        let dir = direction;
        if (!dir) {
            if (activeIndex > previousIndex) dir = 'next'; else if (activeIndex < previousIndex) dir = 'prev'; else dir = 'reset';
        }
        swiper.emit(`transition${step}`);
        if (runCallbacks && activeIndex !== previousIndex) {
            if (dir === 'reset') {
                swiper.emit(`slideResetTransition${step}`);
                return;
            }
            swiper.emit(`slideChangeTransition${step}`);
            if (dir === 'next') {
                swiper.emit(`slideNextTransition${step}`);
            } else {
                swiper.emit(`slidePrevTransition${step}`);
            }
        }
    }
    function transitionStart(runCallbacks, direction) {
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        const {
            params
        } = swiper;
        if (params.cssMode) return;
        if (params.autoHeight) {
            swiper.updateAutoHeight();
        }
        transitionEmit({
            swiper,
            runCallbacks,
            direction,
            step: 'Start'
        });
    }
    function transitionEnd(runCallbacks, direction) {
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        const {
            params
        } = swiper;
        swiper.animating = false;
        if (params.cssMode) return;
        swiper.setTransition(0);
        transitionEmit({
            swiper,
            runCallbacks,
            direction,
            step: 'End'
        });
    }
    var transition = {
        setTransition,
        transitionStart,
        transitionEnd
    };
    function slideTo(index, speed, runCallbacks, internal, initial) {
        if (index === void 0) {
            index = 0;
        }
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        if (typeof index !== 'number' && typeof index !== 'string') {
            throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
        }
        if (typeof index === 'string') {
            /**
             * The `index` argument converted from `string` to `number`.
             * @type {number}
             */
            const indexAsNumber = parseInt(index, 10);
            /**
             * Determines whether the `index` argument is a valid `number`
             * after being converted from the `string` type.
             * @type {boolean}
             */
            const isValidNumber = isFinite(indexAsNumber);
            if (!isValidNumber) {
                throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
            } 
            index = indexAsNumber;
        }
        const swiper = this;
        let slideIndex = index;
        if (slideIndex < 0) slideIndex = 0;
        const {
            params,
            snapGrid,
            slidesGrid,
            previousIndex,
            activeIndex,
            rtlTranslate: rtl,
            wrapperEl,
            enabled
        } = swiper;
        if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
            return false;
        }
        const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
        let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
        if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
            swiper.emit('beforeSlideChangeStart');
        }
        const translate = -snapGrid[snapIndex]; 
        swiper.updateProgress(translate); 
        if (params.normalizeSlideIndex) {
            for (let i = 0; i < slidesGrid.length; i += 1) {
                const normalizedTranslate = -Math.floor(translate * 100);
                const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                if (typeof slidesGrid[i + 1] !== 'undefined') {
                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
                        slideIndex = i;
                    } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
                        slideIndex = i + 1;
                    }
                } else if (normalizedTranslate >= normalizedGrid) {
                    slideIndex = i;
                }
            }
        } 
        if (swiper.initialized && slideIndex !== activeIndex) {
            if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
                return false;
            }
            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
                if ((activeIndex || 0) !== slideIndex) return false;
            }
        }
        let direction;
        if (slideIndex > activeIndex) direction = 'next'; else if (slideIndex < activeIndex) direction = 'prev'; else direction = 'reset'; 
        if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
            swiper.updateActiveIndex(slideIndex); 
            if (params.autoHeight) {
                swiper.updateAutoHeight();
            }
            swiper.updateSlidesClasses();
            if (params.effect !== 'slide') {
                swiper.setTranslate(translate);
            }
            if (direction !== 'reset') {
                swiper.transitionStart(runCallbacks, direction);
                swiper.transitionEnd(runCallbacks, direction);
            }
            return false;
        }
        if (params.cssMode) {
            const isH = swiper.isHorizontal();
            const t = rtl ? translate : -translate;
            if (speed === 0) {
                const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                if (isVirtual) {
                    swiper.wrapperEl.style.scrollSnapType = 'none';
                    swiper._immediateVirtual = true;
                }
                wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
                if (isVirtual) {
                    requestAnimationFrame(() => {
                        swiper.wrapperEl.style.scrollSnapType = '';
                        swiper._swiperImmediateVirtual = false;
                    });
                }
            } else {
                if (!swiper.support.smoothScroll) {
                    animateCSSModeScroll({
                        swiper,
                        targetPosition: t,
                        side: isH ? 'left' : 'top'
                    });
                    return true;
                }
                wrapperEl.scrollTo({
                    [isH ? 'left' : 'top']: t,
                    behavior: 'smooth'
                });
            }
            return true;
        }
        swiper.setTransition(speed);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        if (speed === 0) {
            swiper.transitionEnd(runCallbacks, direction);
        } else if (!swiper.animating) {
            swiper.animating = true;
            if (!swiper.onSlideToWrapperTransitionEnd) {
                swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                    swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
            }
            swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
        }
        return true;
    }
    function slideToLoop(index, speed, runCallbacks, internal) {
        if (index === void 0) {
            index = 0;
        }
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        let newIndex = index;
        if (swiper.params.loop) {
            newIndex += swiper.loopedSlides;
        }
        return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }
    /* eslint no-unused-vars: "off" */
    function slideNext(speed, runCallbacks, internal) {
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        const {
            animating,
            enabled,
            params
        } = swiper;
        if (!enabled) return swiper;
        let perGroup = params.slidesPerGroup;
        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
            perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
        }
        const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
        if (params.loop) {
            if (animating && params.loopPreventsSlide) return false;
            swiper.loopFix(); 
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }
        if (params.rewind && swiper.isEnd) {
            return swiper.slideTo(0, speed, runCallbacks, internal);
        }
        return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }
    /* eslint no-unused-vars: "off" */
    function slidePrev(speed, runCallbacks, internal) {
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        const {
            params,
            animating,
            snapGrid,
            slidesGrid,
            rtlTranslate,
            enabled
        } = swiper;
        if (!enabled) return swiper;
        if (params.loop) {
            if (animating && params.loopPreventsSlide) return false;
            swiper.loopFix(); 
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }
        const translate = rtlTranslate ? swiper.translate : -swiper.translate;
        function normalize(val) {
            if (val < 0) return -Math.floor(Math.abs(val));
            return Math.floor(val);
        }
        const normalizedTranslate = normalize(translate);
        const normalizedSnapGrid = snapGrid.map(val => normalize(val));
        let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
        if (typeof prevSnap === 'undefined' && params.cssMode) {
            let prevSnapIndex;
            snapGrid.forEach((snap, snapIndex) => {
                if (normalizedTranslate >= snap) {
                    prevSnapIndex = snapIndex;
                }
            });
            if (typeof prevSnapIndex !== 'undefined') {
                prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
        }
        let prevIndex = 0;
        if (typeof prevSnap !== 'undefined') {
            prevIndex = slidesGrid.indexOf(prevSnap);
            if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
            if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
                prevIndex = Math.max(prevIndex, 0);
            }
        }
        if (params.rewind && swiper.isBeginning) {
            const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
            return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
        }
        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }
    /* eslint no-unused-vars: "off" */
    function slideReset(speed, runCallbacks, internal) {
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        const swiper = this;
        return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }
    /* eslint no-unused-vars: "off" */
    function slideToClosest(speed, runCallbacks, internal, threshold) {
        if (speed === void 0) {
            speed = this.params.speed;
        }
        if (runCallbacks === void 0) {
            runCallbacks = true;
        }
        if (threshold === void 0) {
            threshold = 0.5;
        }
        const swiper = this;
        let index = swiper.activeIndex;
        const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
        const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
        if (translate >= swiper.snapGrid[snapIndex]) {
            const currentSnap = swiper.snapGrid[snapIndex];
            const nextSnap = swiper.snapGrid[snapIndex + 1];
            if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
                index += swiper.params.slidesPerGroup;
            }
        } else {
            const prevSnap = swiper.snapGrid[snapIndex - 1];
            const currentSnap = swiper.snapGrid[snapIndex];
            if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
                index -= swiper.params.slidesPerGroup;
            }
        }
        index = Math.max(index, 0);
        index = Math.min(index, swiper.slidesGrid.length - 1);
        return swiper.slideTo(index, speed, runCallbacks, internal);
    }
    function slideToClickedSlide() {
        const swiper = this;
        const {
            params,
            $wrapperEl
        } = swiper;
        const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
        let slideToIndex = swiper.clickedIndex;
        let realIndex;
        if (params.loop) {
            if (swiper.animating) return;
            realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
            if (params.centeredSlides) {
                if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                    swiper.loopFix();
                    slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
                    nextTick(() => {
                        swiper.slideTo(slideToIndex);
                    });
                } else {
                    swiper.slideTo(slideToIndex);
                }
            } else if (slideToIndex > swiper.slides.length - slidesPerView) {
                swiper.loopFix();
                slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
                nextTick(() => {
                    swiper.slideTo(slideToIndex);
                });
            } else {
                swiper.slideTo(slideToIndex);
            }
        } else {
            swiper.slideTo(slideToIndex);
        }
    }
    var slide = {
        slideTo,
        slideToLoop,
        slideNext,
        slidePrev,
        slideReset,
        slideToClosest,
        slideToClickedSlide
    };
    function loopCreate() {
        const swiper = this;
        const document = getDocument();
        const {
            params,
            $wrapperEl
        } = swiper; 
        const $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;
        $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
        let slides = $selector.children(`.${params.slideClass}`);
        if (params.loopFillGroupWithBlank) {
            const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
            if (blankSlidesNum !== params.slidesPerGroup) {
                for (let i = 0; i < blankSlidesNum; i += 1) {
                    const blankNode = $(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
                    $selector.append(blankNode);
                }
                slides = $selector.children(`.${params.slideClass}`);
            }
        }
        if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
        swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
        swiper.loopedSlides += params.loopAdditionalSlides;
        if (swiper.loopedSlides > slides.length) {
            swiper.loopedSlides = slides.length;
        }
        const prependSlides = [];
        const appendSlides = [];
        slides.each((el, index) => {
            const slide = $(el);
            if (index < swiper.loopedSlides) {
                appendSlides.push(el);
            }
            if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
                prependSlides.push(el);
            }
            slide.attr('data-swiper-slide-index', index);
        });
        for (let i = 0; i < appendSlides.length; i += 1) {
            $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
        for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
            $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
    }
    function loopFix() {
        const swiper = this;
        swiper.emit('beforeLoopFix');
        const {
            activeIndex,
            slides,
            loopedSlides,
            allowSlidePrev,
            allowSlideNext,
            snapGrid,
            rtlTranslate: rtl
        } = swiper;
        let newIndex;
        swiper.allowSlidePrev = true;
        swiper.allowSlideNext = true;
        const snapTranslate = -snapGrid[activeIndex];
        const diff = snapTranslate - swiper.getTranslate(); 
        if (activeIndex < loopedSlides) {
            newIndex = slides.length - loopedSlides * 3 + activeIndex;
            newIndex += loopedSlides;
            const slideChanged = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged && diff !== 0) {
                swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
        } else if (activeIndex >= slides.length - loopedSlides) {
            newIndex = -slides.length + activeIndex + loopedSlides;
            newIndex += loopedSlides;
            const slideChanged = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged && diff !== 0) {
                swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
        }
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
        swiper.emit('loopFix');
    }
    function loopDestroy() {
        const swiper = this;
        const {
            $wrapperEl,
            params,
            slides
        } = swiper;
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
        slides.removeAttr('data-swiper-slide-index');
    }
    var loop = {
        loopCreate,
        loopFix,
        loopDestroy
    };
    function setGrabCursor(moving) {
        const swiper = this;
        if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
        const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
        el.style.cursor = 'move';
        el.style.cursor = moving ? 'grabbing' : 'grab';
    }
    function unsetGrabCursor() {
        const swiper = this;
        if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
            return;
        }
        swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
    }
    var grabCursor = {
        setGrabCursor,
        unsetGrabCursor
    };
    function closestElement(selector, base) {
        if (base === void 0) {
            base = this;
        }
        function __closestFrom(el) {
            if (!el || el === getDocument() || el === getWindow()) return null;
            if (el.assignedSlot) el = el.assignedSlot;
            const found = el.closest(selector);
            return found || __closestFrom(el.getRootNode().host);
        }
        return __closestFrom(base);
    }
    function onTouchStart(event) {
        const swiper = this;
        const document = getDocument();
        const window = getWindow();
        const data = swiper.touchEventsData;
        const {
            params,
            touches,
            enabled
        } = swiper;
        if (!enabled) return;
        if (swiper.animating && params.preventInteractionOnTransition) {
            return;
        }
        if (!swiper.animating && params.cssMode && params.loop) {
            swiper.loopFix();
        }
        let e = event;
        if (e.originalEvent) e = e.originalEvent;
        let $targetEl = $(e.target);
        if (params.touchEventsTarget === 'wrapper') {
            if (!$targetEl.closest(swiper.wrapperEl).length) return;
        }
        data.isTouchEvent = e.type === 'touchstart';
        if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
        if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
        if (data.isTouched && data.isMoved) return; 
        const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
        if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
            $targetEl = $(event.path[0]);
        }
        const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
        const isTargetShadow = !!(e.target && e.target.shadowRoot); 
        if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
            swiper.allowClick = true;
            return;
        }
        if (params.swipeHandler) {
            if (!$targetEl.closest(params.swipeHandler)[0]) return;
        }
        touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        const startX = touches.currentX;
        const startY = touches.currentY; 
        const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
        const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
        if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
            if (edgeSwipeDetection === 'prevent') {
                axPreventDefault(event);
            } else {
                return;
            }
        }
        Object.assign(data, {
            isTouched: true,
            isMoved: false,
            allowTouchCallbacks: true,
            isScrolling: undefined,
            startMoving: undefined
        });
        touches.startX = startX;
        touches.startY = startY;
        data.touchStartTime = now();
        swiper.allowClick = true;
        swiper.updateSize();
        swiper.swipeDirection = undefined;
        if (params.threshold > 0) data.allowThresholdMove = false;
        if (e.type !== 'touchstart') {
            let preventDefault = true;
            if ($targetEl.is(data.focusableElements)) {
                preventDefault = false;
                if ($targetEl[0].nodeName === 'SELECT') {
                    data.isTouched = false;
                }
            }
            if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
                document.activeElement.blur();
            }
            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
                axPreventDefault(e);
            }
        }
        if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
            swiper.freeMode.onTouchStart();
        }
        swiper.emit('touchStart', e);
    }
    function onTouchMove(event) {
        const document = getDocument();
        const swiper = this;
        const data = swiper.touchEventsData;
        const {
            params,
            touches,
            rtlTranslate: rtl,
            enabled
        } = swiper;
        if (!enabled) return;
        let e = event;
        if (e.originalEvent) e = e.originalEvent;
        if (!data.isTouched) {
            if (data.startMoving && data.isScrolling) {
                swiper.emit('touchMoveOpposite', e);
            }
            return;
        }
        if (data.isTouchEvent && e.type !== 'touchmove') return;
        const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
        const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
        const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
        if (e.preventedByNestedSwiper) {
            touches.startX = pageX;
            touches.startY = pageY;
            return;
        }
        if (!swiper.allowTouchMove) {
            if (!$(e.target).is(data.focusableElements)) {
                swiper.allowClick = false;
            }
            if (data.isTouched) {
                Object.assign(touches, {
                    startX: pageX,
                    startY: pageY,
                    currentX: pageX,
                    currentY: pageY
                });
                data.touchStartTime = now();
            }
            return;
        }
        if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
            if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
                return;
            }
        }
        if (data.isTouchEvent && document.activeElement) {
            if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
        }
        if (data.allowTouchCallbacks) {
            swiper.emit('touchMove', e);
        }
        if (e.targetTouches && e.targetTouches.length > 1) return;
        touches.currentX = pageX;
        touches.currentY = pageY;
        const diffX = touches.currentX - touches.startX;
        const diffY = touches.currentY - touches.startY;
        if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
        if (typeof data.isScrolling === 'undefined') {
            let touchAngle;
            if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
                data.isScrolling = false;
            } else {
                if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
        }
        if (data.isScrolling) {
            swiper.emit('touchMoveOpposite', e);
        }
        if (typeof data.startMoving === 'undefined') {
            if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
                data.startMoving = true;
            }
        }
        if (data.isScrolling) {
            data.isTouched = false;
            return;
        }
        if (!data.startMoving) {
            return;
        }
        swiper.allowClick = false;
        if (!params.cssMode && e.cancelable) {
            axPreventDefault(e);
        }
        if (params.touchMoveStopPropagation && !params.nested) {
            e.stopPropagation();
        }
        if (!data.isMoved) {
            if (params.loop && !params.cssMode) {
                swiper.loopFix();
            }
            data.startTranslate = swiper.getTranslate();
            swiper.setTransition(0);
            if (swiper.animating) {
                swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
            }
            data.allowMomentumBounce = false; 
            if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
                swiper.setGrabCursor(true);
            }
            swiper.emit('sliderFirstMove', e);
        }
        swiper.emit('sliderMove', e);
        data.isMoved = true;
        let diff = swiper.isHorizontal() ? diffX : diffY;
        touches.diff = diff;
        diff *= params.touchRatio;
        if (rtl) diff = -diff;
        swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
        data.currentTranslate = diff + data.startTranslate;
        let disableParentSwiper = true;
        let resistanceRatio = params.resistanceRatio;
        if (params.touchReleaseOnEdges) {
            resistanceRatio = 0;
        }
        if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
        } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
        }
        if (disableParentSwiper) {
            e.preventedByNestedSwiper = true;
        } 
        if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
            data.currentTranslate = data.startTranslate;
        }
        if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
            data.currentTranslate = data.startTranslate;
        }
        if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
            data.currentTranslate = data.startTranslate;
        } 
        if (params.threshold > 0) {
            if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
        }
        if (!params.followFinger || params.cssMode) return; 
        if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
            swiper.freeMode.onTouchMove();
        } 
        swiper.updateProgress(data.currentTranslate); 
        swiper.setTranslate(data.currentTranslate);
    }
    function onTouchEnd(event) {
        const swiper = this;
        const data = swiper.touchEventsData;
        const {
            params,
            touches,
            rtlTranslate: rtl,
            slidesGrid,
            enabled
        } = swiper;
        if (!enabled) return;
        let e = event;
        if (e.originalEvent) e = e.originalEvent;
        if (data.allowTouchCallbacks) {
            swiper.emit('touchEnd', e);
        }
        data.allowTouchCallbacks = false;
        if (!data.isTouched) {
            if (data.isMoved && params.grabCursor) {
                swiper.setGrabCursor(false);
            }
            data.isMoved = false;
            data.startMoving = false;
            return;
        } 
        if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(false);
        } 
        const touchEndTime = now();
        const timeDiff = touchEndTime - data.touchStartTime; 
        if (swiper.allowClick) {
            const pathTree = e.path || e.composedPath && e.composedPath();
            swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
            swiper.emit('tap click', e);
            if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
                swiper.emit('doubleTap doubleClick', e);
            }
        }
        data.lastClickTime = now();
        nextTick(() => {
            if (!swiper.destroyed) swiper.allowClick = true;
        });
        if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            return;
        }
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        let currentPos;
        if (params.followFinger) {
            currentPos = rtl ? swiper.translate : -swiper.translate;
        } else {
            currentPos = -data.currentTranslate;
        }
        if (params.cssMode) {
            return;
        }
        if (swiper.params.freeMode && params.freeMode.enabled) {
            swiper.freeMode.onTouchEnd({
                currentPos
            });
            return;
        } 
        let stopIndex = 0;
        let groupSize = swiper.slidesSizesGrid[0];
        for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
            const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (typeof slidesGrid[i + increment] !== 'undefined') {
                if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                    stopIndex = i;
                    groupSize = slidesGrid[i + increment] - slidesGrid[i];
                }
            } else if (currentPos >= slidesGrid[i]) {
                stopIndex = i;
                groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
            }
        }
        let rewindFirstIndex = null;
        let rewindLastIndex = null;
        if (params.rewind) {
            if (swiper.isBeginning) {
                rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
            } else if (swiper.isEnd) {
                rewindFirstIndex = 0;
            }
        } 
        const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
        const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (timeDiff > params.longSwipesMs) {
            if (!params.longSwipes) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (swiper.swipeDirection === 'next') {
                if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
            }
            if (swiper.swipeDirection === 'prev') {
                if (ratio > 1 - params.longSwipesRatio) {
                    swiper.slideTo(stopIndex + increment);
                } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
                    swiper.slideTo(rewindLastIndex);
                } else {
                    swiper.slideTo(stopIndex);
                }
            }
        } else {
            if (!params.shortSwipes) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
            if (!isNavButtonTarget) {
                if (swiper.swipeDirection === 'next') {
                    swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
                }
                if (swiper.swipeDirection === 'prev') {
                    swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
                }
            } else if (e.target === swiper.navigation.nextEl) {
                swiper.slideTo(stopIndex + increment);
            } else {
                swiper.slideTo(stopIndex);
            }
        }
    }
    function onResize() {
        const swiper = this;
        const {
            params,
            el
        } = swiper;
        if (el && el.offsetWidth === 0) return; 
        if (params.breakpoints) {
            swiper.setBreakpoint();
        } 
        const {
            allowSlideNext,
            allowSlidePrev,
            snapGrid
        } = swiper; 
        swiper.allowSlideNext = true;
        swiper.allowSlidePrev = true;
        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateSlidesClasses();
        if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
            swiper.slideTo(swiper.slides.length - 1, 0, false, true);
        } else {
            swiper.slideTo(swiper.activeIndex, 0, false, true);
        }
        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
            swiper.autoplay.run();
        } 
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
        }
    }
    function onClick(e) {
        const swiper = this;
        if (!swiper.enabled) return;
        if (!swiper.allowClick) {
            if (swiper.params.preventClicks){
                axPreventDefault(e);
            }
            if (swiper.params.preventClicksPropagation && swiper.animating) {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }
    }
    function onScroll() {
        const swiper = this;
        const {
            wrapperEl,
            rtlTranslate,
            enabled
        } = swiper;
        if (!enabled) return;
        swiper.previousTranslate = swiper.translate;
        if (swiper.isHorizontal()) {
            swiper.translate = -wrapperEl.scrollLeft;
        } else {
            swiper.translate = -wrapperEl.scrollTop;
        } 
        if (swiper.translate === 0) swiper.translate = 0;
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        let newProgress;
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        if (translatesDiff === 0) {
            newProgress = 0;
        } else {
            newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
        }
        if (newProgress !== swiper.progress) {
            swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
        }
        swiper.emit('setTranslate', swiper.translate, false);
    }
    let dummyEventAttached = false;
    function dummyEventListener() { }
    const events = (swiper, method) => {
        const document = getDocument();
        const {
            params,
            touchEvents,
            el,
            wrapperEl,
            device,
            support
        } = swiper;
        const capture = !!params.nested;
        const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
        const swiperMethod = method; 
        if (!support.touch) {
            el[domMethod](touchEvents.start, swiper.onTouchStart, false);
            document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
            document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
        } else {
            const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
            el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
                passive: false,
                capture
            } : capture);
            el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
            if (touchEvents.cancel) {
                el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
            }
        } 
        if (params.preventClicks || params.preventClicksPropagation) {
            el[domMethod]('click', swiper.onClick, true);
        }
        if (params.cssMode) {
            wrapperEl[domMethod]('scroll', swiper.onScroll);
        } 
        if (params.updateOnWindowResize) {
            swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
        } else {
            swiper[swiperMethod]('observerUpdate', onResize, true);
        }
    };
    function attachEvents() {
        const swiper = this;
        const document = getDocument();
        const {
            params,
            support
        } = swiper;
        swiper.onTouchStart = onTouchStart.bind(swiper);
        swiper.onTouchMove = onTouchMove.bind(swiper);
        swiper.onTouchEnd = onTouchEnd.bind(swiper);
        if (params.cssMode) {
            swiper.onScroll = onScroll.bind(swiper);
        }
        swiper.onClick = onClick.bind(swiper);
        if (support.touch && !dummyEventAttached) {
            document.addEventListener('touchstart', dummyEventListener);
            dummyEventAttached = true;
        }
        events(swiper, 'on');
    }
    function detachEvents() {
        const swiper = this;
        events(swiper, 'off');
    }
    var _events = {
        attachEvents,
        detachEvents
    };
    const isGridEnabled = (swiper, params) => {
        return swiper.grid && params.grid && params.grid.rows > 1;
    };
    function setBreakpoint() {
        const swiper = this;
        const {
            activeIndex,
            initialized,
            loopedSlides = 0,
            params,
            $el
        } = swiper;
        const breakpoints = params.breakpoints;
        if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; 
        const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
        if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
        const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
        const breakpointParams = breakpointOnlyParams || swiper.originalParams;
        const wasMultiRow = isGridEnabled(swiper, params);
        const isMultiRow = isGridEnabled(swiper, breakpointParams);
        const wasEnabled = params.enabled;
        if (wasMultiRow && !isMultiRow) {
            $el.removeClass(`${params.containerModifierClass}grids ${params.containerModifierClass}grid-column`);
            swiper.emitContainerClasses();
        } else if (!wasMultiRow && isMultiRow) {
            $el.addClass(`${params.containerModifierClass}grids`);
            if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
                $el.addClass(`${params.containerModifierClass}grid-column`);
            }
            swiper.emitContainerClasses();
        }
        const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
        const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
        if (directionChanged && initialized) {
            swiper.changeDirection();
        }
        extend(swiper.params, breakpointParams);
        const isEnabled = swiper.params.enabled;
        Object.assign(swiper, {
            allowTouchMove: swiper.params.allowTouchMove,
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev
        });
        if (wasEnabled && !isEnabled) {
            swiper.disable();
        } else if (!wasEnabled && isEnabled) {
            swiper.enable();
        }
        swiper.currentBreakpoint = breakpoint;
        swiper.emit('_beforeBreakpoint', breakpointParams);
        if (needsReLoop && initialized) {
            swiper.loopDestroy();
            swiper.loopCreate();
            swiper.updateSlides();
            swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
        }
        swiper.emit('breakpoint', breakpointParams);
    }
    function getBreakpoint(breakpoints, base, containerEl) {
        if (base === void 0) {
            base = 'window';
        }
        if (!breakpoints || base === 'container' && !containerEl) return undefined;
        let breakpoint = false;
        const window = getWindow();
        const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
        const points = Object.keys(breakpoints).map(point => {
            if (typeof point === 'string' && point.indexOf('@') === 0) {
                const minRatio = parseFloat(point.substr(1));
                const value = currentHeight * minRatio;
                return {
                    value,
                    point
                };
            }
            return {
                value: point,
                point
            };
        });
        points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
        for (let i = 0; i < points.length; i += 1) {
            const {
                point,
                value
            } = points[i];
            if (base === 'window') {
                if (window.matchMedia(`(min-width: ${value}px)`).matches) {
                    breakpoint = point;
                }
            } else if (value <= containerEl.clientWidth) {
                breakpoint = point;
            }
        }
        return breakpoint || 'max';
    }
    var breakpoints = {
        setBreakpoint,
        getBreakpoint
    };
    function prepareClasses(entries, prefix) {
        const resultClasses = [];
        entries.forEach(item => {
            if (typeof item === 'object') {
                Object.keys(item).forEach(classNames => {
                    if (item[classNames]) {
                        resultClasses.push(prefix + classNames);
                    }
                });
            } else if (typeof item === 'string') {
                resultClasses.push(prefix + item);
            }
        });
        return resultClasses;
    }
    function addClasses() {
        const swiper = this;
        const {
            classNames,
            params,
            rtl,
            $el,
            device,
            support
        } = swiper; 
        const suffixes = prepareClasses(['initialized', params.direction, {
            'pointer-events': !support.touch
        }, {
                'free-mode': swiper.params.freeMode && params.freeMode.enabled
            }, {
                'autoheight': params.autoHeight
            }, {
                'rtl': rtl
            }, {
                'grids': params.grid && params.grid.rows > 1
            }, {
                'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
            }, {
                'android': device.android
            }, {
                'ios': device.ios
            }, {
                'css-mode': params.cssMode
            }, {
                'centered': params.cssMode && params.centeredSlides
            }, {
                'watch-progress': params.watchSlidesProgress
            }], params.containerModifierClass);
        classNames.push(...suffixes);
        $el.addClass([...classNames].join(' '));
        swiper.emitContainerClasses();
    }
    function removeClasses() {
        const swiper = this;
        const {
            $el,
            classNames
        } = swiper;
        $el.removeClass(classNames.join(' '));
        swiper.emitContainerClasses();
    }
    var classes = {
        addClasses,
        removeClasses
    };
    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
        const window = getWindow();
        let image;
        function onReady() {
            if (callback) callback();
        }
        const isPicture = $(imageEl).parent('picture')[0];
        if (!isPicture && (!imageEl.complete || !checkForComplete)) {
            if (src) {
                image = new window.Image();
                image.onload = onReady;
                image.onerror = onReady;
                if (sizes) {
                    image.sizes = sizes;
                }
                if (srcset) {
                    image.srcset = srcset;
                }
                if (src) {
                    image.src = src;
                }
            } else {
                onReady();
            }
        } else {
            onReady();
        }
    }
    function preloadImages() {
        const swiper = this;
        swiper.imagesToLoad = swiper.$el.find('img');
        function onReady() {
            if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
            if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
            if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
                if (swiper.params.updateOnImagesReady) swiper.update();
                swiper.emit('imagesReady');
            }
        }
        for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
            const imageEl = swiper.imagesToLoad[i];
            swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
        }
    }
    var images = {
        loadImage,
        preloadImages
    };
    function checkOverflow() {
        const swiper = this;
        const {
            isLocked: wasLocked,
            params
        } = swiper;
        const {
            slidesOffsetBefore
        } = params;
        if (slidesOffsetBefore) {
            const lastSlideIndex = swiper.slides.length - 1;
            const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
            swiper.isLocked = swiper.size > lastSlideRightEdge;
        } else {
            swiper.isLocked = swiper.snapGrid.length === 1;
        }
        if (params.allowSlideNext === true) {
            swiper.allowSlideNext = !swiper.isLocked;
        }
        if (params.allowSlidePrev === true) {
            swiper.allowSlidePrev = !swiper.isLocked;
        }
        if (wasLocked && wasLocked !== swiper.isLocked) {
            swiper.isEnd = false;
        }
        if (wasLocked !== swiper.isLocked) {
            swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
        }
    }
    var checkOverflow$1 = {
        checkOverflow
    };
    var defaults = {
        init: true,
        direction: 'horizontal',
        touchEventsTarget: 'wrapper',
        initialSlide: 0,
        speed: 300,
        cssMode: false,
        updateOnWindowResize: true,
        resizeObserver: true,
        nested: false,
        createElements: false,
        enabled: true,
        focusableElements: 'input, select, option, textarea, button, video, label',
        width: null,
        height: null,
        preventInteractionOnTransition: false,
        userAgent: null,
        url: null,
        edgeSwipeDetection: false,
        edgeSwipeThreshold: 20,
        autoHeight: false,
        setWrapperSize: false,
        virtualTranslate: false,
        effect: 'slide',
        breakpoints: undefined,
        breakpointsBase: 'window',
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: false,
        centeredSlides: false,
        centeredSlidesBounds: false,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: true,
        centerInsufficientSlides: false,
        watchOverflow: true,
        roundLengths: false,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: true,
        shortSwipes: true,
        longSwipes: true,
        longSwipesRatio: 0.5,
        longSwipesMs: 300,
        followFinger: true,
        allowTouchMove: true,
        threshold: 0,
        touchMoveStopPropagation: false,
        touchStartPreventDefault: true,
        touchStartForcePreventDefault: false,
        touchReleaseOnEdges: false,
        uniqueNavElements: true,
        resistance: true,
        resistanceRatio: 0.85,
        watchSlidesProgress: false,
        grabCursor: false,
        preventClicks: true,
        preventClicksPropagation: true,
        slideToClickedSlide: false,
        preloadImages: true,
        updateOnImagesReady: true,
        loop: false,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopFillGroupWithBlank: false,
        loopPreventsSlide: true,
        rewind: false,
        allowSlidePrev: true,
        allowSlideNext: true,
        swipeHandler: null,
        noSwiping: true,
        noSwipingClass: 'ax-no-swiping',
        noSwipingSelector: null,
        passiveListeners: true,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: 'ax-',
        slideClass: 'ax-slide',
        slideBlankClass: 'ax-slide-invisible-blank',
        slideActiveClass: 'ax-slide-active',
        slideDuplicateActiveClass: 'ax-slide-duplicate-active',
        slideVisibleClass: 'ax-slide-visible',
        slideDuplicateClass: 'ax-slide-duplicate',
        slideNextClass: 'ax-slide-next',
        slideDuplicateNextClass: 'ax-slide-duplicate-next',
        slidePrevClass: 'ax-slide-prev',
        slideDuplicatePrevClass: 'ax-slide-duplicate-prev',
        wrapperClass: 'ax-wrapper',
        runCallbacksOnInit: true,
        _emitClasses: false
    };
    function moduleExtendParams(params, allModulesParams) {
        return function extendParams(obj) {
            if (obj === void 0) {
                obj = {};
            }
            const moduleParamName = Object.keys(obj)[0];
            const moduleParams = obj[moduleParamName];
            if (typeof moduleParams !== 'object' || moduleParams === null) {
                extend(allModulesParams, obj);
                return;
            }
            if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
                params[moduleParamName] = {
                    auto: true
                };
            }
            if (!(moduleParamName in params && 'enabled' in moduleParams)) {
                extend(allModulesParams, obj);
                return;
            }
            if (params[moduleParamName] === true) {
                params[moduleParamName] = {
                    enabled: true
                };
            }
            if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
                params[moduleParamName].enabled = true;
            }
            if (!params[moduleParamName]) params[moduleParamName] = {
                enabled: false
            };
            extend(allModulesParams, obj);
        };
    }
    /* eslint no-param-reassign: "off" */
    const prototypes = {
        eventsEmitter,
        update,
        translate,
        transition,
        slide,
        loop,
        grabCursor,
        events: _events,
        breakpoints,
        checkOverflow: checkOverflow$1,
        classes,
        images
    };
    const extendedDefaults = {};
    class Swiper {
        constructor() {
            let el;
            let params;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
                params = args[0];
            } else {
                [el, params] = args;
            }
            if (!params) params = {};
            params = extend({}, params);
            if (el && !params.el) params.el = el;
            if (params.el && $(params.el).length > 1) {
                const swipers = [];
                $(params.el).each(containerEl => {
                    const newParams = extend({}, params, {
                        el: containerEl
                    });
                    swipers.push(new Swiper(newParams));
                });
                return swipers;
            } 
            const swiper = this;
            swiper.__swiper__ = true;
            swiper.support = getSupport();
            swiper.device = getDevice({
                userAgent: params.userAgent
            });
            swiper.browser = getBrowser();
            swiper.eventsListeners = {};
            swiper.eventsAnyListeners = [];
            swiper.modules = [...swiper.__modules__];
            if (params.modules && Array.isArray(params.modules)) {
                swiper.modules.push(...params.modules);
            }
            const allModulesParams = {};
            swiper.modules.forEach(mod => {
                mod({
                    swiper,
                    extendParams: moduleExtendParams(params, allModulesParams),
                    on: swiper.on.bind(swiper),
                    once: swiper.once.bind(swiper),
                    off: swiper.off.bind(swiper),
                    emit: swiper.emit.bind(swiper)
                });
            }); 
            const swiperParams = extend({}, defaults, allModulesParams); 
            swiper.params = extend({}, swiperParams, extendedDefaults, params);
            if (typeof params.el == 'string') {
                if (swiper.params.navigation.prevEl == '.ax-prev') {
                    swiper.params.navigation.prevEl = document.querySelector(params.el + ' .ax-prev');
                }
                if (swiper.params.navigation.nextEl == '.ax-next') {
                    swiper.params.navigation.nextEl = document.querySelector(params.el + ' .ax-next');
                }
            } else {
                if (swiper.params.navigation.prevEl == '.ax-prev') {
                    swiper.params.navigation.prevEl = params.el.querySelector('.ax-prev');
                }
                if (swiper.params.navigation.nextEl == '.ax-next') {
                    swiper.params.navigation.nextEl = params.el.querySelector('.ax-next');
                }
            }
            swiper.originalParams = extend({}, swiper.params);
            swiper.passedParams = extend({}, params); 
            if (swiper.params && swiper.params.on) {
                Object.keys(swiper.params.on).forEach(eventName => {
                    swiper.on(eventName, swiper.params.on[eventName]);
                });
            }
            if (swiper.params && swiper.params.onAny) {
                swiper.onAny(swiper.params.onAny);
            } 
            swiper.$ = $; 
            Object.assign(swiper, {
                enabled: swiper.params.enabled,
                el,
                classNames: [],
                slides: $(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal() {
                    return swiper.params.direction === 'horizontal';
                },
                isVertical() {
                    return swiper.params.direction === 'vertical';
                },
                activeIndex: 0,
                realIndex: 0,
                isBeginning: true,
                isEnd: false,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: false,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev,
                touchEvents: function touchEvents() {
                    const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
                    const desktop = ['pointerdown', 'pointermove', 'pointerup'];
                    swiper.touchEventsTouch = {
                        start: touch[0],
                        move: touch[1],
                        end: touch[2],
                        cancel: touch[3]
                    };
                    swiper.touchEventsDesktop = {
                        start: desktop[0],
                        move: desktop[1],
                        end: desktop[2]
                    };
                    return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
                }(),
                touchEventsData: {
                    isTouched: undefined,
                    isMoved: undefined,
                    allowTouchCallbacks: undefined,
                    touchStartTime: undefined,
                    isScrolling: undefined,
                    currentTranslate: undefined,
                    startTranslate: undefined,
                    allowThresholdMove: undefined,
                    focusableElements: swiper.params.focusableElements,
                    lastClickTime: now(),
                    clickTimeout: undefined,
                    velocities: [],
                    allowMomentumBounce: undefined,
                    isTouchEvent: undefined,
                    startMoving: undefined
                },
                allowClick: true,
                allowTouchMove: swiper.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            });
            swiper.emit('_swiper'); 
            if (swiper.params.init) { 
                swiper.init();
            } 
            return swiper;
        }
        enable() {
            const swiper = this;
            if (swiper.enabled) return;
            swiper.enabled = true;
            if (swiper.params.grabCursor) {
                swiper.setGrabCursor();
            }
            swiper.emit('enable');
        }
        disable() {
            const swiper = this;
            if (!swiper.enabled) return;
            swiper.enabled = false;
            if (swiper.params.grabCursor) {
                swiper.unsetGrabCursor();
            }
            swiper.emit('disable');
        }
        setProgress(progress, speed) {
            const swiper = this;
            progress = Math.min(Math.max(progress, 0), 1);
            const min = swiper.minTranslate();
            const max = swiper.maxTranslate();
            const current = (max - min) * progress + min;
            swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        emitContainerClasses() {
            const swiper = this;
            if (!swiper.params._emitClasses || !swiper.el) return;
            const cls = swiper.el.className.split(' ').filter(className => {
                return className.indexOf('ax') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
            });
            swiper.emit('_containerClasses', cls.join(' '));
        }
        getSlideClasses(slideEl) {
            const swiper = this;
            if (swiper.destroyed) return '';
            return slideEl.className.split(' ').filter(className => {
                return className.indexOf('ax-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
            }).join(' ');
        }
        emitSlidesClasses() {
            const swiper = this;
            if (!swiper.params._emitClasses || !swiper.el) return;
            const updates = [];
            swiper.slides.each(slideEl => {
                const classNames = swiper.getSlideClasses(slideEl);
                updates.push({
                    slideEl,
                    classNames
                });
                swiper.emit('_slideClass', slideEl, classNames);
            });
            swiper.emit('_slideClasses', updates);
        }
        slidesPerViewDynamic(view, exact) {
            if (view === void 0) {
                view = 'current';
            }
            if (exact === void 0) {
                exact = false;
            }
            const swiper = this;
            const {
                params,
                slides,
                slidesGrid,
                slidesSizesGrid,
                size: swiperSize,
                activeIndex
            } = swiper;
            let spv = 1;
            if (params.centeredSlides) {
                let slideSize = slides[activeIndex].swiperSlideSize;
                let breakLoop;
                for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                }
                for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                }
            } else {
                if (view === 'current') {
                    for (let i = activeIndex + 1; i < slides.length; i += 1) {
                        const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                        if (slideInView) {
                            spv += 1;
                        }
                    }
                } else {
                    for (let i = activeIndex - 1; i >= 0; i -= 1) {
                        const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                        if (slideInView) {
                            spv += 1;
                        }
                    }
                }
            }
            return spv;
        }
        update() {
            const swiper = this;
            if (!swiper || swiper.destroyed) return;
            const {
                snapGrid,
                params
            } = swiper; 
            if (params.breakpoints) {
                swiper.setBreakpoint();
            }
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();
            function setTranslate() {
                const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                swiper.setTranslate(newTranslate);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            let translated;
            if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
                setTranslate();
                if (swiper.params.autoHeight) {
                    swiper.updateAutoHeight();
                }
            } else {
                if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                    translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
                } else {
                    translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                }
                if (!translated) {
                    setTranslate();
                }
            }
            if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
                swiper.checkOverflow();
            }
            swiper.emit('update');
        }
        changeDirection(newDirection, needUpdate) {
            if (needUpdate === void 0) {
                needUpdate = true;
            }
            const swiper = this;
            const currentDirection = swiper.params.direction;
            if (!newDirection) {
                newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
            }
            if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
                return swiper;
            }
            swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
            swiper.emitContainerClasses();
            swiper.params.direction = newDirection;
            swiper.slides.each(slideEl => {
                if (newDirection === 'vertical') {
                    slideEl.style.width = '';
                } else {
                    slideEl.style.height = '';
                }
            });
            swiper.emit('changeDirection');
            if (needUpdate) swiper.update();
            return swiper;
        }
        mount(el) {
            const swiper = this;
            if (swiper.mounted) return true; 
            const $el = $(el || swiper.params.el);
            el = $el[0];
            if (!el) {
                return false;
            }
            el.swiper = swiper;
            const getWrapperSelector = () => {
                return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
            };
            const getWrapper = () => {
                if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                    const res = $(el.shadowRoot.querySelector(getWrapperSelector())); 
                    res.children = options => $el.children(options);
                    return res;
                }
                return $el.children(getWrapperSelector());
            }; 
            let $wrapperEl = getWrapper();
            if ($wrapperEl.length === 0 && swiper.params.createElements) {
                const document = getDocument();
                const wrapper = document.createElement('div');
                $wrapperEl = $(wrapper);
                wrapper.className = swiper.params.wrapperClass;
                $el.append(wrapper);
                $el.children(`.${swiper.params.slideClass}`).each(slideEl => {
                    $wrapperEl.append(slideEl);
                });
            }
            Object.assign(swiper, {
                $el,
                el,
                $wrapperEl,
                wrapperEl: $wrapperEl[0],
                mounted: true,
                rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
                rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
                wrongRTL: $wrapperEl.css('display') === '-webkit-box'
            });
            return true;
        }
        init(el) {
            const swiper = this;
            if (swiper.initialized) return swiper;
            const mounted = swiper.mount(el);
            if (mounted === false) return swiper;
            swiper.emit('beforeInit'); 
            if (swiper.params.breakpoints) {
                swiper.setBreakpoint();
            } 
            swiper.addClasses(); 
            if (swiper.params.loop) {
                swiper.loopCreate();
            } 
            swiper.updateSize(); 
            swiper.updateSlides();
            if (swiper.params.watchOverflow) {
                swiper.checkOverflow();
            } 
            if (swiper.params.grabCursor && swiper.enabled) {
                swiper.setGrabCursor();
            }
            if (swiper.params.preloadImages) {
                swiper.preloadImages();
            } 
            if (swiper.params.loop) {
                swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
            } else {
                swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
            } 
            swiper.attachEvents(); 
            swiper.initialized = true; 
            swiper.emit('init');
            swiper.emit('afterInit');
            return swiper;
        }
        destroy(deleteInstance, cleanStyles) {
            if (deleteInstance === void 0) {
                deleteInstance = true;
            }
            if (cleanStyles === void 0) {
                cleanStyles = true;
            }
            const swiper = this;
            const {
                params,
                $el,
                $wrapperEl,
                slides
            } = swiper;
            if (typeof swiper.params === 'undefined' || swiper.destroyed) {
                return null;
            }
            swiper.emit('beforeDestroy'); 
            swiper.initialized = false; 
            swiper.detachEvents(); 
            if (params.loop) {
                swiper.loopDestroy();
            } 
            if (cleanStyles) {
                swiper.removeClasses();
                $el.removeAttr('style');
                $wrapperEl.removeAttr('style');
                if (slides && slides.length) {
                    slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
                }
            }
            swiper.emit('destroy'); 
            Object.keys(swiper.eventsListeners).forEach(eventName => {
                swiper.off(eventName);
            });
            if (deleteInstance !== false) {
                swiper.$el[0].swiper = null;
                deleteProps(swiper);
            }
            swiper.destroyed = true;
            return null;
        }
        static extendDefaults(newDefaults) {
            extend(extendedDefaults, newDefaults);
        }
        static get extendedDefaults() {
            return extendedDefaults;
        }
        static get defaults() {
            return defaults;
        }
        static installModule(mod) {
            if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
            const modules = Swiper.prototype.__modules__;
            if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
                modules.push(mod);
            }
        }
        static use(module) {
            if (Array.isArray(module)) {
                module.forEach(m => Swiper.installModule(m));
                return Swiper;
            }
            Swiper.installModule(module);
            return Swiper;
        }
    }
    Object.keys(prototypes).forEach(prototypeGroup => {
        Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
        });
    });
    Swiper.use([Resize, Observer]);
    function Virtual(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        extendParams({
            virtual: {
                enabled: false,
                slides: [],
                cache: true,
                renderSlide: null,
                renderExternal: null,
                renderExternalUpdate: true,
                addSlidesBefore: 0,
                addSlidesAfter: 0
            }
        });
        let cssModeTimeout;
        swiper.virtual = {
            cache: {},
            from: undefined,
            to: undefined,
            slides: [],
            offset: 0,
            slidesGrid: []
        };
        function renderSlide(slide, index) {
            const params = swiper.params.virtual;
            if (params.cache && swiper.virtual.cache[index]) {
                return swiper.virtual.cache[index];
            }
            const $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
            if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
            if (params.cache) swiper.virtual.cache[index] = $slideEl;
            return $slideEl;
        }
        function update(force) {
            const {
                slidesPerView,
                slidesPerGroup,
                centeredSlides
            } = swiper.params;
            const {
                addSlidesBefore,
                addSlidesAfter
            } = swiper.params.virtual;
            const {
                from: previousFrom,
                to: previousTo,
                slides,
                slidesGrid: previousSlidesGrid,
                offset: previousOffset
            } = swiper.virtual;
            if (!swiper.params.cssMode) {
                swiper.updateActiveIndex();
            }
            const activeIndex = swiper.activeIndex || 0;
            let offsetProp;
            if (swiper.rtlTranslate) offsetProp = 'right'; else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
            let slidesAfter;
            let slidesBefore;
            if (centeredSlides) {
                slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
                slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
            } else {
                slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
                slidesBefore = slidesPerGroup + addSlidesBefore;
            }
            const from = Math.max((activeIndex || 0) - slidesBefore, 0);
            const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
            const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
            Object.assign(swiper.virtual, {
                from,
                to,
                offset,
                slidesGrid: swiper.slidesGrid
            });
            function onRendered() {
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                if (swiper.lazy && swiper.params.lazy.enabled) {
                    swiper.lazy.load();
                }
                emit('virtualUpdate');
            }
            if (previousFrom === from && previousTo === to && !force) {
                if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
                    swiper.slides.css(offsetProp, `${offset}px`);
                }
                swiper.updateProgress();
                emit('virtualUpdate');
                return;
            }
            if (swiper.params.virtual.renderExternal) {
                swiper.params.virtual.renderExternal.call(swiper, {
                    offset,
                    from,
                    to,
                    slides: function getSlides() {
                        const slidesToRender = [];
                        for (let i = from; i <= to; i += 1) {
                            slidesToRender.push(slides[i]);
                        }
                        return slidesToRender;
                    }()
                });
                if (swiper.params.virtual.renderExternalUpdate) {
                    onRendered();
                } else {
                    emit('virtualUpdate');
                }
                return;
            }
            const prependIndexes = [];
            const appendIndexes = [];
            if (force) {
                swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
            } else {
                for (let i = previousFrom; i <= previousTo; i += 1) {
                    if (i < from || i > to) {
                        swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
                    }
                }
            }
            for (let i = 0; i < slides.length; i += 1) {
                if (i >= from && i <= to) {
                    if (typeof previousTo === 'undefined' || force) {
                        appendIndexes.push(i);
                    } else {
                        if (i > previousTo) appendIndexes.push(i);
                        if (i < previousFrom) prependIndexes.push(i);
                    }
                }
            }
            appendIndexes.forEach(index => {
                swiper.$wrapperEl.append(renderSlide(slides[index], index));
            });
            prependIndexes.sort((a, b) => b - a).forEach(index => {
                swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
            });
            swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
            onRendered();
        }
        function appendSlide(slides) {
            if (typeof slides === 'object' && 'length' in slides) {
                for (let i = 0; i < slides.length; i += 1) {
                    if (slides[i]) swiper.virtual.slides.push(slides[i]);
                }
            } else {
                swiper.virtual.slides.push(slides);
            }
            update(true);
        }
        function prependSlide(slides) {
            const activeIndex = swiper.activeIndex;
            let newActiveIndex = activeIndex + 1;
            let numberOfNewSlides = 1;
            if (Array.isArray(slides)) {
                for (let i = 0; i < slides.length; i += 1) {
                    if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
                }
                newActiveIndex = activeIndex + slides.length;
                numberOfNewSlides = slides.length;
            } else {
                swiper.virtual.slides.unshift(slides);
            }
            if (swiper.params.virtual.cache) {
                const cache = swiper.virtual.cache;
                const newCache = {};
                Object.keys(cache).forEach(cachedIndex => {
                    const $cachedEl = cache[cachedIndex];
                    const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');
                    if (cachedElIndex) {
                        $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
                    }
                    newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
                });
                swiper.virtual.cache = newCache;
            }
            update(true);
            swiper.slideTo(newActiveIndex, 0);
        }
        function removeSlide(slidesIndexes) {
            if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
            let activeIndex = swiper.activeIndex;
            if (Array.isArray(slidesIndexes)) {
                for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
                    swiper.virtual.slides.splice(slidesIndexes[i], 1);
                    if (swiper.params.virtual.cache) {
                        delete swiper.virtual.cache[slidesIndexes[i]];
                    }
                    if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
                    activeIndex = Math.max(activeIndex, 0);
                }
            } else {
                swiper.virtual.slides.splice(slidesIndexes, 1);
                if (swiper.params.virtual.cache) {
                    delete swiper.virtual.cache[slidesIndexes];
                }
                if (slidesIndexes < activeIndex) activeIndex -= 1;
                activeIndex = Math.max(activeIndex, 0);
            }
            update(true);
            swiper.slideTo(activeIndex, 0);
        }
        function removeAllSlides() {
            swiper.virtual.slides = [];
            if (swiper.params.virtual.cache) {
                swiper.virtual.cache = {};
            }
            update(true);
            swiper.slideTo(0, 0);
        }
        on('beforeInit', () => {
            if (!swiper.params.virtual.enabled) return;
            swiper.virtual.slides = swiper.params.virtual.slides;
            swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
            if (!swiper.params.initialSlide) {
                update();
            }
        });
        on('setTranslate', () => {
            if (!swiper.params.virtual.enabled) return;
            if (swiper.params.cssMode && !swiper._immediateVirtual) {
                clearTimeout(cssModeTimeout);
                cssModeTimeout = setTimeout(() => {
                    update();
                }, 100);
            } else {
                update();
            }
        });
        on('init update resize', () => {
            if (!swiper.params.virtual.enabled) return;
            if (swiper.params.cssMode) {
                setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
            }
        });
        Object.assign(swiper.virtual, {
            appendSlide,
            prependSlide,
            removeSlide,
            removeAllSlides,
            update
        });
    }
    /* eslint-disable consistent-return */
    function Keyboard(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const document = getDocument();
        const window = getWindow();
        swiper.keyboard = {
            enabled: false
        };
        extendParams({
            keyboard: {
                enabled: false,
                onlyInViewport: true,
                pageUpDown: true
            }
        });
        function handle(event) {
            if (!swiper.enabled) return;
            const {
                rtlTranslate: rtl
            } = swiper;
            let e = event;
            if (e.originalEvent) e = e.originalEvent; 
            const kc = e.keyCode || e.charCode;
            const pageUpDown = swiper.params.keyboard.pageUpDown;
            const isPageUp = pageUpDown && kc === 33;
            const isPageDown = pageUpDown && kc === 34;
            const isArrowLeft = kc === 37;
            const isArrowRight = kc === 39;
            const isArrowUp = kc === 38;
            const isArrowDown = kc === 40; 
            if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
                return false;
            }
            if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
                return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                return undefined;
            }
            if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
                return undefined;
            }
            if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
                let inView = false; 
                if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
                    return undefined;
                }
                const $el = swiper.$el;
                const swiperWidth = $el[0].clientWidth;
                const swiperHeight = $el[0].clientHeight;
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                const swiperOffset = swiper.$el.offset();
                if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
                const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
                for (let i = 0; i < swiperCoord.length; i += 1) {
                    const point = swiperCoord[i];
                    if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                        if (point[0] === 0 && point[1] === 0) continue; 
                        inView = true;
                    }
                }
                if (!inView) return undefined;
            }
            if (swiper.isHorizontal()) {
                if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
                    axPreventDefault(e);
                }
                if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
                if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
            } else {
                if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
                    axPreventDefault(e);
                }
                if (isPageDown || isArrowDown) swiper.slideNext();
                if (isPageUp || isArrowUp) swiper.slidePrev();
            }
            emit('keyPress', kc);
            return undefined;
        }
        function enable() {
            if (swiper.keyboard.enabled) return;
            $(document).on('keydown', handle);
            swiper.keyboard.enabled = true;
        }
        function disable() {
            if (!swiper.keyboard.enabled) return;
            $(document).off('keydown', handle);
            swiper.keyboard.enabled = false;
        }
        on('init', () => {
            if (swiper.params.keyboard.enabled) {
                enable();
            }
        });
        on('destroy', () => {
            if (swiper.keyboard.enabled) {
                disable();
            }
        });
        Object.assign(swiper.keyboard, {
            enable,
            disable
        });
    }
    /* eslint-disable consistent-return */
    function Mousewheel(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const window = getWindow();
        extendParams({
            mousewheel: {
                enabled: false,
                releaseOnEdges: false,
                invert: false,
                forceToAxis: false,
                sensitivity: 1,
                eventsTarget: 'container',
                thresholdDelta: null,
                thresholdTime: null
            }
        });
        swiper.mousewheel = {
            enabled: false
        };
        let timeout;
        let lastScrollTime = now();
        let lastEventBeforeSnap;
        const recentWheelEvents = [];
        function normalize(e) {
            const PIXEL_STEP = 10;
            const LINE_HEIGHT = 40;
            const PAGE_HEIGHT = 800;
            let sX = 0;
            let sY = 0; 
            let pX = 0;
            let pY = 0; 
            if ('detail' in e) {
                sY = e.detail;
            }
            if ('wheelDelta' in e) {
                sY = -e.wheelDelta / 120;
            }
            if ('wheelDeltaY' in e) {
                sY = -e.wheelDeltaY / 120;
            }
            if ('wheelDeltaX' in e) {
                sX = -e.wheelDeltaX / 120;
            } 
            if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
                sX = sY;
                sY = 0;
            }
            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;
            if ('deltaY' in e) {
                pY = e.deltaY;
            }
            if ('deltaX' in e) {
                pX = e.deltaX;
            }
            if (e.shiftKey && !pX) {
                pX = pY;
                pY = 0;
            }
            if ((pX || pY) && e.deltaMode) {
                if (e.deltaMode === 1) {
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else {
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
            } 
            if (pX && !sX) {
                sX = pX < 1 ? -1 : 1;
            }
            if (pY && !sY) {
                sY = pY < 1 ? -1 : 1;
            }
            return {
                spinX: sX,
                spinY: sY,
                pixelX: pX,
                pixelY: pY
            };
        }
        function handleMouseEnter() {
            if (!swiper.enabled) return;
            swiper.mouseEntered = true;
        }
        function handleMouseLeave() {
            if (!swiper.enabled) return;
            swiper.mouseEntered = false;
        }
        function animateSlider(newEvent) {
            if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
                return false;
            }
            if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
                return false;
            } 
            if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
                return true;
            } 
            if (newEvent.direction < 0) {
                if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                    swiper.slideNext();
                    emit('scroll', newEvent.raw);
                }
            } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
                swiper.slidePrev();
                emit('scroll', newEvent.raw);
            } 
            lastScrollTime = new window.Date().getTime(); 
            return false;
        }
        function releaseScroll(newEvent) {
            const params = swiper.params.mousewheel;
            if (newEvent.direction < 0) {
                if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
                    return true;
                }
            } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
                return true;
            }
            return false;
        }
        function handle(event) {
            let e = event;
            let disableParentSwiper = true;
            if (!swiper.enabled) return;
            const params = swiper.params.mousewheel;
            if (swiper.params.cssMode) {
                axPreventDefault(e);
            }
            let target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarget !== 'container') {
                target = $(swiper.params.mousewheel.eventsTarget);
            }
            if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
            if (e.originalEvent) e = e.originalEvent; 
            let delta = 0;
            const rtlFactor = swiper.rtlTranslate ? -1 : 1;
            const data = normalize(e);
            if (params.forceToAxis) {
                if (swiper.isHorizontal()) {
                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor; else return true;
                } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY; else return true;
            } else {
                delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
            }
            if (delta === 0) return true;
            if (params.invert) delta = -delta; 
            let positions = swiper.getTranslate() + delta * params.sensitivity;
            if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
            if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); 
            disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
            if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
            if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
                const newEvent = {
                    time: now(),
                    delta: Math.abs(delta),
                    direction: Math.sign(delta),
                    raw: event
                }; 
                if (recentWheelEvents.length >= 2) {
                    recentWheelEvents.shift(); 
                }
                const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
                recentWheelEvents.push(newEvent); 
                if (prevEvent) {
                    if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
                        animateSlider(newEvent);
                    }
                } else {
                    animateSlider(newEvent);
                } 
                if (releaseScroll(newEvent)) {
                    return true;
                }
            } else {
                const newEvent = {
                    time: now(),
                    delta: Math.abs(delta),
                    direction: Math.sign(delta)
                };
                const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
                if (!ignoreWheelEvents) {
                    lastEventBeforeSnap = undefined;
                    if (swiper.params.loop) {
                        swiper.loopFix();
                    }
                    let position = swiper.getTranslate() + delta * params.sensitivity;
                    const wasBeginning = swiper.isBeginning;
                    const wasEnd = swiper.isEnd;
                    if (position >= swiper.minTranslate()) position = swiper.minTranslate();
                    if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
                    swiper.setTransition(0);
                    swiper.setTranslate(position);
                    swiper.updateProgress();
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                    if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
                        swiper.updateSlidesClasses();
                    }
                    if (swiper.params.freeMode.sticky) {
                        clearTimeout(timeout);
                        timeout = undefined;
                        if (recentWheelEvents.length >= 15) {
                            recentWheelEvents.shift(); 
                        }
                        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
                        const firstEvent = recentWheelEvents[0];
                        recentWheelEvents.push(newEvent);
                        if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
                            recentWheelEvents.splice(0);
                        } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                            lastEventBeforeSnap = newEvent;
                            recentWheelEvents.splice(0);
                            timeout = nextTick(() => {
                                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                            }, 0); 
                        }
                        if (!timeout) {
                            timeout = nextTick(() => {
                                const snapToThreshold = 0.5;
                                lastEventBeforeSnap = newEvent;
                                recentWheelEvents.splice(0);
                                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                            }, 500);
                        }
                    } 
                    if (!ignoreWheelEvents) emit('scroll', e); 
                    if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); 
                    if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
                }
            }
            axPreventDefault(e);
            return false;
        }
        function events(method) {
            let target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarget !== 'container') {
                target = $(swiper.params.mousewheel.eventsTarget);
            }
            target[method]('mouseenter', handleMouseEnter);
            target[method]('mouseleave', handleMouseLeave);
            target[method]('wheel', handle);
        }
        function enable() {
            if (swiper.params.cssMode) {
                swiper.wrapperEl.removeEventListener('wheel', handle);
                return true;
            }
            if (swiper.mousewheel.enabled) return false;
            events('on');
            swiper.mousewheel.enabled = true;
            return true;
        }
        function disable() {
            if (swiper.params.cssMode) {
                swiper.wrapperEl.addEventListener(event, handle);
                return true;
            }
            if (!swiper.mousewheel.enabled) return false;
            events('off');
            swiper.mousewheel.enabled = false;
            return true;
        }
        on('init', () => {
            if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
                disable();
            }
            if (swiper.params.mousewheel.enabled) enable();
        });
        on('destroy', () => {
            if (swiper.params.cssMode) {
                enable();
            }
            if (swiper.mousewheel.enabled) disable();
        });
        Object.assign(swiper.mousewheel, {
            enable,
            disable
        });
    }
    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
        const document = getDocument();
        if (swiper.params.createElements) {
            Object.keys(checkProps).forEach(key => {
                if (!params[key] && params.auto === true) {
                    let element = swiper.$el.children(`.${checkProps[key]}`)[0];
                    if (!element) {
                        element = document.createElement('div');
                        element.className = checkProps[key];
                        swiper.$el.append(element);
                    }
                    params[key] = element;
                    originalParams[key] = element;
                }
            });
        }
        return params;
    }
    function Navigation(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        extendParams({
            navigation: {
                nextEl: '.ax-next',
                prevEl: '.ax-prev',
                hideOnClick: false,
                disabledClass: 'ax-disabled',
                hiddenClass: 'ax-hidden',
                lockClass: 'ax-lock'
            }
        });
        swiper.navigation = {
            nextEl: null,
            $nextEl: null,
            prevEl: null,
            $prevEl: null
        };
        function getEl(el) {
            let $el;
            if (el) {
                $el = $(el);
                if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
                    $el = swiper.$el.find(el);
                }
            }
            return $el;
        }
        function toggleEl($el, disabled) {
            const params = swiper.params.navigation;
            if ($el && $el.length > 0) {
                $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
                if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;
                if (swiper.params.watchOverflow && swiper.enabled) {
                    $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
                }
            }
        }
        function update() {
            if (swiper.params.loop) return;
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
            toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
        }
        function onPrevClick(e) {
            axPreventDefault(e);
            if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
            swiper.slidePrev();
        }
        function onNextClick(e) {
            axPreventDefault(e);
            if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
            swiper.slideNext();
        }
        function init() {
            const params = swiper.params.navigation;
            swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
                nextEl: 'ax-next',
                prevEl: 'ax-prev'
            });
            if (!(params.nextEl || params.prevEl)) return;
            const $nextEl = getEl(params.nextEl);
            const $prevEl = getEl(params.prevEl);
            if ($nextEl && $nextEl.length > 0) {
                $nextEl.on('click', onNextClick);
            }
            if ($prevEl && $prevEl.length > 0) {
                $prevEl.on('click', onPrevClick);
            }
            Object.assign(swiper.navigation, {
                $nextEl,
                nextEl: $nextEl && $nextEl[0],
                $prevEl,
                prevEl: $prevEl && $prevEl[0]
            });
            if (!swiper.enabled) {
                if ($nextEl) $nextEl.addClass(params.lockClass);
                if ($prevEl) $prevEl.addClass(params.lockClass);
            }
        }
        function destroy() {
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            if ($nextEl && $nextEl.length) {
                $nextEl.off('click', onNextClick);
                $nextEl.removeClass(swiper.params.navigation.disabledClass);
            }
            if ($prevEl && $prevEl.length) {
                $prevEl.off('click', onPrevClick);
                $prevEl.removeClass(swiper.params.navigation.disabledClass);
            }
        }
        on('init', () => {
            init();
            update();
        });
        on('toEdge fromEdge lock unlock', () => {
            update();
        });
        on('destroy', () => {
            destroy();
        });
        on('enable disable', () => {
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            if ($nextEl) {
                $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
            }
            if ($prevEl) {
                $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
            }
        });
        on('click', (_s, e) => {
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            const targetEl = e.target;
            if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
                if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                let isHidden;
                if ($nextEl) {
                    isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
                } else if ($prevEl) {
                    isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
                }
                if (isHidden === true) {
                    emit('navigationShow');
                } else {
                    emit('navigationHide');
                }
                if ($nextEl) {
                    $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
                if ($prevEl) {
                    $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
            }
        });
        Object.assign(swiper.navigation, {
            update,
            init,
            destroy
        });
    }
    function classesToSelector(classes) {
        if (classes === void 0) {
            classes = '';
        }
        return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') 
            .replace(/ /g, '.')}`;
    }
    function Pagination(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const pfx = 'ax-pages';
        extendParams({
            pagination: {
                el: '.' + pfx,
                bulletElement: 'i',
                clickable: true,
                hideOnClick: false,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: false,
                type: 'bullets',
                dynamicBullets: false,
                dynamicMainBullets: 1,
                formatFractionCurrent: number => number,
                formatFractionTotal: number => number,
                bulletClass: `${pfx}-bullet`,
                bulletActiveClass: `${pfx}-bullet-active`,
                modifierClass: `${pfx}-`,
                currentClass: `${pfx}-current`,
                totalClass: `${pfx}-total`,
                hiddenClass: `${pfx}-hidden`,
                progressbarFillClass: `${pfx}-progressbar-fill`,
                progressbarOppositeClass: `${pfx}-progressbar-opposite`,
                clickableClass: `${pfx}-clickable`,
                lockClass: `${pfx}-lock`,
                horizontalClass: `${pfx}-horizontal`,
                verticalClass: `${pfx}-vertical`
            }
        });
        swiper.pagination = {
            el: null,
            $el: null,
            bullets: []
        };
        let bulletSize;
        let dynamicBulletIndex = 0;
        function isPaginationDisabled() {
            return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
        }
        function setSideBullets($bulletEl, position) {
            const {
                bulletActiveClass
            } = swiper.params.pagination;
            $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
        }
        function update() {
            const rtl = swiper.rtl;
            const params = swiper.params.pagination;
            if (isPaginationDisabled()) return;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            const $el = swiper.pagination.$el; 
            let current;
            const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            if (swiper.params.loop) {
                current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
                if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
                    current -= slidesLength - swiper.loopedSlides * 2;
                }
                if (current > total - 1) current -= total;
                if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
            } else if (typeof swiper.snapIndex !== 'undefined') {
                current = swiper.snapIndex;
            } else {
                current = swiper.activeIndex || 0;
            } 
            if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                const bullets = swiper.pagination.bullets;
                let firstIndex;
                let lastIndex;
                let midIndex;
                if (params.dynamicBullets) {
                    bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
                    $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);
                    if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
                        dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);
                        if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                            dynamicBulletIndex = params.dynamicMainBullets - 1;
                        } else if (dynamicBulletIndex < 0) {
                            dynamicBulletIndex = 0;
                        }
                    }
                    firstIndex = Math.max(current - dynamicBulletIndex, 0);
                    lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                    midIndex = (lastIndex + firstIndex) / 2;
                }
                bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));
                if ($el.length > 1) {
                    bullets.each(bullet => {
                        const $bullet = $(bullet);
                        const bulletIndex = $bullet.index();
                        if (bulletIndex === current) {
                            $bullet.addClass(params.bulletActiveClass);
                        }
                        if (params.dynamicBullets) {
                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                                $bullet.addClass(`${params.bulletActiveClass}-main`);
                            }
                            if (bulletIndex === firstIndex) {
                                setSideBullets($bullet, 'prev');
                            }
                            if (bulletIndex === lastIndex) {
                                setSideBullets($bullet, 'next');
                            }
                        }
                    });
                } else {
                    const $bullet = bullets.eq(current);
                    const bulletIndex = $bullet.index();
                    $bullet.addClass(params.bulletActiveClass);
                    if (params.dynamicBullets) {
                        const $firstDisplayedBullet = bullets.eq(firstIndex);
                        const $lastDisplayedBullet = bullets.eq(lastIndex);
                        for (let i = firstIndex; i <= lastIndex; i += 1) {
                            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
                        }
                        if (swiper.params.loop) {
                            if (bulletIndex >= bullets.length) {
                                for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                                    bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                                }
                                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
                            } else {
                                setSideBullets($firstDisplayedBullet, 'prev');
                                setSideBullets($lastDisplayedBullet, 'next');
                            }
                        } else {
                            setSideBullets($firstDisplayedBullet, 'prev');
                            setSideBullets($lastDisplayedBullet, 'next');
                        }
                    }
                }
                if (params.dynamicBullets) {
                    const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                    const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                    const offsetProp = rtl ? 'right' : 'left';
                    bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
                }
            }
            if (params.type === 'fraction') {
                $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
                $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
            }
            if (params.type === 'progressbar') {
                let progressbarDirection;
                if (params.progressbarOpposite) {
                    progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
                } else {
                    progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
                }
                const scale = (current + 1) / total;
                let scaleX = 1;
                let scaleY = 1;
                if (progressbarDirection === 'horizontal') {
                    scaleX = scale;
                } else {
                    scaleY = scale;
                }
                $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
            }
            if (params.type === 'custom' && params.renderCustom) {
                $el.html(params.renderCustom(swiper, current + 1, total));
                emit('paginationRender', $el[0]);
            } else {
                emit('paginationUpdate', $el[0]);
            }
            if (swiper.params.watchOverflow && swiper.enabled) {
                $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
            }
        }
        function render() {
            const params = swiper.params.pagination;
            if (isPaginationDisabled()) return;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            const $el = swiper.pagination.$el;
            let paginationHTML = '';
            if (params.type === 'bullets') {
                let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
                    numberOfBullets = slidesLength;
                }
                for (let i = 0; i < numberOfBullets; i += 1) {
                    if (params.renderBullet) {
                        paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
                    } else {
                        paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
                    }
                }
                $el.html(paginationHTML);
                swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
            }
            if (params.type === 'fraction') {
                if (params.renderFraction) {
                    paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
                } else {
                    paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
                }
                $el.html(paginationHTML);
            }
            if (params.type === 'progressbar') {
                if (params.renderProgressbar) {
                    paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
                } else {
                    paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
                }
                $el.html(paginationHTML);
            }
            if (params.type !== 'custom') {
                emit('paginationRender', swiper.pagination.$el[0]);
            }
        }
        function init() {
            swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
                el: 'ax-pages'
            });
            const params = swiper.params.pagination;
            if (!params.el) return;
            let $el = $(params.el);
            if ($el.length === 0) return;
            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
                $el = swiper.$el.find(params.el); 
                if ($el.length > 1) {
                    $el = $el.filter(el => {
                        if ($(el).parents('.swiper')[0] !== swiper.el) return false;
                        return true;
                    });
                }
            }
            if (params.type === 'bullets' && params.clickable) {
                $el.addClass(params.clickableClass);
            }
            $el.addClass(params.modifierClass + params.type);
            $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
            if (params.type === 'bullets' && params.dynamicBullets) {
                $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
                dynamicBulletIndex = 0;
                if (params.dynamicMainBullets < 1) {
                    params.dynamicMainBullets = 1;
                }
            }
            if (params.type === 'progressbar' && params.progressbarOpposite) {
                $el.addClass(params.progressbarOppositeClass);
            }
            if (params.clickable) {
                $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
                    axPreventDefault(e);
                    let index = $(this).index() * swiper.params.slidesPerGroup;
                    if (swiper.params.loop) index += swiper.loopedSlides;
                    swiper.slideTo(index);
                });
            }
            Object.assign(swiper.pagination, {
                $el,
                el: $el[0]
            });
            if (!swiper.enabled) {
                $el.addClass(params.lockClass);
            }
        }
        function destroy() {
            const params = swiper.params.pagination;
            if (isPaginationDisabled()) return;
            const $el = swiper.pagination.$el;
            $el.removeClass(params.hiddenClass);
            $el.removeClass(params.modifierClass + params.type);
            $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
            if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
            if (params.clickable) {
                $el.off('click', classesToSelector(params.bulletClass));
            }
        }
        on('init', () => {
            init();
            render();
            update();
        });
        on('activeIndexChange', () => {
            if (swiper.params.loop) {
                update();
            } else if (typeof swiper.snapIndex === 'undefined') {
                update();
            }
        });
        on('snapIndexChange', () => {
            if (!swiper.params.loop) {
                update();
            }
        });
        on('slidesLengthChange', () => {
            if (swiper.params.loop) {
                render();
                update();
            }
        });
        on('snapGridLengthChange', () => {
            if (!swiper.params.loop) {
                render();
                update();
            }
        });
        on('destroy', () => {
            destroy();
        });
        on('enable disable', () => {
            const {
                $el
            } = swiper.pagination;
            if ($el) {
                $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
            }
        });
        on('lock unlock', () => {
            update();
        });
        on('click', (_s, e) => {
            const targetEl = e.target;
            const {
                $el
            } = swiper.pagination;
            if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
                if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
                const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);
                if (isHidden === true) {
                    emit('paginationShow');
                } else {
                    emit('paginationHide');
                }
                $el.toggleClass(swiper.params.pagination.hiddenClass);
            }
        });
        Object.assign(swiper.pagination, {
            render,
            update,
            init,
            destroy
        });
    }
    function Scrollbar(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const document = getDocument();
        let isTouched = false;
        let timeout = null;
        let dragTimeout = null;
        let dragStartPos;
        let dragSize;
        let trackSize;
        let divider;
        extendParams({
            scrollbar: {
                el: '.ax-scrollbar',
                dragSize: 'auto',
                hide: true,
                draggable: true,
                snapOnRelease: true,
                lockClass: 'ax-scrollbar-lock',
                dragClass: 'ax-scrollbar-drag'
            }
        });
        swiper.scrollbar = {
            el: null,
            dragEl: null,
            $el: null,
            $dragEl: null
        };
        function setTranslate() {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            const {
                scrollbar,
                rtlTranslate: rtl,
                progress
            } = swiper;
            const {
                $dragEl,
                $el
            } = scrollbar;
            const params = swiper.params.scrollbar;
            let newSize = dragSize;
            let newPos = (trackSize - dragSize) * progress;
            if (rtl) {
                newPos = -newPos;
                if (newPos > 0) {
                    newSize = dragSize - newPos;
                    newPos = 0;
                } else if (-newPos + dragSize > trackSize) {
                    newSize = trackSize + newPos;
                }
            } else if (newPos < 0) {
                newSize = dragSize + newPos;
                newPos = 0;
            } else if (newPos + dragSize > trackSize) {
                newSize = trackSize - newPos;
            }
            if (swiper.isHorizontal()) {
                $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
                $dragEl[0].style.width = `${newSize}px`;
            } else {
                $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
                $dragEl[0].style.height = `${newSize}px`;
            }
            if (params.hide) {
                clearTimeout(timeout);
                $el[0].style.opacity = 1;
                timeout = setTimeout(() => {
                    $el[0].style.opacity = 0;
                    $el.transition(400);
                }, 1000);
            }
        }
        function setTransition(duration) {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            swiper.scrollbar.$dragEl.transition(duration);
        }
        function updateSize() {
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            const {
                scrollbar
            } = swiper;
            const {
                $dragEl,
                $el
            } = scrollbar;
            $dragEl[0].style.width = '';
            $dragEl[0].style.height = '';
            trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
            divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
            if (swiper.params.scrollbar.dragSize === 'auto') {
                dragSize = trackSize * divider;
            } else {
                dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
            }
            if (swiper.isHorizontal()) {
                $dragEl[0].style.width = `${dragSize}px`;
            } else {
                $dragEl[0].style.height = `${dragSize}px`;
            }
            if (divider >= 1) {
                $el[0].style.display = 'none';
            } else {
                $el[0].style.display = '';
            }
            if (swiper.params.scrollbar.hide) {
                $el[0].style.opacity = 0;
            }
            if (swiper.params.watchOverflow && swiper.enabled) {
                scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
            }
        }
        function getPointerPosition(e) {
            if (swiper.isHorizontal()) {
                return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
            }
            return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
        }
        function setDragPosition(e) {
            const {
                scrollbar,
                rtlTranslate: rtl
            } = swiper;
            const {
                $el
            } = scrollbar;
            let positionRatio;
            positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
            positionRatio = Math.max(Math.min(positionRatio, 1), 0);
            if (rtl) {
                positionRatio = 1 - positionRatio;
            }
            const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
            swiper.updateProgress(position);
            swiper.setTranslate(position);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        function onDragStart(e) {
            const params = swiper.params.scrollbar;
            const {
                scrollbar,
                $wrapperEl
            } = swiper;
            const {
                $el,
                $dragEl
            } = scrollbar;
            isTouched = true;
            dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
            axPreventDefault(e);
            e.stopPropagation();
            $wrapperEl.transition(100);
            $dragEl.transition(100);
            setDragPosition(e);
            clearTimeout(dragTimeout);
            $el.transition(0);
            if (params.hide) {
                $el.css('opacity', 1);
            }
            if (swiper.params.cssMode) {
                swiper.$wrapperEl.css('scroll-snap-type', 'none');
            }
            emit('scrollbarDragStart', e);
        }
        function onDragMove(e) {
            const {
                scrollbar,
                $wrapperEl
            } = swiper;
            const {
                $el,
                $dragEl
            } = scrollbar;
            if (!isTouched) return;
            axPreventDefault(e);
            setDragPosition(e);
            $wrapperEl.transition(0);
            $el.transition(0);
            $dragEl.transition(0);
            emit('scrollbarDragMove', e);
        }
        function onDragEnd(e) {
            const params = swiper.params.scrollbar;
            const {
                scrollbar,
                $wrapperEl
            } = swiper;
            const {
                $el
            } = scrollbar;
            if (!isTouched) return;
            isTouched = false;
            if (swiper.params.cssMode) {
                swiper.$wrapperEl.css('scroll-snap-type', '');
                $wrapperEl.transition('');
            }
            if (params.hide) {
                clearTimeout(dragTimeout);
                dragTimeout = nextTick(() => {
                    $el.css('opacity', 0);
                    $el.transition(400);
                }, 1000);
            }
            emit('scrollbarDragEnd', e);
            if (params.snapOnRelease) {
                swiper.slideToClosest();
            }
        }
        function events(method) {
            const {
                scrollbar,
                touchEventsTouch,
                touchEventsDesktop,
                params,
                support
            } = swiper;
            const $el = scrollbar.$el;
            const target = $el[0];
            const activeListener = support.passiveListener && params.passiveListeners ? {
                passive: false,
                capture: false
            } : false;
            const passiveListener = support.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (!target) return;
            const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
            if (!support.touch) {
                target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
                document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
                document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
            } else {
                target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
                target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
                target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
            }
        }
        function enableDraggable() {
            if (!swiper.params.scrollbar.el) return;
            events('on');
        }
        function disableDraggable() {
            if (!swiper.params.scrollbar.el) return;
            events('off');
        }
        function init() {
            const {
                scrollbar,
                $el: $swiperEl
            } = swiper;
            swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
                el: 'ax-scrollbar'
            });
            const params = swiper.params.scrollbar;
            if (!params.el) return;
            let $el = $(params.el);
            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
                $el = $swiperEl.find(params.el);
            }
            let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
            if ($dragEl.length === 0) {
                $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
                $el.append($dragEl);
            }
            Object.assign(scrollbar, {
                $el,
                el: $el[0],
                $dragEl,
                dragEl: $dragEl[0]
            });
            if (params.draggable) {
                enableDraggable();
            }
            if ($el) {
                $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
            }
        }
        function destroy() {
            disableDraggable();
        }
        on('init', () => {
            init();
            updateSize();
            setTranslate();
        });
        on('update resize observerUpdate lock unlock', () => {
            updateSize();
        });
        on('setTranslate', () => {
            setTranslate();
        });
        on('setTransition', (_s, duration) => {
            setTransition(duration);
        });
        on('enable disable', () => {
            const {
                $el
            } = swiper.scrollbar;
            if ($el) {
                $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
            }
        });
        on('destroy', () => {
            destroy();
        });
        Object.assign(swiper.scrollbar, {
            updateSize,
            setTranslate,
            init,
            destroy
        });
    }
    function Parallax(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            parallax: {
                enabled: false
            }
        });
        const setTransform = (el, progress) => {
            const {
                rtl
            } = swiper;
            const $el = $(el);
            const rtlFactor = rtl ? -1 : 1;
            const p = $el.attr('data-swiper-parallax') || '0';
            let x = $el.attr('data-swiper-parallax-x');
            let y = $el.attr('data-swiper-parallax-y');
            const scale = $el.attr('data-swiper-parallax-scale');
            const opacity = $el.attr('data-swiper-parallax-opacity');
            if (x || y) {
                x = x || '0';
                y = y || '0';
            } else if (swiper.isHorizontal()) {
                x = p;
                y = '0';
            } else {
                y = p;
                x = '0';
            }
            if (x.indexOf('%') >= 0) {
                x = `${parseInt(x, 10) * progress * rtlFactor}%`;
            } else {
                x = `${x * progress * rtlFactor}px`;
            }
            if (y.indexOf('%') >= 0) {
                y = `${parseInt(y, 10) * progress}%`;
            } else {
                y = `${y * progress}px`;
            }
            if (typeof opacity !== 'undefined' && opacity !== null) {
                const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
                $el[0].style.opacity = currentOpacity;
            }
            if (typeof scale === 'undefined' || scale === null) {
                $el.transform(`translate3d(${x}, ${y}, 0px)`);
            } else {
                const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
                $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
            }
        };
        const setTranslate = () => {
            const {
                $el,
                slides,
                progress,
                snapGrid
            } = swiper;
            $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
                setTransform(el, progress);
            });
            slides.each((slideEl, slideIndex) => {
                let slideProgress = slideEl.progress;
                if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
                    slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
                }
                slideProgress = Math.min(Math.max(slideProgress, -1), 1);
                $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(el => {
                    setTransform(el, slideProgress);
                });
            });
        };
        const setTransition = function (duration) {
            if (duration === void 0) {
                duration = swiper.params.speed;
            }
            const {
                $el
            } = swiper;
            $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(parallaxEl => {
                const $parallaxEl = $(parallaxEl);
                let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
                if (duration === 0) parallaxDuration = 0;
                $parallaxEl.transition(parallaxDuration);
            });
        };
        on('beforeInit', () => {
            if (!swiper.params.parallax.enabled) return;
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
        });
        on('init', () => {
            if (!swiper.params.parallax.enabled) return;
            setTranslate();
        });
        on('setTranslate', () => {
            if (!swiper.params.parallax.enabled) return;
            setTranslate();
        });
        on('setTransition', (_swiper, duration) => {
            if (!swiper.params.parallax.enabled) return;
            setTransition(duration);
        });
    }
    function Zoom(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        const window = getWindow();
        extendParams({
            zoom: {
                enabled: false,
                maxRatio: 3,
                minRatio: 1,
                toggle: true,
                containerClass: 'ax-zoom',
                zoomedSlideClass: 'ax-slide-zoomed'
            }
        });
        swiper.zoom = {
            enabled: false
        };
        let currentScale = 1;
        let isScaling = false;
        let gesturesEnabled;
        let fakeGestureTouched;
        let fakeGestureMoved;
        const gesture = {
            $slideEl: undefined,
            slideWidth: undefined,
            slideHeight: undefined,
            $imageEl: undefined,
            $imageWrapEl: undefined,
            maxRatio: 3
        };
        const image = {
            isTouched: undefined,
            isMoved: undefined,
            currentX: undefined,
            currentY: undefined,
            minX: undefined,
            minY: undefined,
            maxX: undefined,
            maxY: undefined,
            width: undefined,
            height: undefined,
            startX: undefined,
            startY: undefined,
            touchesStart: {},
            touchesCurrent: {}
        };
        const velocity = {
            x: undefined,
            y: undefined,
            prevPositionX: undefined,
            prevPositionY: undefined,
            prevTime: undefined
        };
        let scale = 1;
        Object.defineProperty(swiper.zoom, 'scale', {
            get() {
                return scale;
            },
            set(value) {
                if (scale !== value) {
                    const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;
                    const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;
                    emit('zoomChange', value, imageEl, slideEl);
                }
                scale = value;
            }
        });
        function getDistanceBetweenTouches(e) {
            if (e.targetTouches.length < 2) return 1;
            const x1 = e.targetTouches[0].pageX;
            const y1 = e.targetTouches[0].pageY;
            const x2 = e.targetTouches[1].pageX;
            const y2 = e.targetTouches[1].pageY;
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            return distance;
        } 
        function onGestureStart(e) {
            const support = swiper.support;
            const params = swiper.params.zoom;
            fakeGestureTouched = false;
            fakeGestureMoved = false;
            if (!support.gestures) {
                if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
                    return;
                }
                fakeGestureTouched = true;
                gesture.scaleStart = getDistanceBetweenTouches(e);
            }
            if (!gesture.$slideEl || !gesture.$slideEl.length) {
                gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
                if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
                gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
                gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
                if (gesture.$imageWrapEl.length === 0) {
                    gesture.$imageEl = undefined;
                    return;
                }
            }
            if (gesture.$imageEl) {
                gesture.$imageEl.transition(0);
            }
            isScaling = true;
        }
        function onGestureChange(e) {
            const support = swiper.support;
            const params = swiper.params.zoom;
            const zoom = swiper.zoom;
            if (!support.gestures) {
                if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
                    return;
                }
                fakeGestureMoved = true;
                gesture.scaleMove = getDistanceBetweenTouches(e);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                if (e.type === 'gesturechange') onGestureStart(e);
                return;
            }
            if (support.gestures) {
                zoom.scale = e.scale * currentScale;
            } else {
                zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
            }
            if (zoom.scale > gesture.maxRatio) {
                zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
            }
            if (zoom.scale < params.minRatio) {
                zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
            }
            gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
        }
        function onGestureEnd(e) {
            const device = swiper.device;
            const support = swiper.support;
            const params = swiper.params.zoom;
            const zoom = swiper.zoom;
            if (!support.gestures) {
                if (!fakeGestureTouched || !fakeGestureMoved) {
                    return;
                }
                if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {
                    return;
                }
                fakeGestureTouched = false;
                fakeGestureMoved = false;
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
            gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
            currentScale = zoom.scale;
            isScaling = false;
            if (zoom.scale === 1) gesture.$slideEl = undefined;
        }
        function onTouchStart(e) {
            const device = swiper.device;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            if (image.isTouched) return;
            if (device.android && e.cancelable){
                axPreventDefault(e);
            } 
            image.isTouched = true;
            image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        }
        function onTouchMove(e) {
            const zoom = swiper.zoom;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            swiper.allowClick = false;
            if (!image.isTouched || !gesture.$slideEl) return;
            if (!image.isMoved) {
                image.width = gesture.$imageEl[0].offsetWidth;
                image.height = gesture.$imageEl[0].offsetHeight;
                image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
                image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
                gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
                gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
                gesture.$imageWrapEl.transition(0);
            } 
            const scaledWidth = image.width * zoom.scale;
            const scaledHeight = image.height * zoom.scale;
            if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
            image.maxX = -image.minX;
            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
            image.maxY = -image.minY;
            image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
            image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
            if (!image.isMoved && !isScaling) {
                if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
                    image.isTouched = false;
                    return;
                }
                if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
                    image.isTouched = false;
                    return;
                }
            }
            if (e.cancelable) {
                axPreventDefault(e);
            }
            e.stopPropagation();
            image.isMoved = true;
            image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
            image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;
            if (image.currentX < image.minX) {
                image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
            }
            if (image.currentX > image.maxX) {
                image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
            }
            if (image.currentY < image.minY) {
                image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
            }
            if (image.currentY > image.maxY) {
                image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
            } 
            if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
            if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
            if (!velocity.prevTime) velocity.prevTime = Date.now();
            velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
            velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
            if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
            if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
            velocity.prevPositionX = image.touchesCurrent.x;
            velocity.prevPositionY = image.touchesCurrent.y;
            velocity.prevTime = Date.now();
            gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
        }
        function onTouchEnd() {
            const zoom = swiper.zoom;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            if (!image.isTouched || !image.isMoved) {
                image.isTouched = false;
                image.isMoved = false;
                return;
            }
            image.isTouched = false;
            image.isMoved = false;
            let momentumDurationX = 300;
            let momentumDurationY = 300;
            const momentumDistanceX = velocity.x * momentumDurationX;
            const newPositionX = image.currentX + momentumDistanceX;
            const momentumDistanceY = velocity.y * momentumDurationY;
            const newPositionY = image.currentY + momentumDistanceY; 
            if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
            if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
            const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
            image.currentX = newPositionX;
            image.currentY = newPositionY; 
            const scaledWidth = image.width * zoom.scale;
            const scaledHeight = image.height * zoom.scale;
            image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
            image.maxX = -image.minX;
            image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
            image.maxY = -image.minY;
            image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
            image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
            gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
        }
        function onTransitionEnd() {
            const zoom = swiper.zoom;
            if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
                if (gesture.$imageEl) {
                    gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
                }
                if (gesture.$imageWrapEl) {
                    gesture.$imageWrapEl.transform('translate3d(0,0,0)');
                }
                zoom.scale = 1;
                currentScale = 1;
                gesture.$slideEl = undefined;
                gesture.$imageEl = undefined;
                gesture.$imageWrapEl = undefined;
            }
        }
        function zoomIn(e) {
            const zoom = swiper.zoom;
            const params = swiper.params.zoom;
            if (!gesture.$slideEl) {
                if (e && e.target) {
                    gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
                }
                if (!gesture.$slideEl) {
                    if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
                    } else {
                        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                    }
                }
                gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
                gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
            if (swiper.params.cssMode) {
                swiper.wrapperEl.style.overflow = 'hidden';
                swiper.wrapperEl.style.touchAction = 'none';
            }
            gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
            let touchX;
            let touchY;
            let offsetX;
            let offsetY;
            let diffX;
            let diffY;
            let translateX;
            let translateY;
            let imageWidth;
            let imageHeight;
            let scaledWidth;
            let scaledHeight;
            let translateMinX;
            let translateMinY;
            let translateMaxX;
            let translateMaxY;
            let slideWidth;
            let slideHeight;
            if (typeof image.touchesStart.x === 'undefined' && e) {
                touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
                touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
            } else {
                touchX = image.touchesStart.x;
                touchY = image.touchesStart.y;
            }
            zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
            currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
            if (e) {
                slideWidth = gesture.$slideEl[0].offsetWidth;
                slideHeight = gesture.$slideEl[0].offsetHeight;
                offsetX = gesture.$slideEl.offset().left + window.scrollX;
                offsetY = gesture.$slideEl.offset().top + window.scrollY;
                diffX = offsetX + slideWidth / 2 - touchX;
                diffY = offsetY + slideHeight / 2 - touchY;
                imageWidth = gesture.$imageEl[0].offsetWidth;
                imageHeight = gesture.$imageEl[0].offsetHeight;
                scaledWidth = imageWidth * zoom.scale;
                scaledHeight = imageHeight * zoom.scale;
                translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
                translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
                translateMaxX = -translateMinX;
                translateMaxY = -translateMinY;
                translateX = diffX * zoom.scale;
                translateY = diffY * zoom.scale;
                if (translateX < translateMinX) {
                    translateX = translateMinX;
                }
                if (translateX > translateMaxX) {
                    translateX = translateMaxX;
                }
                if (translateY < translateMinY) {
                    translateY = translateMinY;
                }
                if (translateY > translateMaxY) {
                    translateY = translateMaxY;
                }
            } else {
                translateX = 0;
                translateY = 0;
            }
            gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
            gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
        }
        function zoomOut() {
            const zoom = swiper.zoom;
            const params = swiper.params.zoom;
            if (!gesture.$slideEl) {
                if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                    gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
                } else {
                    gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                }
                gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);
                gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
            if (swiper.params.cssMode) {
                swiper.wrapperEl.style.overflow = '';
                swiper.wrapperEl.style.touchAction = '';
            }
            zoom.scale = 1;
            currentScale = 1;
            gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
            gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
            gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
            gesture.$slideEl = undefined;
        } 
        function zoomToggle(e) {
            const zoom = swiper.zoom;
            if (zoom.scale && zoom.scale !== 1) {
                zoomOut();
            } else {
                zoomIn(e);
            }
        }
        function getListeners() {
            const support = swiper.support;
            const passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            const activeListenerWithCapture = support.passiveListener ? {
                passive: false,
                capture: true
            } : true;
            return {
                passiveListener,
                activeListenerWithCapture
            };
        }
        function getSlideSelector() {
            return `.${swiper.params.slideClass}`;
        }
        function toggleGestures(method) {
            const {
                passiveListener
            } = getListeners();
            const slideSelector = getSlideSelector();
            swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);
            swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);
            swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);
        }
        function enableGestures() {
            if (gesturesEnabled) return;
            gesturesEnabled = true;
            toggleGestures('on');
        }
        function disableGestures() {
            if (!gesturesEnabled) return;
            gesturesEnabled = false;
            toggleGestures('off');
        } 
        function enable() {
            const zoom = swiper.zoom;
            if (zoom.enabled) return;
            zoom.enabled = true;
            const support = swiper.support;
            const {
                passiveListener,
                activeListenerWithCapture
            } = getListeners();
            const slideSelector = getSlideSelector(); 
            if (support.gestures) {
                swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);
                swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);
            } else if (swiper.touchEvents.start === 'touchstart') {
                swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
                swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
                swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
                if (swiper.touchEvents.cancel) {
                    swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
                }
            } 
            swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
        }
        function disable() {
            const zoom = swiper.zoom;
            if (!zoom.enabled) return;
            const support = swiper.support;
            zoom.enabled = false;
            const {
                passiveListener,
                activeListenerWithCapture
            } = getListeners();
            const slideSelector = getSlideSelector(); 
            if (support.gestures) {
                swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);
                swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);
            } else if (swiper.touchEvents.start === 'touchstart') {
                swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
                swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
                swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
                if (swiper.touchEvents.cancel) {
                    swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
                }
            } 
            swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove, activeListenerWithCapture);
        }
        on('init', () => {
            if (swiper.params.zoom.enabled) {
                enable();
            }
        });
        on('destroy', () => {
            disable();
        });
        on('touchStart', (_s, e) => {
            if (!swiper.zoom.enabled) return;
            onTouchStart(e);
        });
        on('touchEnd', (_s, e) => {
            if (!swiper.zoom.enabled) return;
            onTouchEnd();
        });
        on('doubleTap', (_s, e) => {
            if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
                zoomToggle(e);
            }
        });
        on('transitionEnd', () => {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
                onTransitionEnd();
            }
        });
        on('slideChange', () => {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
                onTransitionEnd();
            }
        });
        Object.assign(swiper.zoom, {
            enable,
            disable,
            in: zoomIn,
            out: zoomOut,
            toggle: zoomToggle
        });
    }
    function Lazy(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        extendParams({
            lazy: {
                checkInView: false,
                enabled: false,
                loadPrevNext: false,
                loadPrevNextAmount: 1,
                loadOnTransitionStart: false,
                scrollingElement: '',
                elementClass: 'ax-lazy',
                loadingClass: 'ax-lazy-loading',
                loadedClass: 'ax-lazy-loaded',
                preloaderClass: 'ax-loading'
            }
        });
        swiper.lazy = {};
        let scrollHandlerAttached = false;
        let initialImageLoaded = false;
        function loadInSlide(index, loadInDuplicate) {
            if (loadInDuplicate === void 0) {
                loadInDuplicate = true;
            }
            const params = swiper.params.lazy;
            if (typeof index === 'undefined') return;
            if (swiper.slides.length === 0) return;
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`) : swiper.slides.eq(index);
            const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
            if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
                $images.push($slideEl[0]);
            }
            if ($images.length === 0) return;
            $images.each(imageEl => {
                const $imageEl = $(imageEl);
                $imageEl.addClass(params.loadingClass);
                const background = $imageEl.attr('data-background');
                const src = $imageEl.attr('data-src');
                const srcset = $imageEl.attr('data-srcset');
                const sizes = $imageEl.attr('data-sizes');
                const $pictureEl = $imageEl.parent('picture');
                swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
                    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;
                    if (background) {
                        $imageEl.css('background-image', `url("${background}")`);
                        $imageEl.removeAttr('data-background');
                    } else {
                        if (srcset) {
                            $imageEl.attr('srcset', srcset);
                            $imageEl.removeAttr('data-srcset');
                        }
                        if (sizes) {
                            $imageEl.attr('sizes', sizes);
                            $imageEl.removeAttr('data-sizes');
                        }
                        if ($pictureEl.length) {
                            $pictureEl.children('source').each(sourceEl => {
                                const $source = $(sourceEl);
                                if ($source.attr('data-srcset')) {
                                    $source.attr('srcset', $source.attr('data-srcset'));
                                    $source.removeAttr('data-srcset');
                                }
                            });
                        }
                        if (src) {
                            $imageEl.attr('src', src);
                            $imageEl.removeAttr('data-src');
                        }
                    }
                    $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
                    $slideEl.find(`.${params.preloaderClass}`).remove();
                    if (swiper.params.loop && loadInDuplicate) {
                        const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
                        if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
                            loadInSlide(originalSlide.index(), false);
                        } else {
                            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
                            loadInSlide(duplicatedSlide.index(), false);
                        }
                    }
                    emit('lazyImageReady', $slideEl[0], $imageEl[0]);
                    if (swiper.params.autoHeight) {
                        swiper.updateAutoHeight();
                    }
                });
                emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
            });
        }
        function load() {
            const {
                $wrapperEl,
                params: swiperParams,
                slides,
                activeIndex
            } = swiper;
            const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
            const params = swiperParams.lazy;
            let slidesPerView = swiperParams.slidesPerView;
            if (slidesPerView === 'auto') {
                slidesPerView = 0;
            }
            function slideExist(index) {
                if (isVirtual) {
                    if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
                        return true;
                    }
                } else if (slides[index]) return true;
                return false;
            }
            function slideIndex(slideEl) {
                if (isVirtual) {
                    return $(slideEl).attr('data-swiper-slide-index');
                }
                return $(slideEl).index();
            }
            if (!initialImageLoaded) initialImageLoaded = true;
            if (swiper.params.watchSlidesProgress) {
                $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each(slideEl => {
                    const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
                    loadInSlide(index);
                });
            } else if (slidesPerView > 1) {
                for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
                    if (slideExist(i)) loadInSlide(i);
                }
            } else {
                loadInSlide(activeIndex);
            }
            if (params.loadPrevNext) {
                if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
                    const amount = params.loadPrevNextAmount;
                    const spv = slidesPerView;
                    const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
                    const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); 
                    for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
                        if (slideExist(i)) loadInSlide(i);
                    } 
                    for (let i = minIndex; i < activeIndex; i += 1) {
                        if (slideExist(i)) loadInSlide(i);
                    }
                } else {
                    const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
                    if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));
                    const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
                    if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));
                }
            }
        }
        function checkInViewOnLoad() {
            const window = getWindow();
            if (!swiper || swiper.destroyed) return;
            const $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window);
            const isWindow = $scrollElement[0] === window;
            const scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
            const scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
            const swiperOffset = swiper.$el.offset();
            const {
                rtlTranslate: rtl
            } = swiper;
            let inView = false;
            if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
            const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];
            for (let i = 0; i < swiperCoord.length; i += 1) {
                const point = swiperCoord[i];
                if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
                    if (point[0] === 0 && point[1] === 0) continue; 
                    inView = true;
                }
            }
            const passiveListener = swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (inView) {
                load();
                $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);
            } else if (!scrollHandlerAttached) {
                scrollHandlerAttached = true;
                $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);
            }
        }
        on('beforeInit', () => {
            if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
                swiper.params.preloadImages = false;
            }
        });
        on('init', () => {
            if (swiper.params.lazy.enabled) {
                if (swiper.params.lazy.checkInView) {
                    checkInViewOnLoad();
                } else {
                    load();
                }
            }
        });
        on('scroll', () => {
            if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {
                load();
            }
        });
        on('scrollbarDragMove resize _freeModeNoMomentumRelease', () => {
            if (swiper.params.lazy.enabled) {
                if (swiper.params.lazy.checkInView) {
                    checkInViewOnLoad();
                } else {
                    load();
                }
            }
        });
        on('transitionStart', () => {
            if (swiper.params.lazy.enabled) {
                if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
                    if (swiper.params.lazy.checkInView) {
                        checkInViewOnLoad();
                    } else {
                        load();
                    }
                }
            }
        });
        on('transitionEnd', () => {
            if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
                if (swiper.params.lazy.checkInView) {
                    checkInViewOnLoad();
                } else {
                    load();
                }
            }
        });
        on('slideChange', () => {
            const {
                lazy,
                cssMode,
                watchSlidesProgress,
                touchReleaseOnEdges,
                resistanceRatio
            } = swiper.params;
            if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
                load();
            }
        });
        Object.assign(swiper.lazy, {
            load,
            loadInSlide
        });
    }
    /* eslint no-bitwise: ["error", { "allow": [">>"] }] */
    function Controller(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            controller: {
                control: undefined,
                inverse: false,
                by: 'slide' 
            }
        });
        swiper.controller = {
            control: undefined
        };
        function LinearSpline(x, y) {
            const binarySearch = function search() {
                let maxIndex;
                let minIndex;
                let guess;
                return (array, val) => {
                    minIndex = -1;
                    maxIndex = array.length;
                    while (maxIndex - minIndex > 1) {
                        guess = maxIndex + minIndex >> 1;
                        if (array[guess] <= val) {
                            minIndex = guess;
                        } else {
                            maxIndex = guess;
                        }
                    }
                    return maxIndex;
                };
            }();
            this.x = x;
            this.y = y;
            this.lastIndex = x.length - 1; 
            let i1;
            let i3;
            this.interpolate = function interpolate(x2) {
                if (!x2) return 0; 
                i3 = binarySearch(this.x, x2);
                i1 = i3 - 1; 
                return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
            };
            return this;
        } 
        function getInterpolateFunction(c) {
            if (!swiper.controller.spline) {
                swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
            }
        }
        function setTranslate(_t, byController) {
            const controlled = swiper.controller.control;
            let multiplier;
            let controlledTranslate;
            const Swiper = swiper.constructor;
            function setControlledTranslate(c) {
                const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
                if (swiper.params.controller.by === 'slide') {
                    getInterpolateFunction(c); 
                    controlledTranslate = -swiper.controller.spline.interpolate(-translate);
                }
                if (!controlledTranslate || swiper.params.controller.by === 'container') {
                    multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                    controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
                }
                if (swiper.params.controller.inverse) {
                    controlledTranslate = c.maxTranslate() - controlledTranslate;
                }
                c.updateProgress(controlledTranslate);
                c.setTranslate(controlledTranslate, swiper);
                c.updateActiveIndex();
                c.updateSlidesClasses();
            }
            if (Array.isArray(controlled)) {
                for (let i = 0; i < controlled.length; i += 1) {
                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                        setControlledTranslate(controlled[i]);
                    }
                }
            } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTranslate(controlled);
            }
        }
        function setTransition(duration, byController) {
            const Swiper = swiper.constructor;
            const controlled = swiper.controller.control;
            let i;
            function setControlledTransition(c) {
                c.setTransition(duration, swiper);
                if (duration !== 0) {
                    c.transitionStart();
                    if (c.params.autoHeight) {
                        nextTick(() => {
                            c.updateAutoHeight();
                        });
                    }
                    c.$wrapperEl.transitionEnd(() => {
                        if (!controlled) return;
                        if (c.params.loop && swiper.params.controller.by === 'slide') {
                            c.loopFix();
                        }
                        c.transitionEnd();
                    });
                }
            }
            if (Array.isArray(controlled)) {
                for (i = 0; i < controlled.length; i += 1) {
                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                        setControlledTransition(controlled[i]);
                    }
                }
            } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTransition(controlled);
            }
        }
        function removeSpline() {
            if (!swiper.controller.control) return;
            if (swiper.controller.spline) {
                swiper.controller.spline = undefined;
                delete swiper.controller.spline;
            }
        }
        on('beforeInit', () => {
            swiper.controller.control = swiper.params.controller.control;
        });
        on('update', () => {
            removeSpline();
        });
        on('resize', () => {
            removeSpline();
        });
        on('observerUpdate', () => {
            removeSpline();
        });
        on('setTranslate', (_s, translate, byController) => {
            if (!swiper.controller.control) return;
            swiper.controller.setTranslate(translate, byController);
        });
        on('setTransition', (_s, duration, byController) => {
            if (!swiper.controller.control) return;
            swiper.controller.setTransition(duration, byController);
        });
        Object.assign(swiper.controller, {
            setTranslate,
            setTransition
        });
    }
    function A11y(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            a11y: {
                enabled: true,
                notificationClass: 'ax-notification',
                prevSlideMessage: '上一个',
                nextSlideMessage: '下一个',
                firstSlideMessage: '这是第一个',
                lastSlideMessage: '这是最后一个',
                paginationBulletMessage: '跳转到第{{index}}页',
                slideLabelMessage: '第{{index}}/{{slidesLength}}页',
                containerMessage: null,
                containerRoleDescriptionMessage: null,
                itemRoleDescriptionMessage: null,
                slideRole: 'group',
                id: null
            }
        });
        let liveRegion = null;
        function notify(message) {
            const notification = liveRegion;
            if (notification.length === 0) return;
            notification.html('');
            notification.html(message);
        }
        function getRandomNumber(size) {
            if (size === void 0) {
                size = 16;
            }
            const randomChar = () => Math.round(16 * Math.random()).toString(16);
            return 'x'.repeat(size).replace(/x/g, randomChar);
        }
        function makeElFocusable($el) {
            $el.attr('tabIndex', '0');
        }
        function makeElNotFocusable($el) {
            $el.attr('tabIndex', '-1');
        }
        function addElRole($el, role) {
            $el.attr('role', role);
        }
        function addElRoleDescription($el, description) {
            $el.attr('aria-roledescription', description);
        }
        function addElControls($el, controls) {
            $el.attr('aria-controls', controls);
        }
        function addElLabel($el, label) {
            $el.attr('aria-label', label);
        }
        function addElId($el, id) {
            $el.attr('id', id);
        }
        function addElLive($el, live) {
            $el.attr('aria-live', live);
        }
        function disableEl($el) {
            $el.attr('aria-disabled', true);
        }
        function enableEl($el) {
            $el.attr('aria-disabled', false);
        }
        function onEnterOrSpaceKey(e) {
            if (e.keyCode !== 13 && e.keyCode !== 32) return;
            const params = swiper.params.a11y;
            const $targetEl = $(e.target);
            if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
                if (!(swiper.isEnd && !swiper.params.loop)) {
                    swiper.slideNext();
                }
                if (swiper.isEnd) {
                    notify(params.lastSlideMessage);
                } else {
                    notify(params.nextSlideMessage);
                }
            }
            if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
                if (!(swiper.isBeginning && !swiper.params.loop)) {
                    swiper.slidePrev();
                }
                if (swiper.isBeginning) {
                    notify(params.firstSlideMessage);
                } else {
                    notify(params.prevSlideMessage);
                }
            }
            if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
                $targetEl[0].click();
            }
        }
        function updateNavigation() {
            if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
            const {
                $nextEl,
                $prevEl
            } = swiper.navigation;
            if ($prevEl && $prevEl.length > 0) {
                if (swiper.isBeginning) {
                    disableEl($prevEl);
                    makeElNotFocusable($prevEl);
                } else {
                    enableEl($prevEl);
                    makeElFocusable($prevEl);
                }
            }
            if ($nextEl && $nextEl.length > 0) {
                if (swiper.isEnd) {
                    disableEl($nextEl);
                    makeElNotFocusable($nextEl);
                } else {
                    enableEl($nextEl);
                    makeElFocusable($nextEl);
                }
            }
        }
        function hasPagination() {
            return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
        }
        function hasClickablePagination() {
            return hasPagination() && swiper.params.pagination.clickable;
        }
        function updatePagination() {
            const params = swiper.params.a11y;
            if (!hasPagination()) return;
            swiper.pagination.bullets.each(bulletEl => {
                const $bulletEl = $(bulletEl);
                if (swiper.params.pagination.clickable) {
                    makeElFocusable($bulletEl);
                    if (!swiper.params.pagination.renderBullet) {
                        addElRole($bulletEl, 'button');
                        addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
                    }
                }
                if ($bulletEl.is(`.${swiper.params.pagination.bulletActiveClass}`)) {
                    $bulletEl.attr('aria-current', 'true');
                } else {
                    $bulletEl.removeAttr('aria-current');
                }
            });
        }
        const initNavEl = ($el, wrapperId, message) => {
            makeElFocusable($el);
            if ($el[0].tagName !== 'BUTTON') {
                addElRole($el, 'button');
                $el.on('keydown', onEnterOrSpaceKey);
            }
            addElLabel($el, message);
            addElControls($el, wrapperId);
        };
        const handleFocus = e => {
            const slideEl = e.target.closest(`.${swiper.params.slideClass}`);
            if (!slideEl || !swiper.slides.includes(slideEl)) return;
            const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
            const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
            if (isActive || isVisible) return;
            swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
        };
        function init() {
            const params = swiper.params.a11y;
            swiper.$el.append(liveRegion); 
            const $containerEl = swiper.$el;
            if (params.containerRoleDescriptionMessage) {
                addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
            }
            if (params.containerMessage) {
                addElLabel($containerEl, params.containerMessage);
            } 
            const $wrapperEl = swiper.$wrapperEl;
            const wrapperId = params.id || $wrapperEl.attr('id') || `ax-wrapper-${getRandomNumber(16)}`;
            const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
            addElId($wrapperEl, wrapperId);
            addElLive($wrapperEl, live); 
            if (params.itemRoleDescriptionMessage) {
                addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);
            }
            addElRole($(swiper.slides), params.slideRole);
            const slidesLength = swiper.params.loop ? swiper.slides.filter(el => !el.classList.contains(swiper.params.slideDuplicateClass)).length : swiper.slides.length;
            swiper.slides.each((slideEl, index) => {
                const $slideEl = $(slideEl);
                const slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;
                const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
                addElLabel($slideEl, ariaLabelMessage);
            }); 
            let $nextEl;
            let $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
                $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
                $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl && $nextEl.length) {
                initNavEl($nextEl, wrapperId, params.nextSlideMessage);
            }
            if ($prevEl && $prevEl.length) {
                initNavEl($prevEl, wrapperId, params.prevSlideMessage);
            } 
            if (hasClickablePagination()) {
                swiper.pagination.$el.on('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
            } 
            swiper.$el.on('focus', handleFocus, true);
        }
        function destroy() {
            if (liveRegion && liveRegion.length > 0) liveRegion.remove();
            let $nextEl;
            let $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
                $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
                $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl) {
                $nextEl.off('keydown', onEnterOrSpaceKey);
            }
            if ($prevEl) {
                $prevEl.off('keydown', onEnterOrSpaceKey);
            } 
            if (hasClickablePagination()) {
                swiper.pagination.$el.off('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
            } 
            swiper.$el.off('focus', handleFocus, true);
        }
        on('beforeInit', () => {
            liveRegion = $(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`);
        });
        on('afterInit', () => {
            if (!swiper.params.a11y.enabled) return;
            init();
        });
        on('fromEdge toEdge afterInit lock unlock', () => {
            if (!swiper.params.a11y.enabled) return;
            updateNavigation();
        });
        on('paginationUpdate', () => {
            if (!swiper.params.a11y.enabled) return;
            updatePagination();
        });
        on('destroy', () => {
            if (!swiper.params.a11y.enabled) return;
            destroy();
        });
    }
    function History(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            history: {
                enabled: false,
                root: '',
                replaceState: false,
                key: 'slides'
            }
        });
        let initialized = false;
        let paths = {};
        const slugify = text => {
            return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
        };
        const getPathValues = urlOverride => {
            const window = getWindow();
            let location;
            if (urlOverride) {
                location = new URL(urlOverride);
            } else {
                location = window.location;
            }
            const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
            const total = pathArray.length;
            const key = pathArray[total - 2];
            const value = pathArray[total - 1];
            return {
                key,
                value
            };
        };
        const setHistory = (key, index) => {
            const window = getWindow();
            if (!initialized || !swiper.params.history.enabled) return;
            let location;
            if (swiper.params.url) {
                location = new URL(swiper.params.url);
            } else {
                location = window.location;
            }
            const slide = swiper.slides.eq(index);
            let value = slugify(slide.attr('data-history'));
            if (swiper.params.history.root.length > 0) {
                let root = swiper.params.history.root;
                if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
                value = `${root}/${key}/${value}`;
            } else if (!location.pathname.includes(key)) {
                value = `${key}/${value}`;
            }
            const currentState = window.history.state;
            if (currentState && currentState.value === value) {
                return;
            }
            if (swiper.params.history.replaceState) {
                window.history.replaceState({
                    value
                }, null, value);
            } else {
                window.history.pushState({
                    value
                }, null, value);
            }
        };
        const scrollToSlide = (speed, value, runCallbacks) => {
            if (value) {
                for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
                    const slide = swiper.slides.eq(i);
                    const slideHistory = slugify(slide.attr('data-history'));
                    if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                        const index = slide.index();
                        swiper.slideTo(index, speed, runCallbacks);
                    }
                }
            } else {
                swiper.slideTo(0, speed, runCallbacks);
            }
        };
        const setHistoryPopState = () => {
            paths = getPathValues(swiper.params.url);
            scrollToSlide(swiper.params.speed, swiper.paths.value, false);
        };
        const init = () => {
            const window = getWindow();
            if (!swiper.params.history) return;
            if (!window.history || !window.history.pushState) {
                swiper.params.history.enabled = false;
                swiper.params.hashNavigation.enabled = true;
                return;
            }
            initialized = true;
            paths = getPathValues(swiper.params.url);
            if (!paths.key && !paths.value) return;
            scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
            if (!swiper.params.history.replaceState) {
                window.addEventListener('popstate', setHistoryPopState);
            }
        };
        const destroy = () => {
            const window = getWindow();
            if (!swiper.params.history.replaceState) {
                window.removeEventListener('popstate', setHistoryPopState);
            }
        };
        on('init', () => {
            if (swiper.params.history.enabled) {
                init();
            }
        });
        on('destroy', () => {
            if (swiper.params.history.enabled) {
                destroy();
            }
        });
        on('transitionEnd _freeModeNoMomentumRelease', () => {
            if (initialized) {
                setHistory(swiper.params.history.key, swiper.activeIndex);
            }
        });
        on('slideChange', () => {
            if (initialized && swiper.params.cssMode) {
                setHistory(swiper.params.history.key, swiper.activeIndex);
            }
        });
    }
    function HashNavigation(_ref) {
        let {
            swiper,
            extendParams,
            emit,
            on
        } = _ref;
        let initialized = false;
        const document = getDocument();
        const window = getWindow();
        extendParams({
            hashNavigation: {
                enabled: false,
                replaceState: false,
                watchState: false
            }
        });
        const onHashChange = () => {
            emit('hashChange');
            const newHash = document.location.hash.replace('#', '');
            const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
            if (newHash !== activeSlideHash) {
                const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
                if (typeof newIndex === 'undefined') return;
                swiper.slideTo(newIndex);
            }
        };
        const setHash = () => {
            if (!initialized || !swiper.params.hashNavigation.enabled) return;
            if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
                window.history.replaceState(null, null, `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '');
                emit('hashSet');
            } else {
                const slide = swiper.slides.eq(swiper.activeIndex);
                const hash = slide.attr('data-hash') || slide.attr('data-history');
                document.location.hash = hash || '';
                emit('hashSet');
            }
        };
        const init = () => {
            if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
            initialized = true;
            const hash = document.location.hash.replace('#', '');
            if (hash) {
                const speed = 0;
                for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
                    const slide = swiper.slides.eq(i);
                    const slideHash = slide.attr('data-hash') || slide.attr('data-history');
                    if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                        const index = slide.index();
                        swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
                    }
                }
            }
            if (swiper.params.hashNavigation.watchState) {
                $(window).on('hashchange', onHashChange);
            }
        };
        const destroy = () => {
            if (swiper.params.hashNavigation.watchState) {
                $(window).off('hashchange', onHashChange);
            }
        };
        on('init', () => {
            if (swiper.params.hashNavigation.enabled) {
                init();
            }
        });
        on('destroy', () => {
            if (swiper.params.hashNavigation.enabled) {
                destroy();
            }
        });
        on('transitionEnd _freeModeNoMomentumRelease', () => {
            if (initialized) {
                setHash();
            }
        });
        on('slideChange', () => {
            if (initialized && swiper.params.cssMode) {
                setHash();
            }
        });
    }
    /* eslint no-underscore-dangle: "off" */
    function Autoplay(_ref) {
        let {
            swiper,
            extendParams,
            on,
            emit
        } = _ref;
        let timeout;
        swiper.autoplay = {
            running: false,
            paused: false
        };
        extendParams({
            autoplay: {
                enabled: false,
                delay: 3000,
                waitForTransition: true,
                disableOnInteraction: true,
                stopOnLastSlide: false,
                reverseDirection: false,
                pauseOnMouseEnter: false
            }
        });
        function run() {
            const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
            let delay = swiper.params.autoplay.delay;
            if ($activeSlideEl.attr('data-swiper-autoplay')) {
                delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
            }
            clearTimeout(timeout);
            timeout = nextTick(() => {
                let autoplayResult;
                if (swiper.params.autoplay.reverseDirection) {
                    if (swiper.params.loop) {
                        swiper.loopFix();
                        autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
                        emit('autoplay');
                    } else if (!swiper.isBeginning) {
                        autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
                        emit('autoplay');
                    } else if (!swiper.params.autoplay.stopOnLastSlide) {
                        autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
                        emit('autoplay');
                    } else {
                        stop();
                    }
                } else if (swiper.params.loop) {
                    swiper.loopFix();
                    autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
                    emit('autoplay');
                } else if (!swiper.isEnd) {
                    autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
                    emit('autoplay');
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                    autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
                    emit('autoplay');
                } else {
                    stop();
                }
                if (swiper.params.cssMode && swiper.autoplay.running) run(); else if (autoplayResult === false) {
                    run();
                }
            }, delay);
        }
        function start() {
            if (typeof timeout !== 'undefined') return false;
            if (swiper.autoplay.running) return false;
            swiper.autoplay.running = true;
            emit('autoplayStart');
            run();
            return true;
        }
        function stop() {
            if (!swiper.autoplay.running) return false;
            if (typeof timeout === 'undefined') return false;
            if (timeout) {
                clearTimeout(timeout);
                timeout = undefined;
            }
            swiper.autoplay.running = false;
            emit('autoplayStop');
            return true;
        }
        function pause(speed) {
            if (!swiper.autoplay.running) return;
            if (swiper.autoplay.paused) return;
            if (timeout) clearTimeout(timeout);
            swiper.autoplay.paused = true;
            if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
                swiper.autoplay.paused = false;
                run();
            } else {
                ['transitionend', 'webkitTransitionEnd'].forEach(event => {
                    swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
                });
            }
        }
        function onVisibilityChange() {
            const document = getDocument();
            if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
                pause();
            }
            if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
                run();
                swiper.autoplay.paused = false;
            }
        }
        function onTransitionEnd(e) {
            if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
            if (e.target !== swiper.$wrapperEl[0]) return;
            ['transitionend', 'webkitTransitionEnd'].forEach(event => {
                swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
            });
            swiper.autoplay.paused = false;
            if (!swiper.autoplay.running) {
                stop();
            } else {
                run();
            }
        }
        function onMouseEnter() {
            if (swiper.params.autoplay.disableOnInteraction) {
                stop();
            } else {
                emit('autoplayPause');
                pause();
            }
            ['transitionend', 'webkitTransitionEnd'].forEach(event => {
                swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
            });
        }
        function onMouseLeave() {
            if (swiper.params.autoplay.disableOnInteraction) {
                return;
            }
            swiper.autoplay.paused = false;
            emit('autoplayResume');
            run();
        }
        function attachMouseEvents() {
            if (swiper.params.autoplay.pauseOnMouseEnter) {
                swiper.$el.on('mouseenter', onMouseEnter);
                swiper.$el.on('mouseleave', onMouseLeave);
            }
        }
        function detachMouseEvents() {
            swiper.$el.off('mouseenter', onMouseEnter);
            swiper.$el.off('mouseleave', onMouseLeave);
        }
        on('init', () => {
            if (swiper.params.autoplay.enabled) {
                start();
                const document = getDocument();
                document.addEventListener('visibilitychange', onVisibilityChange);
                attachMouseEvents();
            }
        });
        on('beforeTransitionStart', (_s, speed, internal) => {
            if (swiper.autoplay.running) {
                if (internal || !swiper.params.autoplay.disableOnInteraction) {
                    swiper.autoplay.pause(speed);
                } else {
                    stop();
                }
            }
        });
        on('sliderFirstMove', () => {
            if (swiper.autoplay.running) {
                if (swiper.params.autoplay.disableOnInteraction) {
                    stop();
                } else {
                    pause();
                }
            }
        });
        on('touchEnd', () => {
            if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
                run();
            }
        });
        on('destroy', () => {
            detachMouseEvents();
            if (swiper.autoplay.running) {
                stop();
            }
            const document = getDocument();
            document.removeEventListener('visibilitychange', onVisibilityChange);
        });
        Object.assign(swiper.autoplay, {
            pause,
            run,
            start,
            stop
        });
    }
    function Thumb(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            thumbs: {
                swiper: null,
                multipleActiveThumbs: true,
                autoScrollOffset: 0,
                slideThumbActiveClass: 'ax-slide-thumb-active',
                thumbsContainerClass: 'ax-thumbs'
            }
        });
        let initialized = false;
        let swiperCreated = false;
        swiper.thumbs = {
            swiper: null
        };
        function onThumbClick() {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            const clickedIndex = thumbsSwiper.clickedIndex;
            const clickedSlide = thumbsSwiper.clickedSlide;
            if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
            if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
            let slideToIndex;
            if (thumbsSwiper.params.loop) {
                slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
            } else {
                slideToIndex = clickedIndex;
            }
            if (swiper.params.loop) {
                let currentIndex = swiper.activeIndex;
                if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
                    swiper.loopFix(); 
                    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
                    currentIndex = swiper.activeIndex;
                }
                const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
                const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
                if (typeof prevIndex === 'undefined') slideToIndex = nextIndex; else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex; else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex; else slideToIndex = prevIndex;
            }
            swiper.slideTo(slideToIndex);
        }
        function init() {
            const {
                thumbs: thumbsParams
            } = swiper.params;
            if (initialized) return false;
            initialized = true;
            const SwiperClass = swiper.constructor;
            if (thumbsParams.swiper instanceof SwiperClass) {
                swiper.thumbs.swiper = thumbsParams.swiper;
                Object.assign(swiper.thumbs.swiper.originalParams, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false
                });
                Object.assign(swiper.thumbs.swiper.params, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false
                });
            } else if (isObject(thumbsParams.swiper)) {
                const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
                Object.assign(thumbsSwiperParams, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false
                });
                swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
                swiperCreated = true;
            }
            swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
            swiper.thumbs.swiper.on('tap', onThumbClick);
            return true;
        }
        function update(initial) {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
            const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
            const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
            if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
                let currentThumbsIndex = thumbsSwiper.activeIndex;
                let newThumbsIndex;
                let direction;
                if (thumbsSwiper.params.loop) {
                    if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
                        thumbsSwiper.loopFix(); 
                        thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
                        currentThumbsIndex = thumbsSwiper.activeIndex;
                    } 
                    const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
                    const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
                    if (typeof prevThumbsIndex === 'undefined') {
                        newThumbsIndex = nextThumbsIndex;
                    } else if (typeof nextThumbsIndex === 'undefined') {
                        newThumbsIndex = prevThumbsIndex;
                    } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
                        newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
                    } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
                        newThumbsIndex = nextThumbsIndex;
                    } else {
                        newThumbsIndex = prevThumbsIndex;
                    }
                    direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
                } else {
                    newThumbsIndex = swiper.realIndex;
                    direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
                }
                if (useOffset) {
                    newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
                }
                if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                    if (thumbsSwiper.params.centeredSlides) {
                        if (newThumbsIndex > currentThumbsIndex) {
                            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                        } else {
                            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                        }
                    } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1);
                    thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
                }
            } 
            let thumbsToActivate = 1;
            const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
            if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
                thumbsToActivate = swiper.params.slidesPerView;
            }
            if (!swiper.params.thumbs.multipleActiveThumbs) {
                thumbsToActivate = 1;
            }
            thumbsToActivate = Math.floor(thumbsToActivate);
            thumbsSwiper.slides.removeClass(thumbActiveClass);
            if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
                for (let i = 0; i < thumbsToActivate; i += 1) {
                    thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
                }
            } else {
                for (let i = 0; i < thumbsToActivate; i += 1) {
                    thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
                }
            }
        }
        on('beforeInit', () => {
            const {
                thumbs
            } = swiper.params;
            if (!thumbs || !thumbs.swiper) return;
            init();
            update(true);
        });
        on('slideChange update resize observerUpdate', () => {
            update();
        });
        on('setTransition', (_s, duration) => {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            thumbsSwiper.setTransition(duration);
        });
        on('beforeDestroy', () => {
            const thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper || thumbsSwiper.destroyed) return;
            if (swiperCreated) {
                thumbsSwiper.destroy();
            }
        });
        Object.assign(swiper.thumbs, {
            init,
            update
        });
    }
    function freeMode(_ref) {
        let {
            swiper,
            extendParams,
            emit,
            once
        } = _ref;
        extendParams({
            freeMode: {
                enabled: false,
                momentum: true,
                momentumRatio: 1,
                momentumBounce: true,
                momentumBounceRatio: 1,
                momentumVelocityRatio: 1,
                sticky: false,
                minimumVelocity: 0.02
            }
        });
        function onTouchStart() {
            const translate = swiper.getTranslate();
            swiper.setTranslate(translate);
            swiper.setTransition(0);
            swiper.touchEventsData.velocities.length = 0;
            swiper.freeMode.onTouchEnd({
                currentPos: swiper.rtl ? swiper.translate : -swiper.translate
            });
        }
        function onTouchMove() {
            const {
                touchEventsData: data,
                touches
            } = swiper; 
            if (data.velocities.length === 0) {
                data.velocities.push({
                    position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
                    time: data.touchStartTime
                });
            }
            data.velocities.push({
                position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
                time: now()
            });
        }
        function onTouchEnd(_ref2) {
            let {
                currentPos
            } = _ref2;
            const {
                params,
                $wrapperEl,
                rtlTranslate: rtl,
                snapGrid,
                touchEventsData: data
            } = swiper; 
            const touchEndTime = now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (currentPos < -swiper.minTranslate()) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (currentPos > -swiper.maxTranslate()) {
                if (swiper.slides.length < snapGrid.length) {
                    swiper.slideTo(snapGrid.length - 1);
                } else {
                    swiper.slideTo(swiper.slides.length - 1);
                }
                return;
            }
            if (params.freeMode.momentum) {
                if (data.velocities.length > 1) {
                    const lastMoveEvent = data.velocities.pop();
                    const velocityEvent = data.velocities.pop();
                    const distance = lastMoveEvent.position - velocityEvent.position;
                    const time = lastMoveEvent.time - velocityEvent.time;
                    swiper.velocity = distance / time;
                    swiper.velocity /= 2;
                    if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
                        swiper.velocity = 0;
                    } 
                    if (time > 150 || now() - lastMoveEvent.time > 300) {
                        swiper.velocity = 0;
                    }
                } else {
                    swiper.velocity = 0;
                }
                swiper.velocity *= params.freeMode.momentumVelocityRatio;
                data.velocities.length = 0;
                let momentumDuration = 1000 * params.freeMode.momentumRatio;
                const momentumDistance = swiper.velocity * momentumDuration;
                let newPosition = swiper.translate + momentumDistance;
                if (rtl) newPosition = -newPosition;
                let doBounce = false;
                let afterBouncePosition;
                const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
                let needsLoopFix;
                if (newPosition < swiper.maxTranslate()) {
                    if (params.freeMode.momentumBounce) {
                        if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                            newPosition = swiper.maxTranslate() - bounceAmount;
                        }
                        afterBouncePosition = swiper.maxTranslate();
                        doBounce = true;
                        data.allowMomentumBounce = true;
                    } else {
                        newPosition = swiper.maxTranslate();
                    }
                    if (params.loop && params.centeredSlides) needsLoopFix = true;
                } else if (newPosition > swiper.minTranslate()) {
                    if (params.freeMode.momentumBounce) {
                        if (newPosition - swiper.minTranslate() > bounceAmount) {
                            newPosition = swiper.minTranslate() + bounceAmount;
                        }
                        afterBouncePosition = swiper.minTranslate();
                        doBounce = true;
                        data.allowMomentumBounce = true;
                    } else {
                        newPosition = swiper.minTranslate();
                    }
                    if (params.loop && params.centeredSlides) needsLoopFix = true;
                } else if (params.freeMode.sticky) {
                    let nextSlide;
                    for (let j = 0; j < snapGrid.length; j += 1) {
                        if (snapGrid[j] > -newPosition) {
                            nextSlide = j;
                            break;
                        }
                    }
                    if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
                        newPosition = snapGrid[nextSlide];
                    } else {
                        newPosition = snapGrid[nextSlide - 1];
                    }
                    newPosition = -newPosition;
                }
                if (needsLoopFix) {
                    once('transitionEnd', () => {
                        swiper.loopFix();
                    });
                } 
                if (swiper.velocity !== 0) {
                    if (rtl) {
                        momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
                    } else {
                        momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                    }
                    if (params.freeMode.sticky) {
                        const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                        const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                        if (moveDistance < currentSlideSize) {
                            momentumDuration = params.speed;
                        } else if (moveDistance < 2 * currentSlideSize) {
                            momentumDuration = params.speed * 1.5;
                        } else {
                            momentumDuration = params.speed * 2.5;
                        }
                    }
                } else if (params.freeMode.sticky) {
                    swiper.slideToClosest();
                    return;
                }
                if (params.freeMode.momentumBounce && doBounce) {
                    swiper.updateProgress(afterBouncePosition);
                    swiper.setTransition(momentumDuration);
                    swiper.setTranslate(newPosition);
                    swiper.transitionStart(true, swiper.swipeDirection);
                    swiper.animating = true;
                    $wrapperEl.transitionEnd(() => {
                        if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
                        emit('momentumBounce');
                        swiper.setTransition(params.speed);
                        setTimeout(() => {
                            swiper.setTranslate(afterBouncePosition);
                            $wrapperEl.transitionEnd(() => {
                                if (!swiper || swiper.destroyed) return;
                                swiper.transitionEnd();
                            });
                        }, 0);
                    });
                } else if (swiper.velocity) {
                    emit('_freeModeNoMomentumRelease');
                    swiper.updateProgress(newPosition);
                    swiper.setTransition(momentumDuration);
                    swiper.setTranslate(newPosition);
                    swiper.transitionStart(true, swiper.swipeDirection);
                    if (!swiper.animating) {
                        swiper.animating = true;
                        $wrapperEl.transitionEnd(() => {
                            if (!swiper || swiper.destroyed) return;
                            swiper.transitionEnd();
                        });
                    }
                } else {
                    swiper.updateProgress(newPosition);
                }
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            } else if (params.freeMode.sticky) {
                swiper.slideToClosest();
                return;
            } else if (params.freeMode) {
                emit('_freeModeNoMomentumRelease');
            }
            if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
        }
        Object.assign(swiper, {
            freeMode: {
                onTouchStart,
                onTouchMove,
                onTouchEnd
            }
        });
    }
    function Grid(_ref) {
        let {
            swiper,
            extendParams
        } = _ref;
        extendParams({
            grid: {
                rows: 1,
                fill: 'column'
            }
        });
        let slidesNumberEvenToRows;
        let slidesPerRow;
        let numFullColumns;
        const initSlides = slidesLength => {
            const {
                slidesPerView
            } = swiper.params;
            const {
                rows,
                fill
            } = swiper.params.grid;
            slidesPerRow = slidesNumberEvenToRows / rows;
            numFullColumns = Math.floor(slidesLength / rows);
            if (Math.floor(slidesLength / rows) === slidesLength / rows) {
                slidesNumberEvenToRows = slidesLength;
            } else {
                slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
            }
            if (slidesPerView !== 'auto' && fill === 'row') {
                slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
            }
        };
        const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
            const {
                slidesPerGroup,
                spaceBetween
            } = swiper.params;
            const {
                rows,
                fill
            } = swiper.params.grid; 
            let newSlideOrderIndex;
            let column;
            let row;
            if (fill === 'row' && slidesPerGroup > 1) {
                const groupIndex = Math.floor(i / (slidesPerGroup * rows));
                const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
                const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
                row = Math.floor(slideIndexInGroup / columnsInGroup);
                column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
                newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
                slide.css({
                    '-webkit-order': newSlideOrderIndex,
                    order: newSlideOrderIndex
                });
            } else if (fill === 'column') {
                column = Math.floor(i / rows);
                row = i - column * rows;
                if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
                    row += 1;
                    if (row >= rows) {
                        row = 0;
                        column += 1;
                    }
                }
            } else {
                row = Math.floor(i / slidesPerRow);
                column = i - row * slidesPerRow;
            }
            slide.css(getDirectionLabel('margin-top'), row !== 0 ? spaceBetween && `${spaceBetween}px` : '');
        };
        const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
            const {
                spaceBetween,
                centeredSlides,
                roundLengths
            } = swiper.params;
            const {
                rows
            } = swiper.params.grid;
            swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
            swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
            swiper.$wrapperEl.css({
                [getDirectionLabel('width')]: `${swiper.virtualSize + spaceBetween}px`
            });
            if (centeredSlides) {
                snapGrid.splice(0, snapGrid.length);
                const newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid.push(...newSlidesGrid);
            }
        };
        swiper.grid = {
            initSlides,
            updateSlide,
            updateWrapperSize
        };
    }
    function appendSlide(slides) {
        const swiper = this;
        const {
            $wrapperEl,
            params
        } = swiper;
        if (params.loop) {
            swiper.loopDestroy();
        }
        if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) $wrapperEl.append(slides[i]);
            }
        } else {
            $wrapperEl.append(slides);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!params.observer) {
            swiper.update();
        }
    }
    function prependSlide(slides) {
        const swiper = this;
        const {
            params,
            $wrapperEl,
            activeIndex
        } = swiper;
        if (params.loop) {
            swiper.loopDestroy();
        }
        let newActiveIndex = activeIndex + 1;
        if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) $wrapperEl.prepend(slides[i]);
            }
            newActiveIndex = activeIndex + slides.length;
        } else {
            $wrapperEl.prepend(slides);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!params.observer) {
            swiper.update();
        }
        swiper.slideTo(newActiveIndex, 0, false);
    }
    function addSlide(index, slides) {
        const swiper = this;
        const {
            $wrapperEl,
            params,
            activeIndex
        } = swiper;
        let activeIndexBuffer = activeIndex;
        if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
        }
        const baseLength = swiper.slides.length;
        if (index <= 0) {
            swiper.prependSlide(slides);
            return;
        }
        if (index >= baseLength) {
            swiper.appendSlide(slides);
            return;
        }
        let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
        const slidesBuffer = [];
        for (let i = baseLength - 1; i >= index; i -= 1) {
            const currentSlide = swiper.slides.eq(i);
            currentSlide.remove();
            slidesBuffer.unshift(currentSlide);
        }
        if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) $wrapperEl.append(slides[i]);
            }
            newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
        } else {
            $wrapperEl.append(slides);
        }
        for (let i = 0; i < slidesBuffer.length; i += 1) {
            $wrapperEl.append(slidesBuffer[i]);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!params.observer) {
            swiper.update();
        }
        if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
            swiper.slideTo(newActiveIndex, 0, false);
        }
    }
    function removeSlide(slidesIndexes) {
        const swiper = this;
        const {
            params,
            $wrapperEl,
            activeIndex
        } = swiper;
        let activeIndexBuffer = activeIndex;
        if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
        }
        let newActiveIndex = activeIndexBuffer;
        let indexToRemove;
        if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
            for (let i = 0; i < slidesIndexes.length; i += 1) {
                indexToRemove = slidesIndexes[i];
                if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
                if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
            }
            newActiveIndex = Math.max(newActiveIndex, 0);
        } else {
            indexToRemove = slidesIndexes;
            if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
            newActiveIndex = Math.max(newActiveIndex, 0);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!params.observer) {
            swiper.update();
        }
        if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
            swiper.slideTo(newActiveIndex, 0, false);
        }
    }
    function removeAllSlides() {
        const swiper = this;
        const slidesIndexes = [];
        for (let i = 0; i < swiper.slides.length; i += 1) {
            slidesIndexes.push(i);
        }
        swiper.removeSlide(slidesIndexes);
    }
    function Manipulation(_ref) {
        let {
            swiper
        } = _ref;
        Object.assign(swiper, {
            appendSlide: appendSlide.bind(swiper),
            prependSlide: prependSlide.bind(swiper),
            addSlide: addSlide.bind(swiper),
            removeSlide: removeSlide.bind(swiper),
            removeAllSlides: removeAllSlides.bind(swiper)
        });
    }
    function effectInit(params) {
        const {
            effect,
            swiper,
            on,
            setTranslate,
            setTransition,
            overwriteParams,
            perspective,
            recreateShadows,
            getEffectParams
        } = params;
        on('beforeInit', () => {
            if (swiper.params.effect !== effect) return;
            swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
            if (perspective && perspective()) {
                swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
            }
            const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
            Object.assign(swiper.params, overwriteParamsResult);
            Object.assign(swiper.originalParams, overwriteParamsResult);
        });
        on('setTranslate', () => {
            if (swiper.params.effect !== effect) return;
            setTranslate();
        });
        on('setTransition', (_s, duration) => {
            if (swiper.params.effect !== effect) return;
            setTransition(duration);
        });
        on('transitionEnd', () => {
            if (swiper.params.effect !== effect) return;
            if (recreateShadows) {
                if (!getEffectParams || !getEffectParams().slideShadows) return; 
                swiper.slides.each(slideEl => {
                    const $slideEl = swiper.$(slideEl);
                    $slideEl.find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').remove();
                }); 
                recreateShadows();
            }
        });
        let requireUpdateOnVirtual;
        on('virtualUpdate', () => {
            if (swiper.params.effect !== effect) return;
            if (!swiper.slides.length) {
                requireUpdateOnVirtual = true;
            }
            requestAnimationFrame(() => {
                if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
                    setTranslate();
                    requireUpdateOnVirtual = false;
                }
            });
        });
    }
    function effectTarget(effectParams, $slideEl) {
        if (effectParams.transformEl) {
            return $slideEl.find(effectParams.transformEl).css({
                'backface-visibility': 'hidden',
                '-webkit-backface-visibility': 'hidden'
            });
        }
        return $slideEl;
    }
    function effectVirtualTransitionEnd(_ref) {
        let {
            swiper,
            duration,
            transformEl,
            allSlides
        } = _ref;
        const {
            slides,
            activeIndex,
            $wrapperEl
        } = swiper;
        if (swiper.params.virtualTranslate && duration !== 0) {
            let eventTriggered = false;
            let $transitionEndTarget;
            if (allSlides) {
                $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
            } else {
                $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
            }
            $transitionEndTarget.transitionEnd(() => {
                if (eventTriggered) return;
                if (!swiper || swiper.destroyed) return;
                eventTriggered = true;
                swiper.animating = false;
                const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
                for (let i = 0; i < triggerEvents.length; i += 1) {
                    $wrapperEl.trigger(triggerEvents[i]);
                }
            });
        }
    }
    function EffectFade(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            fadeEffect: {
                crossFade: false,
                transformEl: null
            }
        });
        const setTranslate = () => {
            const {
                slides
            } = swiper;
            const params = swiper.params.fadeEffect;
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = swiper.slides.eq(i);
                const offset = $slideEl[0].swiperSlideOffset;
                let tx = -offset;
                if (!swiper.params.virtualTranslate) tx -= swiper.translate;
                let ty = 0;
                if (!swiper.isHorizontal()) {
                    ty = tx;
                    tx = 0;
                }
                const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.css({
                    opacity: slideOpacity
                }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.fadeEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration);
            effectVirtualTransitionEnd({
                swiper,
                duration,
                transformEl,
                allSlides: true
            });
        };
        effectInit({
            effect: 'fade',
            swiper,
            on,
            setTranslate,
            setTransition,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: !swiper.params.cssMode
            })
        });
    }
    function EffectCube(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            cubeEffect: {
                slideShadows: true,
                shadow: true,
                shadowOffset: 20,
                shadowScale: 0.94
            }
        });
        const createSlideShadows = ($slideEl, progress, isHorizontal) => {
            let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
            let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
            if (shadowBefore.length === 0) {
                shadowBefore = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
                $slideEl.append(shadowBefore);
            }
            if (shadowAfter.length === 0) {
                shadowAfter = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
                $slideEl.append(shadowAfter);
            }
            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
        };
        const recreateShadows = () => {
            const isHorizontal = swiper.isHorizontal();
            swiper.slides.each(slideEl => {
                const progress = Math.max(Math.min(slideEl.progress, 1), -1);
                createSlideShadows($(slideEl), progress, isHorizontal);
            });
        };
        const setTranslate = () => {
            const {
                $el,
                $wrapperEl,
                slides,
                width: swiperWidth,
                height: swiperHeight,
                rtlTranslate: rtl,
                size: swiperSize,
                browser
            } = swiper;
            const params = swiper.params.cubeEffect;
            const isHorizontal = swiper.isHorizontal();
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let wrapperRotate = 0;
            let $cubeShadowEl;
            if (params.shadow) {
                if (isHorizontal) {
                    $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
                    if ($cubeShadowEl.length === 0) {
                        $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                        $wrapperEl.append($cubeShadowEl);
                    }
                    $cubeShadowEl.css({
                        height: `${swiperWidth}px`
                    });
                } else {
                    $cubeShadowEl = $el.find('.swiper-cube-shadow');
                    if ($cubeShadowEl.length === 0) {
                        $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                        $el.append($cubeShadowEl);
                    }
                }
            }
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                let slideIndex = i;
                if (isVirtual) {
                    slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
                }
                let slideAngle = slideIndex * 90;
                let round = Math.floor(slideAngle / 360);
                if (rtl) {
                    slideAngle = -slideAngle;
                    round = Math.floor(-slideAngle / 360);
                }
                const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                let tx = 0;
                let ty = 0;
                let tz = 0;
                if (slideIndex % 4 === 0) {
                    tx = -round * 4 * swiperSize;
                    tz = 0;
                } else if ((slideIndex - 1) % 4 === 0) {
                    tx = 0;
                    tz = -round * 4 * swiperSize;
                } else if ((slideIndex - 2) % 4 === 0) {
                    tx = swiperSize + round * 4 * swiperSize;
                    tz = swiperSize;
                } else if ((slideIndex - 3) % 4 === 0) {
                    tx = -swiperSize;
                    tz = 3 * swiperSize + swiperSize * 4 * round;
                }
                if (rtl) {
                    tx = -tx;
                }
                if (!isHorizontal) {
                    ty = tx;
                    tx = 0;
                }
                const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
                if (progress <= 1 && progress > -1) {
                    wrapperRotate = slideIndex * 90 + progress * 90;
                    if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
                }
                $slideEl.transform(transform);
                if (params.slideShadows) {
                    createSlideShadows($slideEl, progress, isHorizontal);
                }
            }
            $wrapperEl.css({
                '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
                'transform-origin': `50% 50% -${swiperSize / 2}px`
            });
            if (params.shadow) {
                if (isHorizontal) {
                    $cubeShadowEl.transform(`translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
                } else {
                    const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                    const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                    const scale1 = params.shadowScale;
                    const scale2 = params.shadowScale / multiplier;
                    const offset = params.shadowOffset;
                    $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
                }
            }
            const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
            $wrapperEl.transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
            $wrapperEl[0].style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);
        };
        const setTransition = duration => {
            const {
                $el,
                slides
            } = swiper;
            slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
            if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
                $el.find('.swiper-cube-shadow').transition(duration);
            }
        };
        effectInit({
            effect: 'cube',
            swiper,
            on,
            setTranslate,
            setTransition,
            recreateShadows,
            getEffectParams: () => swiper.params.cubeEffect,
            perspective: () => true,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: false,
                virtualTranslate: true
            })
        });
    }
    function createShadow(params, $slideEl, side) {
        const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;
        const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
        let $shadowEl = $shadowContainer.children(`.${shadowClass}`);
        if (!$shadowEl.length) {
            $shadowEl = $(`<div class="swiper-slide-shadow${side ? `-${side}` : ''}"></div>`);
            $shadowContainer.append($shadowEl);
        }
        return $shadowEl;
    }
    function EffectFlip(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            flipEffect: {
                slideShadows: true,
                limitRotation: true,
                transformEl: null
            }
        });
        const createSlideShadows = ($slideEl, progress, params) => {
            let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
            let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
            if (shadowBefore.length === 0) {
                shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');
            }
            if (shadowAfter.length === 0) {
                shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
            }
            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
        };
        const recreateShadows = () => {
            const params = swiper.params.flipEffect;
            swiper.slides.each(slideEl => {
                const $slideEl = $(slideEl);
                let progress = $slideEl[0].progress;
                if (swiper.params.flipEffect.limitRotation) {
                    progress = Math.max(Math.min(slideEl.progress, 1), -1);
                }
                createSlideShadows($slideEl, progress, params);
            });
        };
        const setTranslate = () => {
            const {
                slides,
                rtlTranslate: rtl
            } = swiper;
            const params = swiper.params.flipEffect;
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                let progress = $slideEl[0].progress;
                if (swiper.params.flipEffect.limitRotation) {
                    progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                }
                const offset = $slideEl[0].swiperSlideOffset;
                const rotate = -180 * progress;
                let rotateY = rotate;
                let rotateX = 0;
                let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
                let ty = 0;
                if (!swiper.isHorizontal()) {
                    ty = tx;
                    tx = 0;
                    rotateX = -rotateY;
                    rotateY = 0;
                } else if (rtl) {
                    rotateY = -rotateY;
                }
                $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
                if (params.slideShadows) {
                    createSlideShadows($slideEl, progress, params);
                }
                const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.transform(transform);
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.flipEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
            effectVirtualTransitionEnd({
                swiper,
                duration,
                transformEl
            });
        };
        effectInit({
            effect: 'flip',
            swiper,
            on,
            setTranslate,
            setTransition,
            recreateShadows,
            getEffectParams: () => swiper.params.flipEffect,
            perspective: () => true,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: !swiper.params.cssMode
            })
        });
    }
    function EffectCoverflow(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                scale: 1,
                modifier: 1,
                slideShadows: true,
                transformEl: null
            }
        });
        const setTranslate = () => {
            const {
                width: swiperWidth,
                height: swiperHeight,
                slides,
                slidesSizesGrid
            } = swiper;
            const params = swiper.params.coverflowEffect;
            const isHorizontal = swiper.isHorizontal();
            const transform = swiper.translate;
            const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
            const rotate = isHorizontal ? params.rotate : -params.rotate;
            const translate = params.depth; 
            for (let i = 0, length = slides.length; i < length; i += 1) {
                const $slideEl = slides.eq(i);
                const slideSize = slidesSizesGrid[i];
                const slideOffset = $slideEl[0].swiperSlideOffset;
                const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
                const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;
                let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
                let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; 
                let translateZ = -translate * Math.abs(offsetMultiplier);
                let stretch = params.stretch; 
                if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
                    stretch = parseFloat(params.stretch) / 100 * slideSize;
                }
                let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
                let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
                let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); 
                if (Math.abs(translateX) < 0.001) translateX = 0;
                if (Math.abs(translateY) < 0.001) translateY = 0;
                if (Math.abs(translateZ) < 0.001) translateZ = 0;
                if (Math.abs(rotateY) < 0.001) rotateY = 0;
                if (Math.abs(rotateX) < 0.001) rotateX = 0;
                if (Math.abs(scale) < 0.001) scale = 0;
                const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.transform(slideTransform);
                $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                if (params.slideShadows) {
                    let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
                    let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
                    if ($shadowBeforeEl.length === 0) {
                        $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? 'left' : 'top');
                    }
                    if ($shadowAfterEl.length === 0) {
                        $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? 'right' : 'bottom');
                    }
                    if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                    if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
                }
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.coverflowEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
        };
        effectInit({
            effect: 'coverflow',
            swiper,
            on,
            setTranslate,
            setTransition,
            perspective: () => true,
            overwriteParams: () => ({
                watchSlidesProgress: true
            })
        });
    }
    function EffectCreative(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            creativeEffect: {
                transformEl: null,
                limitProgress: 1,
                shadowPerProgress: false,
                progressMultiplier: 1,
                perspective: true,
                prev: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                },
                next: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                }
            }
        });
        const getTranslateValue = value => {
            if (typeof value === 'string') return value;
            return `${value}px`;
        };
        const setTranslate = () => {
            const {
                slides,
                $wrapperEl,
                slidesSizesGrid
            } = swiper;
            const params = swiper.params.creativeEffect;
            const {
                progressMultiplier: multiplier
            } = params;
            const isCenteredSlides = swiper.params.centeredSlides;
            if (isCenteredSlides) {
                const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
                $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);
            }
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                const slideProgress = $slideEl[0].progress;
                const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
                let originalProgress = progress;
                if (!isCenteredSlides) {
                    originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);
                }
                const offset = $slideEl[0].swiperSlideOffset;
                const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
                const r = [0, 0, 0];
                let custom = false;
                if (!swiper.isHorizontal()) {
                    t[1] = t[0];
                    t[0] = 0;
                }
                let data = {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    scale: 1,
                    opacity: 1
                };
                if (progress < 0) {
                    data = params.next;
                    custom = true;
                } else if (progress > 0) {
                    data = params.prev;
                    custom = true;
                } 
                t.forEach((value, index) => {
                    t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
                }); 
                r.forEach((value, index) => {
                    r[index] = data.rotate[index] * Math.abs(progress * multiplier);
                });
                $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
                const translateString = t.join(', ');
                const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
                const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
                const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
                const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`; 
                if (custom && data.shadow || !custom) {
                    let $shadowEl = $slideEl.children('.swiper-slide-shadow');
                    if ($shadowEl.length === 0 && data.shadow) {
                        $shadowEl = createShadow(params, $slideEl);
                    }
                    if ($shadowEl.length) {
                        const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
                        $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
                    }
                }
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.transform(transform).css({
                    opacity: opacityString
                });
                if (data.origin) {
                    $targetEl.css('transform-origin', data.origin);
                }
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.creativeEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
            effectVirtualTransitionEnd({
                swiper,
                duration,
                transformEl,
                allSlides: true
            });
        };
        effectInit({
            effect: 'creative',
            swiper,
            on,
            setTranslate,
            setTransition,
            perspective: () => swiper.params.creativeEffect.perspective,
            overwriteParams: () => ({
                watchSlidesProgress: true,
                virtualTranslate: !swiper.params.cssMode
            })
        });
    }
    function EffectCards(_ref) {
        let {
            swiper,
            extendParams,
            on
        } = _ref;
        extendParams({
            cardsEffect: {
                slideShadows: true,
                transformEl: null,
                rotate: true
            }
        });
        const setTranslate = () => {
            const {
                slides,
                activeIndex
            } = swiper;
            const params = swiper.params.cardsEffect;
            const {
                startTranslate,
                isTouched
            } = swiper.touchEventsData;
            const currentTranslate = swiper.translate;
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                const slideProgress = $slideEl[0].progress;
                const progress = Math.min(Math.max(slideProgress, -4), 4);
                let offset = $slideEl[0].swiperSlideOffset;
                if (swiper.params.centeredSlides && !swiper.params.cssMode) {
                    swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);
                }
                if (swiper.params.centeredSlides && swiper.params.cssMode) {
                    offset -= slides[0].swiperSlideOffset;
                }
                let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
                let tY = 0;
                const tZ = -100 * Math.abs(progress);
                let scale = 1;
                let rotate = -2 * progress;
                let tXAdd = 8 - Math.abs(progress) * 0.75;
                const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
                const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
                const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
                if (isSwipeToNext || isSwipeToPrev) {
                    const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
                    rotate += -28 * progress * subProgress;
                    scale += -0.5 * subProgress;
                    tXAdd += 96 * subProgress;
                    tY = `${-25 * subProgress * Math.abs(progress)}%`;
                }
                if (progress < 0) {
                    tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;
                } else if (progress > 0) {
                    tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;
                } else {
                    tX = `${tX}px`;
                }
                if (!swiper.isHorizontal()) {
                    const prevY = tY;
                    tY = tX;
                    tX = prevY;
                }
                const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
                const transform = `
          translate3d(${tX}, ${tY}, ${tZ}px)
          rotateZ(${params.rotate ? rotate : 0}deg)
          scale(${scaleString})
        `;
                if (params.slideShadows) {
                    let $shadowEl = $slideEl.find('.swiper-slide-shadow');
                    if ($shadowEl.length === 0) {
                        $shadowEl = createShadow(params, $slideEl);
                    }
                    if ($shadowEl.length) $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
                }
                $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
                const $targetEl = effectTarget(params, $slideEl);
                $targetEl.transform(transform);
            }
        };
        const setTransition = duration => {
            const {
                transformEl
            } = swiper.params.cardsEffect;
            const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
            $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
            effectVirtualTransitionEnd({
                swiper,
                duration,
                transformEl
            });
        };
        effectInit({
            effect: 'cards',
            swiper,
            on,
            setTranslate,
            setTransition,
            perspective: () => true,
            overwriteParams: () => ({
                watchSlidesProgress: true,
                virtualTranslate: !swiper.params.cssMode
            })
        });
    }
    const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Lazy, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
    Swiper.use(modules);
    return Swiper;
}));
/*!
 * 设置多久后过期时间，返回过期时间（国标时间），
 */
const axExpires = (type = 'd', expires = 365) => {
    let dateExp;
    if (axIsDate(expires)) {
        dateExp = new Date(expires).toUTCString()
    } else {
        let now = new Date();
        if (type == 'second' || type == 's') {
            now.setSeconds(now.getSeconds() + ~~expires);
            dateExp = now.toUTCString();
        } else if (type == 'minute' || type == 'm') {
            now.setMinutes(now.getMinutes() + ~~expires);
            dateExp = now.toUTCString();
        } else if (type == 'hour' || type == 'h') {
            now.setHours(now.getHours() + ~~expires);
            dateExp = now.toUTCString();
        } else {
            now.setDate(now.getDate() + ~~expires);
            dateExp = now.toUTCString();
        }
    }
    return dateExp;
}
/*!
 * 定义cookie方法
 * 支持axCookie.set、axCookie.get、axCookie.del三个方法
 * set方法支持options参数，支持追加path、domain、secure和sameSite属性
 * 默认过期时间是365天
 */
const axCookie = {
    set: function (name, value, options = { type: 'd', expires: 365 }) {
        if (!name) {
            console.error('The name of cookie can not be empty!');
            return false;
        }
        let opt = Object.assign({}, options),
            string = opt.path ? ';path=' + opt.path : '';
        string += opt.domain ? ';domain=' + opt.domain : '';
        string += opt.secure ? ';secure=' + opt.secure : '';
        string += opt.sameSite ? ';sameSite=' + opt.sameSite : '';
        opt.expires = axExpires(options.type, options.expires);
        if ((options.expires < 0 || value === null) && this.get(name)) {
            this.del(name);
        } else {
            document.cookie = name + "=" + encodeURIComponent(value) + ";expires=" + opt.expires + string;
        }
        return this;
    },
    get: function (name) {
        let cookieArr = document.cookie.replace(/;\s*/, ';').split(';');
        let value = '';
        for (let i = 0; i < cookieArr.length; i++) {
            let k = cookieArr[i].split('=')[0],
                v = cookieArr[i].split('=')[1];
            if (k == name) {
                value = v;
                break;
            }
        }
        if (value) {
            return decodeURIComponent(value);
        } else {
            return false;
        }
    },
    remove: function (name) {
        document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT";
        return this;
    }
}
/*!
 * 定义localStorage本地存储
 * 支持set、get、del、clear、key五个方法
 * set方法支持options参数，type和expires
 * 默认过期时间是0，即永不过期
 */
const axLocalStorage = {
    set: function (key, value = '', options = { type: 'd', expires: 0, cover: true }) {
        if (typeof key !== 'string' && !key) {
            return false;
        }
        let newValue = axClone(value),
            type = axType(value),
            filterProps = (obj) => {
                Object.keys(obj).forEach(k => {
                    let val = obj[k];
                    (axType(val) === 'Array' || axType(val) === 'Object') && filterProps(val);
                    (axType(val).includes('HTML') || axType(val) === 'Function') && delete obj[k];
                });
                return obj;
            };
        if ((type === 'Array' || type === 'Object') && !axIsEmpty(newValue)) {
            filterProps(newValue);
        }
        let expires = options.expires !== 0 ? axExpires(options.type, options.expires) : 0,
            oldValue = axLocalStorage.get(key),
            valueExp = {
                data: (!options.cover && axLocalStorage.get(key)) ? axExtend(oldValue, newValue) : newValue,
                expires: expires,
            };
        if ((options.expires < 0 || newValue === null) && this.get(key)) {
            this.del(key);
        } else {
            window.localStorage.setItem(key, JSON.stringify(valueExp));
        }
        return this;
    },
    get: function (key) {
        if (axIsEmpty(key)) {
            return false;
        }
        let now = new Date().toUTCString(),
            valueExp = JSON.parse(window.localStorage.getItem(key));
        if (valueExp) {
            if (valueExp.expires === 0 || now <= valueExp.expires) {
                return valueExp.data;
            } else {
                window.localStorage.removeItem(key);
                return null;
            }
        } else {
            return null;
        }
    },
    remove: function (key) {
        if (axIsEmpty(key)) {
            return false;
        }
        let arr = [];
        if (Array.isArray(key)) {
            arr = key;
        } else {
            arr.push(key);
        }
        arr.forEach(k => {
            window.localStorage.removeItem(k);
        });
        return this;
    },
    key: function (num) {
        if (typeof num !== 'number') {
            return false;
        }
        return window.localStorage.key(num);
    },
    clear: function () {
        window.localStorage.clear();
        return this;
    }
}
/*!
 * 插件：全局实例管理；使用方法：new axInstance('#id',{参数})
 * 支持axInstance.push、axInstance.destroy、axInstance.destroyAll、axInstance.clear等个方法
 */
class AXINSTANCE {
    constructor() {
        this.data = [];
        this.destroyFun = (item) => {
            if (!item) {
                return false;
            }
            if ((!item.instance.hasOwnProperty('destroyed') || !item.instance.destroyed) && item.instance.__proto__.destroy) {
                item.instance.destroy();
                item.log = `destroy(${new Date().toLocaleString()})`;
            }
        }
        this.initFun = (item) => {
            if (!item) {
                return false;
            }
            if ((!item.instance.hasOwnProperty('destroyed') || item.instance.destroyed) && item.instance.__proto__.init) {
                item.instance.init();
                item.log = `init(${new Date().toLocaleString()})`;
            }
        }
    }
    push(instance, name, type) {
        if (!instance) {
            return false;
        }
        let obj = { name: name, instance: instance, type: type || '', log: `push(${new Date().toLocaleString()})` }
        if (!this.data.some(i => i.instance === instance)) {
            this.data.push(obj);
        }
    }
    find(name, type, destroyed = false) {
        if (!name) {
            return false;
        }
        let item;
        if (type) {
            item = this.data.find(i => {
                if (i.instance.hasOwnProperty('destroyed')) {
                    return i.name === name && i.type === type && i.instance.destroyed === destroyed;
                } else {
                    return i.name === name && i.type === type;
                }
            });
        } else {
            item = this.data.find(i => {
                if (i.instance.hasOwnProperty('destroyed')) {
                    return i.name === name && i.instance.destroyed === destroyed;
                } else {
                    return i.name === name;
                }
            });
        }
        return item ? item.instance : item;
    }
    findAll(type, destroyed = false) {
        let items = [];
        if (!type) {
            if (i.instance.hasOwnProperty('destroyed')) {
                items = this.data.filter(i => i.instance.destroyed === destroyed);
            } else {
                items = this.data;
            }
        } else {
            items = this.data.filter(i => {
                if (i.instance.hasOwnProperty('destroyed')) {
                    return i.type === type && i.instance.destroyed === destroyed;
                } else {
                    return i.type === type;
                }
            });
        }
        return items.length > 0 ? items.map(i => i.instance) : items;
    }
    destroy(name, type, callback) {
        if (!name) {
            return false;
        }
        let item;
        if (type) {
            item = this.data.find(i => i.name === name && i.type === type);
        } else {
            item = this.data.find(i => i.name === name);
        }
        this.destroyFun(item);
        callback && callback(item);
    }
    destroyAll(type, callback) {
        if (!type) {
            this.data.forEach(i => {
                this.destroyFun(i);
            });
            callback && callback(this.data);
            return false;
        } else {
            let items = this.data.filter(i => i.type === type);
            items.forEach(i => {
                this.destroyFun(i);
            });
            callback && callback(items);
        }
    }
    clear(callback) {
        this.data.forEach(i => {
            this.destroyFun(i);
        });
        this.data.length = 0
        callback && callback();
    }
    init(name, type, callback) {
        if (!name) {
            return false;
        }
        let item;
        if (type) {
            item = this.data.find(i => i.name === name && i.type === type);
        } else {
            item = this.data.find(i => i.name === name);
        }
        this.initFun(item);
        callback && callback(item);
    }
    initAll(type, callback) {
        if (!type) {
            this.data.forEach(i => {
                this.initFun(i);
            });
            callback && callback(this.data);
            return false;
        } else {
            let items = this.data.filter(i => i.type === type);
            items.forEach(i => {
                this.initFun(i);
            });
            callback && callback(items);
        }
    }
}
const axInstance = new AXINSTANCE();
/*!
* 插件：告示；使用方法：new axAlert('#id',{参数})
*/
class axAlert {
    constructor(elem, options) {
        if (!elem) {
            return false;
        }
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            insName: '',
            caption: '',
            content: '',
            theme: 'warning',
            borderless: false,
            square: false,
            className: '',
            closable: false,
            style: 'simple',
            icon: '',
            iconShow: true,
            notable: false,
            display: '',
            onInit: '',
            onShow: '',
            onHide: '',
            onUpdate: '',
            onUpdateContent: '',
            onClear: '',
            onDestroy: '',
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.init();
    }
    init() {
        this.shown = true;
        let subset = axInstance.data.find(i => i.instance === this);
        if (!subset) {
            axInstance.push(this, this.options.insName, 'alert');
        }
        this.destroyed = false;
        this.render();
        this.setAttribute();
        if (this.close) {
            this.close.onclick = () => {
                this.hide();
            }
        }
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    render() {
        if (!this.targetDom.innerHTML.trim()) {
            let html = '';
            if (this.options.style == 'simple' || !this.options.style) {
                this.content = this.targetDom.innerHTML.trim() ? this.targetDom.innerHTML : this.options.content;
                if (this.options.icon && this.options.iconShow) {
                    html = `<i class="ax-iconfont ${this.options.icon}" icon></i><span content>${this.content}</span>`;
                } else {
                    html = `<span content>${this.content}</span>${this.options.closable ? '<i close></i>' : ''}`;
                }
            } else if (this.options.style == 'complex') {
                if (!this.targetDom.innerHTML.trim()) {
                    html = `${this.options.icon && this.options.iconShow ? '<i class="ax-iconfont ' + this.options.icon + '" icon></i>' : ''}
                    <div wrapper>
                        ${this.options.caption ? '<div caption>' + this.options.caption + '</div>' : ''}
                        <div content>${this.options.content}</div>
                    </div>
                    ${this.options.closable ? '<i close></i>' : ''}
                    `;
                }
            }
            this.targetDom.innerHTML = html;
        }
        this.close = this.targetDom.querySelector('[close]');
        this.icon = this.targetDom.querySelector('[icon]');
        this.wrapper = this.targetDom.querySelector('[wrapper]');
        this.caption = this.targetDom.querySelector('[caption]');
        this.content = this.targetDom.querySelector('[content]');
    }
    setAttribute() {
        !this.targetDom.classList.contains('ax-alert') ? this.targetDom.classList.add('ax-alert') : null;
        axClass.add(this.targetDom, this.options.className);
        this.options.theme ? this.targetDom.setAttribute('theme', this.options.theme) : null;
        this.options.borderless ? this.targetDom.setAttribute('borderless', '') : null;
        this.options.notable && this.options.style === 'complex' ? this.targetDom.setAttribute('notable', '') : null;
        this.options.square ? this.targetDom.setAttribute('square', '') : null;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options = axExtend(this.options, setting);
        this.targetDom.removeAttribute('class');
        this.targetDom.removeAttribute('theme');
        this.targetDom.removeAttribute('borderless');
        this.targetDom.removeAttribute('square');
        this.targetDom.removeAttribute('notable');
        this.targetDom.innerHTML = '';
        this.init();
        callback && callback.call(this);
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        return this;
    }
    updateContent(html, callback) {
        if (this.destroyed) {
            return this;
        }
        this.content.innerHTML = html;
        callback && callback.call(this);
        this.options.onUpdateContent && this.options.onUpdateContent.call(this);
        'updateContent' in this.handlers ? this.emit('updateContent', '') : null;
        return this;
    }
    show(callback) {
        if (this.destroyed || this.shown) {
            return this;
        }
        if (this.options.display) {
            this.targetDom.style.display = this.options.display;
        } else {
            this.targetDom.style.cssText = this.targetDom.style.cssText.replace('display: none;', '');
        }
        this.shown = true;
        this.options.onShow && this.options.onShow.call(this);
        'show' in this.handlers ? this.emit('show', '') : null;
        callback && callback.call(this);
        return this;
    }
    hide(callback) {
        if (this.destroyed || !this.shown) {
            return this;
        }
        this.targetDom.style.display = 'none';
        this.shown = false;
        this.options.onHide && this.options.onHide.call(this);
        'hide' in this.handlers ? this.emit('hide', '') : null;
        callback && callback.call(this);
        return this;
    }
    clear(callback) {
        if (this.destroyed) {
            return this;
        }
        this.targetDom.removeAttribute('class');
        this.targetDom.removeAttribute('theme');
        this.targetDom.removeAttribute('borderless');
        this.targetDom.removeAttribute('square');
        this.targetDom.removeAttribute('notable');
        this.targetDom.innerHTML = '';
        callback && callback.call(this);
        this.options.onClear && this.options.onClear.call(this);
        'clear' in this.handlers ? this.emit('clear', '') : null;
        return this;
    }
    destroy(callback) {
        this.close ? this.close.onclick = null : null;
        this.destroyed = true;
        this.options.onDestroy && this.options.onDestroy.call(this);
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axAlert]').forEach(element => {
        new axAlert(element);
    });
})();
/*!
* 插件：Tags标签；使用方法：new axTags('#id',{参数})
*/
class axTags {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        if (!this.targetDom) {
            return false;
        }
        this.options = axExtend({
            insName: '',
            content: '',
            theme: '',
            borderless: false,
            compact: false,
            corner: '',
            className: '',
            closeNode: 'i',
            closable: false,
            separator: ',',
            input: '',
            onInit: '',
            onAdd: '',
            onRemove: '',
            onUpdate: '',
            onUClear: '',
            onDestroy: '',
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.indexMax = 0;
        this.inputEdit = (e) => {
            let value = this.inputDom.value,
                selected = this.content.find(k => k.dom.hasAttribute('selected'));
            if (value) {
                if (e.code === 'Enter') {
                    this.add(this.inputDom.value.trim());
                    this.inputDom.value = '';
                }
                selected ? selected.dom.removeAttribute('selected') : null;
            } else {
                if (e.code === 'Backspace' && this.content.length > 0) {
                    let end = this.content.slice(-1)[0];
                    if (end.dom.hasAttribute('selected')) {
                        end.dom.remove();
                        this.content = this.content.slice(0, -1);
                    } else {
                        end.dom.setAttribute('selected', '');
                    }
                } else {
                    selected ? selected.dom.removeAttribute('selected') : null;
                }
            }
        }
        this.init();
    }
    init() {
        let subset = axInstance.data.find(i => i.instance === this);
        if (!subset) {
            axInstance.push(this, this.options.insName, 'tags');
        }
        this.destroyed = false;
        if (this.targetDom.innerHTML.trim()) {
            this.targetDom.innerHTML = '';
            this.indexMax = 0;
        }
        this.content = this.getSource(this.options.content);
        this.render(this.content);
        this.observeInput();
        this.setAttribute();
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    getSource(obj) {
        let result = [];
        if (Array.isArray(obj)) {
            if (typeof obj[0] === 'string') {
                result = obj.map(k => {
                    return { value: k, theme: '' };
                });
            } else {
                result = obj;
            }
        } else if (typeof obj === 'object') {
            result = [obj];
        } else if (typeof obj === 'string') {
            let arr = obj.trim().split(this.options.separator);
            result = arr.map(k => {
                return { value: k, theme: '' };
            });
        }
        result = result.filter(Boolean);
        result.forEach((k, i) => {
            !k.hasOwnProperty('index') ? k.index = this.indexMax + i : null;
            !k.hasOwnProperty('theme') ? k.theme = '' : null;
        });
        this.indexMax += result.length;
        return result;
    }
    render(content) {
        if (axIsEmpty(content)) {
            return false;
        }
        let fragment = document.createDocumentFragment();
        content.forEach(i => {
            let tagDom = this.createTag(i);
            i.dom = tagDom;
            fragment.appendChild(tagDom);
        });
        this.targetDom.appendChild(fragment);
    }
    createTag(obj) {
        let tagDom = axAddElem('span', { class: 'ax-tag' }, obj.value),
            tagClose = axAddElem(this.options.closeNode, { close: '' });
        if (!this.options.theme && obj.theme) {
            tagDom.setAttribute('theme', obj.theme)
        }
        if (this.options.closable) {
            tagDom.appendChild(tagClose);
            tagClose.onclick = () => {
                this.remove(tagDom);
            }
        }
        obj.dom = tagDom;
        return tagDom;
    }
    getTag(obj) {
        if (axIsEmpty(obj)) {
            return false;
        }
        let filter, tag,
            type = axType(obj);
        if (type === 'Object') {
            let str = '';
            obj.index || obj.index === 0 ? str += 'item.index === obj.index' : null;
            obj.value ? str += '&& item.index === obj.index' : null;
            obj.dom ? str += '&& item.dom === obj.dom' : null;
            str.startsWith('&&') ? str = 'true ' + str : null;
            filter = new Function(`return ${this.content}.filter(item =>${str})`)();
            filter > 0 ? tag = filter[0] : null;
        } else if (type.includes('HTML')) {
            tag = this.content.find(k => k.dom === obj);
        } else if (type === 'String') {
            tag = this.content.find(k => k.value === obj);
        } else if (type === 'Number') {
            tag = this.content.find(k => k.index === index);
        }
        return tag;
    }
    setAttribute() {
        !this.targetDom.classList.contains('ax-tags') ? this.targetDom.classList.add('ax-tags') : null;
        axClass.add(this.targetDom, this.options.className);
        this.options.theme ? this.targetDom.setAttribute('theme', this.options.theme) : null;
        this.options.borderless ? this.targetDom.setAttribute('borderless', '') : null;
        this.options.compact ? this.targetDom.setAttribute('compact', '') : null;
        this.options.corner ? this.targetDom.setAttribute('corner', this.options.corner) : null;
    }
    observeInput() {
        if (!this.options.input || this.destroyed) {
            return false;
        }
        this.inputDom = axIdToDom(this.options.input);
        if (!this.inputDom) {
            return false;
        }
        this.inputDom.addEventListener('keyup', this.inputEdit, false);
    }
    update(setting, callback) {
        if (axIsEmpty(setting) || this.destroyed) {
            return this;
        }
        this.options = axExtend(this.options, setting);
        this.targetDom.innerHTML = '';
        this.init();
        callback && callback.call(this);
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        return this;
    }
    add(obj, callback) {
        if (axIsEmpty(obj) || this.destroyed) {
            return this;
        }
        let arr = this.getSource(obj);
        this.render(arr);
        this.content.push(...arr);
        this.options.onAdd && this.options.onAdd.call(this, arr);
        'add' in this.handlers ? this.emit('add', arr) : null;
        callback && callback.call(this, arr);
        return this;
    }
    remove(obj, callback) {
        if (axIsEmpty(obj) || this.destroyed) {
            return this;
        }
        let tags = [],
            type = axType(obj);
        if (type === 'Array' && obj.length > 0) {
            obj.forEach(k => {
                let item = this.getTag(k);
                item ? tags.push(item) : null
            });
        } else if (type === 'String') {
            let arr = obj.split(this.options.separator);
            tags = this.content.filter(k => arr.includes(k.value));
        } else {
            let item = this.getTag(obj);
            item ? tags.push(item) : null
        }
        tags.forEach(k => {
            k.dom.remove();
        });
        let values = tags.map(k => {
            return k.value;
        });
        this.content = this.content.filter(k => !values.includes(k.value));
        this.options.onRemove && this.options.onRemove.call(this, tags);
        'remove' in this.handlers ? this.emit('remove', tags) : null;
        callback && callback.call(this, tags);
        return this;
    }
    clear(callback) {
        if (this.destroyed) {
            return this;
        }
        this.content = [];
        this.index = 0;
        this.targetDom.innerHTML = '';
        this.options.onClear && this.options.onClear.call(this);
        'clear' in this.handlers ? this.emit('clear', '') : null;
        callback && callback.call(this);
        return this;
    }
    destroy(callback) {
        this.content.forEach(K => {
            let close = K.dom.querySelector('[close]');
            close ? close.onclick = null : null;
        });
        this.inputDom ? this.inputDom.removeEventListener('keyup', this.inputEdit, false) : null;
        this.destroyed = true;
        this.options.onDestroy && this.options.onDestroy.call(this);
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axTags]').forEach(element => {
        new axTags(element);
    });
})(); 
/*!
 * 插件：表单校验；使用方法：new axValid('#id',{参数})
 */
const axValids = [];
class axValid {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        if (!this.targetDom.getAttribute('name')) {
            console.error('The element to be verified must have a name attribute!');
            return false;
        }
        this.options = axExtend({
            label: '',
            mode: 'newline', 
            url: '', 
            iconShow: true, 
            type: '', 
            label: '', 
            parent: '',
            error: '', 
            success: '通过验证！', 
            rule: {}, 
            number: '', 
            max: '', 
            min: '', 
            length: '', 
            maxLength: '', 
            minLength: '', 
            include: [], 
            exclude: [], 
            date: '', 
            earliest: '', 
            latest: '', 
            compare: '', 
            compareLabel: '', 
            least: 1, 
            most: 2, 
            separator: '',
            format: '', 
            inputSuccess: 'ax-check-primary', 
            inputError: 'ax-check-danger', 
            boxSuccess: 'ax-color-primary', 
            boxError: 'ax-color-danger', 
            chars: '~!@#', 
            charsShow: false, 
            trigger: 'blur', 
            ajaxType: 'post',
            onTrigger: '', 
            onChange: '',
            onInit: '',
        }, options, this.targetDom,'axValid');
        if (this.options.parent) {
            this.parent = axIdToDom(this.options.parent);
        } else {
            this.parent = this.targetDom.closest('form') ? this.targetDom.closest('form') : document;
        }
        if (this.options.compare) {
            if (typeof this.options.compare == 'string') {
                this.compare = this.parent.querySelector('[name=' + this.options.compare + ']');
            } else {
                this.compare = axIdToDom(this.options.compare);
            }
        }
        if (this.options.compareLabel) {
            this.compareLabel = this.options.compareLabel;
        } else {
            if (this.compare && this.compare.getAttribute('data-label')) {
                this.compareLabel = this.compare.getAttribute('data-label');
            }
        }
        this.handlers = {};
        this.strong = 0;
        this.msgBox = axAddElem('div', { 'valid': '' });
        this.value = null;
        this.label = this.options.label;
        this.name = this.targetDom.getAttribute('name');
        this.type = this.targetDom.getAttribute('type') ? this.targetDom.getAttribute('type') : this.targetDom.type;
        this.text = '';
        this.verified = null;
        this.verifieds = [];
        this.getRules();
        this.strongParse = this.parseFormat();
        this.checks = {
            /**
             * 为空校验，不填则直接返回结果
             */
            required: function (value) {
                if (value) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label ? this.label + '是必填项！' : '这是必填项！' };
                }
            },
            /**
             * 特定字符串校验
             */
            email: function (value) {
                let pattern = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/;
                return this.doTest(pattern, value, '请填写正确的邮箱！');
            },
            telephone: function (value) {
                let pattern = /^[1][3456789][0-9]{9}$/;
                return this.doTest(pattern, value, '请填写11位手机号！');
            },
            landline: function (value) {
                let pattern = /^([0-9]{3,4}-)?[0-9]{7,8}$/;
                return this.doTest(pattern, value, '请填写正确的座机号码！');
            },
            ip: function (value) {
                let pattern = /^\d+\.\d+\.\d+\.\d+$/;
                return this.doTest(pattern, value, '请填写正确的IP地址！');
            },
            plate: function (value) {
                let pattern = '';
                if (value.length == 8) {
                    pattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}(([0-9]{5}[DF]$)|([DF][A-HJ-NP-Z0-9][0-9]{4}$))/;
                } else {
                    pattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳]{1}$/;
                }
                return this.doTest(pattern, value, '请填写正确的车牌号！');
            },
            idCard: function (value) {
                let pattern = /^(([1][1-5])|([2][1-3])|([3][1-7])|([4][1-6])|([5][0-4])|([6][1-5])|([7][1])|([8][1-2]))\d{4}(([1][9]\d{2})|([2]\d{3}))(([0][1-9])|([1][0-2]))(([0][1-9])|([1-2][0-9])|([3][0-1]))\d{3}[0-9xX]$/;
                return this.doTest(pattern, value, '请填写正确的身份证号！');
            },
            zip: function (value) {
                let pattern = /^\d{6}$/;
                return this.doTest(pattern, value, '只能填写6位数字邮编！');
            },
            url: function (value) {
                let pattern = /^(?=^.{3,255}$)(http(s)?:\/\/)?(www\.)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+(:\d+)*(\/\w+\.\w+)*$/;
                return this.doTest(pattern, value, '请填写正确的域名！');
            },
            /**
             * 字符类型校验
             */
            chinese: function (value) {
                let pattern = /^[\u0391-\uFFE5]+$/;
                return this.doTest(pattern, value, this.label + '只能填写中文！');
            },
            letter: function (value) {
                let pattern = /^[a-zA-Z]+$/;
                return this.doTest(pattern, value, this.label + '只能填写大小写英文字母！');
            },
            string: function (value) {
                let pattern = /^[a-zA-Z0-9]+$/;
                return this.doTest(pattern, value, this.label + '只能填写大小写英文字母和数字！');
            },
            password: function (value) {
                let pattern = new RegExp('^[a-zA-Z0-9' + this.options.chars + ']+$');
                return this.doTest(pattern, value, this.label + '只能填写大小写英文字母、数字以及特殊字符！');
            },
            /** 
             *日期格式校验
             */
            ymdhms: function (value) {
                let pattern = /^(\d{4})(-|\/)(\d{1,2})\2(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/;
                return this.doTest(pattern, value, this.label + '只能填写类似2022-11-13 2:56:12的日期格式！');
            },
            ymd: function (value) {
                let pattern = /^(\d{4})(-|\/)(\d{1,2})\2(\d{1,2})$/;
                return this.doTest(pattern, value, this.label + '只能填写类似2022-11-13的日期格式！');
            },
            hms: function (value) {
                let pattern = /^((20|21|22|23|[0-1]\d)\:[0-5][0-9])(\:[0-5][0-9])?$/;
                return this.doTest(pattern, value, this.label + '只能填写类似2:56:12的日期格式！');
            },
            ym: function (value) {
                let pattern = /^(\d{4})(-|\/)(\d{1,2})$/;
                return this.doTest(pattern, value, this.label + '只能填写类似2022-11的日期格式！');
            },
            y: function (value) {
                let pattern = /^(\d{4})$/;
                return this.doTest(pattern, value, this.label + '只能填写4位数字年份！');
            },
            m: function (value) {
                let pattern = /^(0?[1-9]|1[0-2])$/;
                return this.doTest(pattern, value, this.label + '只能填写1~12月份！');
            },
            d: function (value) {
                let pattern = /^((0?[1-9])|((1|2)[0-9])|30|31)$/;
                return this.doTest(pattern, value, this.label + '只能填写1~31日！');
            },
            date: function (value) {
                let ymdhms = /^(\d{4})(-|\/)(\d{1,2})\2(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/,
                    ymd = /^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2})$/,
                    ym = /^(\d{1,4})(-|\/)(\d{1,2})$/,
                    y = /^(\d{4})$/;
                if (ymdhms.test(value) || ymd.test(value) || ym.test(value) || y.test(value)) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '请填写有效的日期！' };
                }
            },
            earlier: function (value) {
                if (!this.options.date || isNaN(Date.parse(this.options.date))) {
                    console.error('Please enter a valid target date!');
                    return;
                }
                if (isNaN(Date.parse(value))) {
                    console.error('The value is not a valid date!');
                    return;
                }
                let timestamp = axLocalTime(value),
                    target = axLocalTime(this.options.date);
                if (timestamp < target) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '不可晚于' + this.options.date + '！' };
                }
            },
            later: function (value) {
                if (!this.options.date || isNaN(Date.parse(this.options.date))) {
                    console.error('Please enter a valid target date!');
                    return;
                }
                if (isNaN(Date.parse(value))) {
                    console.error('The value is not a valid date!');
                    return;
                }
                let timestamp = axLocalTime(value),
                    target = axLocalTime(this.options.date);
                if (timestamp > target) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '不可早于' + this.options.date + '！' };
                }
            },
            dateRange: function (value) {
                if (!this.options.earliest || isNaN(Date.parse(this.options.earliest))) {
                    console.error('Please enter a valid earliest date!');
                    return;
                }
                if (!this.options.latest || isNaN(Date.parse(this.options.latest))) {
                    console.error('Please enter a valid latest date!');
                    return;
                }
                if (isNaN(Date.parse(value))) {
                    console.error('The value is not a valid date!');
                    return;
                }
                let timestamp = axLocalTime(value),
                    earliest = axLocalTime(this.options.earliest),
                    latest = axLocalTime(this.options.latest);
                if (timestamp > earliest && timestamp < latest) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '不可早于' + this.options.latest + '，且不可晚于' + this.options.earliest + '！' };
                }
            },
            /** 
             *数字校验
             */
            integer: function (value) {
                let pattern = /^[1-9]d*$/;
                return this.doTest(pattern, value, this.label + '只能填写非0开头的正整数！');
            },
            number: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                return this.doTest(pattern, value, this.label + '只能填写数字，包括正数、负数、整数、小数！');
            },
            moreThan: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value > this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要大于' + this.options.number + '！' };
                }
            },
            moreEqual: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value >= this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要大于或等于' + this.options.number + '！' };
                }
            },
            lessThan: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value < this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要小于' + this.options.number + '！' };
                }
            },
            lessEqual: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value <= this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要小于或等于' + this.options.number + '！' };
                }
            },
            equal: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value == this.options.number) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要等于' + this.options.number + '！' };
                }
            },
            range: function (value) {
                let pattern = /^(-?\d+)\.?(\d*)$/;
                if (pattern.test(value) && value >= this.options.min && value < this.options.max) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '需要大于等于' + this.options.min + '并小于' + this.options.max + '！' };
                }
            },
            /*
             *字符长度校验
             */
            length: function (value) {
                let pattern = new RegExp('^.{' + this.options.length + '}$');
                return this.doTest(pattern, value, this.label + '只能填写' + this.options.length + '个字符！');
            },
            lengthMore: function (value) {
                let pattern = new RegExp('^.{' + this.options.length + ',}$');
                return this.doTest(pattern, value, this.label + '字符数量不可少于' + this.options.length + '个！');
            },
            lengthLess: function (value) {
                let pattern = new RegExp('^.{0,' + this.options.length + '}$');
                return this.doTest(pattern, value, this.label + '字符数量不可多于' + this.options.length + '个！');
            },
            lengthRange: function (value) {
                let pattern = new RegExp('^.{' + this.options.minLength + ',' + this.options.maxLength + '}$');
                return this.doTest(pattern, value, this.label + '字符数量不可少于' + this.options.minLength + '个，而且不可多于' + this.options.maxLength + '个！');
            },
            /**
             * 包含与否检验
             */
            include: function (value) {
                if (axIsEmpty(this.options.include)) {
                    console.error('The array of include can not be empty!');
                    return;
                }
                if (this.options.include.includes(value)) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '填写的值在指定内容中不存在！' };
                }
            },
            exclude: function (value) {
                if (axIsEmpty(this.options.exclude)) {
                    console.error('The array of exclude can not be empty!');
                    return;
                }
                if (!this.options.exclude.includes(value)) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '不可填写该值！' };
                }
            },
            /**
             * 强度校验
             */
            strong: function (value) {
                if (!this.options.format) {
                    console.error(axError.formatError);
                    return;
                }
                this.getStrong(value);
                let pattern = new RegExp(this.strongParse.pattern);
                return this.doTest(pattern, value, this.strongParse.message);
            },
            /**
             * 异步校验，需要配合this.options.url参数
             */
            async: function (value) {
                if (!this.options.format) {
                    console.error(axError.formatError);
                    return;
                }
                this.getStrong(value);
                let pattern = new RegExp(this.strongParse.pattern);
                return this.doTest(pattern, value, this.strongParse.message);
            },
            /**
             * 选择数量校验，radio、checkbox、select使用
             */
            oneChecked: function (value) {
                if (!Array.isArray(value)) {
                    console.error(axError.arrayRequired);
                    return;
                }
                if (value.length == 1) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '必须且只能选择1项！' };
                }
            },
            leastChecked: function (value) {
                if (!Array.isArray(value)) {
                    console.error(axError.arrayRequired);
                    return;
                }
                if (this.options.least && value.length >= this.options.least) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '至少选择' + this.options.least + '项！' };
                }
            },
            mostChecked: function (value) {
                if (!Array.isArray(value)) {
                    console.error(axError.arrayRequired);
                    return;
                }
                if (!this.options.most || (this.options.most && value.length <= this.options.most)) {
                    return { verified: true, message: '' };
                } else {
                    return { verified: false, message: this.label + '最多选择' + this.options.most + '项！' };
                }
            },
            rangeChecked: function (value) {
                if (!Array.isArray(value)) {
                    console.error(axError.arrayRequired);
                    return;
                }
                if (this.options.least && this.options.most && this.options.most > this.options.least) {
                    if (value.length >= this.options.least && value.length <= this.options.most) {
                        return { verified: true, message: '' };
                    } else {
                        return { verified: false, message: this.label + '至少选择' + this.options.least + '项，且不能多于' + this.options.most + '项！' };
                    }
                } else {
                    console.error(axError.paraError);
                    return;
                }
            },
            /**
             * 对比校验
            */
            same: function (value) {
                if (!this.compare) {
                    console.error(axError.noNode);
                    return;
                }
                if (value == this.compare.value) {
                    return { verified: true, message: '' };
                } else {
                    let info = this.compareLabel ? this.label + '与' + this.compareLabel + '不一致！' : '两个字段值不一致！';
                    return { verified: false, message: info };
                }
            },
        }
        Object.assign(this.checks, this.options.extend);
        this.init()
    }
    init(callback) {
        let _this = this;
        let info = { dom: this.targetDom, name: this.name, instance: this };
        if (axIsEmpty(axValids)) {
            if (this.parent) {
                axValids.push({ parent: this.parent, children: [info] });
            }
        } else {
            if (axValids.some(item => (item.parent == this.parent))) {
                let index = axValids.findIndex(i => (i.parent == this.parent)),
                    infoArr = axValids[index].children;
                if (infoArr.some(i => (i.name == this.name))) {
                    for (let k = 0; k < infoArr.length; k++) {
                        if (infoArr[k].name == this.name) {
                            infoArr[k] = info;
                            break;
                        }
                    }
                } else {
                    infoArr.push(info);
                }
            } else {
                axValids.push({ parent: this.parent, children: [info] });
            }
        }
        /* 
        axValids的最终格式如下：
        [
            {
                parent:'', children: [
                    { dom: '', name: '', instance: '', verified: '' },
                    { dom: '', name: '', instance: '', verified: '' },
                ]
            },
            {
                parent:'', children: [
                    { dom: '', name: '', instance: '', verified: '' },
                    { dom: '', name: '', instance: '', verified: '' },
                ]
            },
            ...
        ] 
        以parent循环监听submit事件，以dom和instance执行校验，以name去重，以verfied确认表单验证是否全部通过
        */
        /**
         * 触发校验
         * */
        let checkFun = function () {
            if (!axIsEmpty(_this.options.extend)) {
                for (let i in _this.options.extend) {
                    _this.rules[i] = ['', _this.options.success]
                }
            }
            let value = '';
            if (_this.type == 'radio' || _this.type == 'checkbox' || _this.type == 'select-multiple' || _this.type == 'file') {
                value = axMultiValues(_this.name, _this.type, _this.parent);
            } else {
                 value = _this.targetDom.value.trim();
                if(_this.options.separator){
                    value = value.split(_this.options.separator);
                }
            }
            let len = Object.keys(_this.rules).length,
                index = 0;
            _this.value = value;
            for (let i in _this.rules) {
                index++;
                let msgFalse = _this.rules[i][0],
                    msgTrue = _this.rules[i][1];
                if (axIsEmpty(value)) {
                    if (i == 'required') {
                        _this.text = !msgFalse ? _this.checks[i].call(_this, '').message : msgFalse;
                        _this.verified = false;
                        break;
                    } else if (i == 'oneChecked' || i == 'leastChecked' || i == 'rangeChecked') {
                        _this.text = !msgFalse ?_this.checks[i].call(_this, []).message : msgFalse;
                        _this.verified = false;
                    } else {
                        _this.text = msgTrue;
                        _this.verified = true;
                    }
                } else {
                    if (_this.options.type) {
                        let result = _this.checks[i].call(_this, value);
                        if (!result.verified) {
                            !msgFalse ? _this.text = result.message : _this.text = msgFalse;
                            _this.verified = false;
                            break;
                        } else {
                            if (index == len) {
                                _this.text = msgTrue;
                                _this.verified = true;
                            }
                        }
                    }
                }
            }
            if (_this.options.url && !_this.options.type) {
                axAjax({
                    url: _this.options.url,
                    data: { name: _this.name, value: _this.value, parent: _this.parent },
                    type: _this.options.ajaxType,
                    success: function (content) {
                        _this.verified = content.verified;
                        _this.text = content.text;
                        _this.refreshDom(_this.options.mode);
                        info.verified = _this.verified;
                        callback && callback.call(_this, _this.verified, _this.text, _this.strong);
                        _this.options.onInit && _this.options.onInit.call(_this, _this.verified, _this.text, _this.strong);
                    },
                })
            } else {
                _this.refreshDom(_this.options.mode);
                info.verified = _this.verified;
                callback && callback.call(_this, _this.verified, _this.text, _this.strong);
                _this.options.onInit && _this.options.onInit.call(_this, _this.verified, _this.text, _this.strong);
            }
            _this.options.onTrigger && _this.options.onTrigger.call(_this, _this.verified, _this.text, _this.strong);
            _this.verifieds.unshift(_this.verified);
            if (_this.verifieds.length >= 2) {
                if (_this.verifieds.length > 2) {
                    _this.verifieds.splice(2);
                }
                if (_this.verifieds[0] != _this.verifieds[1]) {
                    _this.options.onChange && _this.options.onChange.call(_this,  _this.verified, _this.text,_this.strong);
                    'change' in _this.handlers ? _this.emit('change', _this.verified, _this.text, _this.strong) : null;
                }
            }
        }
        if (this.options.trigger == 'submit' ) {
            checkFun();
        }else if (this.options.trigger == 'listen') {
            this.targetDom.onchange = ()=>{
                checkFun();
            }
        } else {
            this.targetDom.addEventListener(this.options.trigger, checkFun, false);
        }
    }
    parseFormat() {
        if (this.options.format) {
            let upperLen = '', 
                lowerLen = '', 
                numberLen = '', 
                charLen = '', 
                cnLen = '', 
                formatMin = '', 
                formatMax = '', 
                onlyName = {},
                scaleNameGroup = [],
                scaleName = {},
                scale = '',
                regExp = '',
                regText = [],
                message = '',
                lengthOnly = null,
                formatType = '',
                formatLength = '',
                formatScale = '';
            formatType = this.options.format.split("#")[0];
            if (this.options.format.split("#")[1]) {
                formatLength = this.options.format.split("#")[1];
                formatMin = formatLength.split(",")[0];
                if (formatLength.indexOf(',') == -1) {
                    lengthOnly = true;
                    formatMax = '';
                } else if (formatLength.indexOf(',') !== -1 && formatLength.split(",")[1]) {
                    formatMax = formatLength.split(",")[1];
                } else {
                    formatMax = '';
                }
            } else {
                formatMin = '';
                formatMax = '';
            }
            if (this.options.format.split("#")[2]) {
                formatScale = this.options.format.split("#")[2];
                if (formatScale.indexOf('a') !== -1) {
                    scaleName.lower = '小写字母';
                    scale += 'a-z';
                    regText.push('a-z');
                    scaleNameGroup.push(scaleName.lower);
                }
                if (formatScale.indexOf('A') !== -1) {
                    scaleName.upper = '大写字母';
                    scale += 'A-Z';
                    regText.push('A-Z');
                    scaleNameGroup.push(scaleName.upper);
                }
                if (formatScale.indexOf('9') !== -1) {
                    scaleName.number = '数字';
                    scale += '0-9';
                    regText.push('0-9');
                    scaleNameGroup.push(scaleName.number);
                }
                if (formatScale.indexOf('~') !== -1) {
                    scaleName.char = this.options.charsShow ? '特殊字符"' + this.options.chars + '"' : '特殊字符';
                    scale += this.options.chars;
                    regText.push(this.options.chars);
                    scaleNameGroup.push(scaleName.char);
                }
                if (formatScale.indexOf('中') !== -1) {
                    scaleName.cn = '中文';
                    scale += '\u4e00-\u9fa5';
                    regText.push('\u4e00-\u9fa5');
                    scaleNameGroup.push(scaleName.cn);
                }
                if (scaleNameGroup.length > 2) {
                    scaleNameGroup = axRangeReplace(scaleNameGroup.join(), '和', scaleNameGroup.join().lastIndexOf(','));
                } else {
                    scaleNameGroup = scaleNameGroup.join()
                }
                scaleNameGroup = scaleNameGroup.replaceAll(',', '、');
                !axIsEmpty(scaleNameGroup) ? message += '必须是' + scaleNameGroup + '，并且要求' : null;
            }
            if (axIsEmpty(this.options.format.split("#")[0]) && this.options.format.split("#")[3]) {
                if (this.options.format.split("#")[3] < formatScale.length && this.options.format.split("#")[3] > 0) {
                    if (this.options.format.split("#")[3] == 2) {
                        regText.forEach(item => {
                            regExp += '(?![' + item + ']+$)';
                        });
                    } else if (this.options.format.split("#")[3] == 3) {
                        axArrange(regText, 2).forEach(item => {
                            regExp += '(?![' + item.join().replaceAll(',', '') + ']+$)';
                        });
                    } else if (this.options.format.split("#")[3] == 4) {
                        axArrange(regExp, 3).forEach(item => {
                            regExp += '(?![' + item.join().replaceAll(',', '') + ']+$)';
                        });
                    }
                } else {
                    console.error('随机字符类型必须有1种，并且不能超过允许字符类型范围！');
                }
                message = scaleNameGroup + '中至少选择' + this.options.format.split("#")[3] + '种字符。';
            }
            if (formatType.indexOf('a') !== -1) {
                let index = formatType.lastIndexOf("a");
                onlyName.lower = '小写字母';
                lowerLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.lower + '至少' + lowerLen + '个，';
            }
            if (formatType.indexOf('A') !== -1) {
                let index = formatType.lastIndexOf("A");
                onlyName.upper = '大写字母';
                upperLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.upper + '至少' + upperLen + '个，';
            }
            if (formatType.indexOf('9') !== -1) {
                let index = formatType.lastIndexOf("9");
                onlyName.number = '数字';
                numberLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.number + '至少' + numberLen + '个，';
            }
            if (formatType.indexOf('~') !== -1) {
                let index = formatType.lastIndexOf("~");
                onlyName.char = this.options.charsShow ? '特殊字符"' + this.options.chars + '"' : '特殊字符';
                charLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.char + '至少' + charLen + '个。';
            }
            if (formatType.indexOf('中') !== -1) {
                let index = formatType.lastIndexOf("中");
                onlyName.cn = '中文';
                cnLen = parseInt(formatType.substring(index + 1, index + 2));
                message += onlyName.cn + '至少' + cnLen + '个。';
            }
            lowerLen ? regExp += '(?=' + Array(lowerLen + 1).join('.*?[a-z]') + ')' : null;
            upperLen ? regExp += '(?=' + Array(upperLen + 1).join('.*?[A-Z]') + ')' : null;
            numberLen ? regExp += '(?=' + Array(numberLen + 1).join('.*?[0-9]') + ')' : null;
            charLen ? regExp += '(?=' + Array(charLen + 1).join('.*?[' + this.options.chars + ']') + ')' : null;
            cnLen ? regExp += '(?=' + Array(cnLen + 1).join('.*?[\u4e00-\u9fa5]') + ')' : null;
            if (!axIsEmpty(scale)) {
                if (formatMin) {
                    regExp += '[' + scale + ']';
                } else {
                    regExp += '[' + scale + ']+';
                }
            } else if (axIsEmpty(scale) && formatMin) {
                regExp += '.'
            } else {
                regExp += '.{0,}'
            }
            if (formatMin && lengthOnly && !formatMax) {
                regExp += '{' + formatMin + '}';
                message += '总共只能是' + formatMin + '个字符。';
            } else if (formatMin && !formatMax) {
                regExp += '{' + formatMin + ',}';
                message += '总共至少' + formatMin + '个字符。';
            } else if (formatMin && formatMax) {
                regExp += '{' + formatMin + ',' + formatMax + '}';
                message += '总共至少' + formatMin + '个字符，且不能超过' + formatMax + '个字符。';
            }
            regExp = '^' + regExp + '$';
            return { pattern: regExp, message: message }
        } else {
            return {}
        }
    }
    getStrong(value) {
        let upVal = 0,
            lowVal = 0,
            numVal = 0,
            charVal = 0,
            cnVal = 0,
            lenVal = 0;
        if (this.options.format) {
            let minLength = this.options.format.split("#")[1].split(",")[0];
            if (value && value.match(new RegExp('[a-z]'))) { lowVal = 1; };
            if (value && value.match(new RegExp('[A-Z]'))) { upVal = 1; };
            if (value && value.match(new RegExp('[0-9]'))) { numVal = 1; }
            if (value && value.match(new RegExp('[' + this.options.chars + ']'))) { charVal = 1; };
            if (value && value.match(new RegExp('[\u4e00-\u9fa5]'))) { cnVal = 1; }
            if (value && minLength && value.length >= minLength) { lenVal = 1; };
        }
        this.strong = upVal + lowVal + numVal + charVal + cnVal + lenVal;
        return this.strong;
    }
    doTest(pattern, value, message) {
        if (pattern.test(value)) {
            return { verified: true, message: '' };
        } else {
            return { verified: false, message: message };
        }
    }
    getRules() {
        this.rules = {};
        let types = this.options.type.trim().split(",");
        if (types[0] != 'required' && types.includes('required')) {
            for (let i = 0; i < types.length; i++) {
                if (types[i] === 'required') {
                    types.splice(i, 1);
                    break;
                }
            }
            types.unshift('required');
        }
        types.forEach(item => {
            this.rules[item] = ['', ''];
            if (!axIsEmpty(this.options.rule)) {
                this.options.rule[item] ? this.rules[item] = this.options.rule[item] : null;
            }
            !this.rules[item][0] ? this.rules[item][0] = this.options.error : null;
            !this.rules[item][1] ? this.rules[item][1] = this.options.success : null;
        });
        return this.rules;
    }
    refreshText() {
        let icon = this.verified ? axIcon.font.successFill : axIcon.font.errorFill;
        if (this.options.iconShow) {
            this.msgBox.innerHTML = icon + ' ' + this.text;
        } else {
            this.msgBox.innerHTML = this.text;
        }
    }
    refreshDom(mode) {
        let _this = this,
            classToggle = function () {
                if (_this.verified) {
                    _this.msgBox.classList.remove(_this.options.boxError)
                    _this.msgBox.classList.add(_this.options.boxSuccess)
                    _this.targetDom.classList.remove(_this.options.inputError);
                    _this.targetDom.classList.add(_this.options.inputSuccess);
                } else {
                    _this.msgBox.classList.remove(_this.options.boxSuccess)
                    _this.msgBox.classList.add(_this.options.boxError)
                    _this.targetDom.classList.remove(_this.options.inputSuccess);
                    _this.targetDom.classList.add(_this.options.inputError);
                }
            };
        this.refreshText();
        if (this.options.mode.nodeType == 1 || mode.substr(0, 1) == "#") {
            let dom = axIdToDom(mode);
            if (!this.msgBox.parentNode) {
                dom.appendChild(this.msgBox);
            }
            classToggle();
        } else if (mode == 'note') {
            this.msgBox.classList.add('ax-form-txt');
            let parent = this.targetDom.closest('.ax-form-con'),
                brother = parent.nextElementSibling;
            if (this.type == 'raido' || this.type == 'checkbox') {
                if (brother && brother.hasAttribute('valid')) {
                    brother.remove();
                }
                parent.insertAdjacentElement('afterend', this.msgBox);
            } else {
                if (brother != this.msgBox) {
                    parent.insertAdjacentElement('afterend', this.msgBox);
                }
            }
            classToggle();
        } else if (mode == 'popup') {
            if (!this.popup) {
                this.popup = new axPopup(this.targetDom.closest('.ax-form-input'), {
                    content: _this.msgBox,
                    padding: false,
                    placement: 'bottom-start',
                    offsetShow: false,
                    arrow: false,
                    close: false,
                    footerShow: false,
                    theme: 'crude',
                    stay: true,
                }).show();
            } else {
                this.popup.content.innerHTML = '';
                this.popup.content.appendChild(this.msgBox);
            }
            classToggle();
        } else if (mode == 'message') {
            if (!this.verified) {
                new axMessage({
                    content: _this.text,
                    result: 'error',
                    iconShow: _this.options.iconShow,
                });
            } else {
                new axMessage({
                    content: _this.text,
                    result: 'success',
                    iconShow: _this.options.iconShow,
                });
            }
            classToggle();
        } else {
            let brother = this.targetDom.closest('.ax-form-input');
            if (this.type == 'radio' || this.type == 'checkbox') {
                if (brother.nextElementSibling && brother.nextElementSibling.hasAttribute('valid')) {
                    brother.nextElementSibling.remove();
                }
                brother.insertAdjacentElement('afterend', this.msgBox);
            } else {
                if (brother != this.msgBox) {
                    brother.insertAdjacentElement('afterend', this.msgBox);
                }
            }
            this.msgBox.classList.add('ax-valid');
            classToggle();
        }
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/**
 * 点击提交表单校验，通常是对button使用js提交的时候使用
 * e：通常是window
 * data：数组数据，格式为：[{parent:'',children:{name:'',verified:'',text:''}},{}]
 * outer:表单项的父层，可以是form节点，也可以是某div节点，但是必须与表单项的父节点一致，所以建议是form节点
 * callback：校验成功后执行回调函数
 * interval：表单项校验的间隔时间，纯是为了显示逐个校验效果，默认100毫秒
*/
const axValidRepeat = (e, data, outer, callback, interval = 100) => {
    if (!outer) {
        console.error('A form node must be filled in!');
        return false;
    }
    if (axIsEmpty(data)) {
        console.error(axError.required);
        return false;
    }
    if (axIsEmpty(data.filter(i => i.parent == outer))) {
        console.error('No submittable form found!');
        return false;
    }
    let formValids = [...axValids],
        children = formValids.filter(item => item.parent == outer)[0].children,
        k = 0,
        judge = () => {
            let form = axValids.filter(i => i.parent == outer)[0];
            if (form.children.some(i => !i.verified)) {
                axPreventDefault(e);
            } else {
                callback && callback();
            }
        };
    children.forEach((i, index) => {
        i.instance.options.trigger = 'submit';
        setTimeout(() => {
            k++;
            i.instance.init(function () {
                if (k == children.length) {
                    judge();
                }
            });
        }, interval * index);
    });
}
(() => {
    [...document.querySelectorAll('[axValid]')].filter(item => {
        return item.getAttribute('name');
    }).forEach(item => {
        new axValid(item);
    });
    if (!axIsEmpty(axValids)) {
        let formValids = [...axValids];
        formValids.forEach(item => {
            if (item.parent.nodeName == 'FORM') {
                item.parent.addEventListener("submit", function (e) {
                    axPreventDefault(e);
                    axValidRepeat(e, axValids, item.parent,  ()=> {
                        item.parent.submit();
                    });
                }, false);
            }
        })
    }
})();
/*!
* 插件：定义效果更好Hover操作；使用方法：new axHover('#id',{参数})
*/
class axHover {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            timeout: 50,
            interval: 50,
            threshold: 7,
            enter: () => { },
            leave: () => { },
            hold: '',
        }, options);
        this.curX;
        this.curY;
        this.preX;
        this.preY;
        this.enterTimer;
        this.leaveTimer;
        this.isActive = false;
        this.options.hold ? this.hold = axIdToDom(this.options.hold) : this.hold = '';
        this.event = (type, elem, event) => {
            if (type === 'enter') {
                this.options.enter.call(this, elem, event);
                this.isActive = true;
            } else if (type === 'leave') {
                this.options.leave.call(this, elem, event);
                this.isActive = false;
            }
        }
        this.enterCompare = (elem, e) => {
            let distX = this.preX - this.curX,
                distY = this.preY - this.curY,
                distance = Math.sqrt(distX ** 2 + distY ** 2);
            if (distance < this.options.threshold) {
                if(!this.isActive){
                    this.event('enter', elem, e);
                }
            } else {
                this.preX = this.curX;
                this.preY = this.curY;
                this.enterTimer = setTimeout(() => {
                    this.enterCompare(elem, e);
                }, this.options.interval);
            }
        };
        this.init();
    }
    init() {
        let _this = this;
        this.targetDom.addEventListener('mousemove', (e) => {
            this.curX = e.pageX;
            this.curY = e.pageY;
        });
        this.targetDom.addEventListener('mouseenter', function (e) {
            clearTimeout(_this.leaveTimer);
            _this.preX = e.pageX;
            _this.preY = e.pageY;
            _this.enterTimer = setTimeout(() => {
                _this.enterCompare(this, e);
            }, _this.options.interval);
        });
        this.targetDom.addEventListener('mouseleave', function (e) {
            clearTimeout(_this.enterTimer);
            _this.leaveTimer = setTimeout(() => {
                _this.event('leave', this, e);
            }, _this.options.timeout);
        });
        if (this.hold) {
            _this.hold.onmouseenter = function (e) {
                clearTimeout(_this.leaveTimer);
            }
            _this.hold.onmouseleave = function (e) {
                clearTimeout(_this.enterTimer);
                _this.leaveTimer = setTimeout(() => {
                    _this.event('leave', _this.targetDom, e);
                }, _this.options.timeout);
            }
        }
    };
}
/*!
 * 插件：查看更多；使用方法：new axMore('#id',{参数})
 */
const axMores = [];
class axMore {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            length: 60,
            textFold: '展开',
            textUnfold: '收起',
            classFold: 'ax-color-primary',
            classUnfold: 'ax-color-primary',
        }, options, this.targetDom,'axMore');
        this.handlers = {};
        this.html = this.targetDom.innerHTML;
        this.pureHtml = this.targetDom.textContent;
        let _this = this,
            more = true;
        this.event = function() {
            if (more) {
                _this.targetDom.removeChild(this.previousSibling);
                this.innerHTML = _this.options.textUnfold;
                this.setAttribute('class', _this.options.classUnfold);
                this.insertAdjacentHTML('beforeBegin', _this.text);
                more = false;
                'unfold' in _this.handlers ? _this.emit('unfold', '') : null;
            } else {
                _this.targetDom.removeChild(this.previousSibling);
                this.innerHTML = _this.options.textFold;
                this.setAttribute('class', _this.options.classFold);
                this.insertAdjacentHTML('beforeBegin', _this.ell);
                more = true;
                'fold' in _this.handlers ? _this.emit('fold', '') : null;
            }
        };
        !!this.targetDom.getAttribute('axMore') ? this.referName = this.targetDom.getAttribute('axMore') : this.referName = '';
        this.init();
    }
    init() {
        this.text = this.pureHtml.trim().replace(/<[^>]+>/g, '').replace(/ +/g, ' ');
        this.ell = this.text.substring(0, this.options.length) + '...';
        let _this = this,
            textLength = [...this.text].length,
            link = `<a href="###" class="${this.options.classFold}">${this.options.textFold}</a>`;
        if (textLength > this.options.length) {
            this.targetDom.innerHTML = this.ell + link;
        }
        this.targetDom.lastChild.onclick = this.event;
        if (this.referName) {
            if (axIsEmpty(axMores)) {
                axMores.push({ name: this.referName, instance: this });
            } else {
                if (!axMores.some(item => (item.name == this.referName))) {
                    axMores.push({ name: this.referName, instance: this });
                }
                /*  for (let i = 0; i < axMores.length; i++) {
                     if (axMores[i].name == this.referName) {
                         axMores[i].instance = this;
                         break;
                     } else {
                         axMores.push({ name: this.referName, instance: this });
                     }
                 } */
            }
        }
        'load' in this.handlers ? this.emit('load', '') : null;
        return this;
    }
    destroy(callback) {
        this.targetDom.lastChild.removeEventListener('click', this.event, false);
        this.targetDom.innerHTML = this.html;
        callback && callback.call(this);
    }
    updateContent(text, callback) {
        let _this = this;
        if ((typeof text) === 'string') {
            if (text.substr(0, 1) == "#") {
                text = document.querySelector(text).textContent;
            } else {
                text = text;
            }
        } else {
            text = text.textContent;
        }
        this.pureHtml = text;
        this.init();
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    update(setting, callback) {
        let _this = this;
        this.options = axExtend(this.options, setting);
        this.init();
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axMore]').forEach(element => {
        new axMore(element);
    });
})();
/*!
 * 插件：手风琴折叠；使用方法：new axAccordion('#id',{参数})
 */
class axAccordion {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            insName: '',
            storageName: '',
            content: '',
            dispose: false,
            active: '',
            disabled: '',
            multiple: false,
            collapseAll: true,
            borderShow: false,
            ajaxType: 'post',
            trigger: 'click',
            max: 0,
            headerBreakShow: true,
            bodyBreakShow: true,
            targetClass: '',
            itemNode: 'li',
            arrow: {
                enable: true,
                rotate: 180,
                iconClose: 'ax-icon-up',
                iconOpen: 'ax-icon-up',
                position: 'end',
            },
            tipPosition: 'start',
            addToActive: true,
            onInit: '',
            onAdd: '',
            onRemove: '',
            onDisable: '',
            onEnable: '',
            onDisableALL: '',
            onEnableAll: '',
            onExpand: '',
            onExpanded: '',
            onCollapse: '',
            onCollapsed: '',
            onUpdate: '',
            onUpdateContent: '',
            onDestroy: '',
            onSave: '',
            onExpandAll: '',
            onCollapseAll: '',
        }, options, this.targetDom, this.constructor.name);
        let _this = this;
        this.handlers = {};
        this.triggerShow = function () {
            _this.toggle(this);
        }
        this.init();
    };
    init() {
        axInstance.push(this, this.options.insName, 'accordion');
        this.destroyed = false;
        this.data = [];
        if (this.options.storageName) {
            let storageVal = axLocalStorage.get(this.options.storageName);
            if (!axIsEmpty(storageVal)) {
                this.options = axExtend(this.options, storageVal);
            } else {
                axLocalStorage.set(this.options.storageName, {});
            }
        }
        this.setAttribute();
        this.initDataStd();
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    initDataStd() {
        let _this = this;
        if (!axIsEmpty(this.options.content)) {
            this.targetDom.innerHTML = '';
            if (typeof this.options.content === 'string') {
                axAjax({
                    url: this.options.content,
                    type: this.options.ajaxType,
                    success: (content) => {
                        this.targetDom.innerHTML = '';
                        this.data = content;
                        if (this.data.length > 0) {
                            this.initRender(this.data);
                            this.renderFinish();
                        }
                    }
                }, this.targetDom);
            } else {
                this.data = this.options.content;
                if (this.data.length > 0) {
                    this.initRender(this.data);
                    this.renderFinish();
                }
            }
        } else {
            if (this.targetDom.innerHTML) {
                let children = [...this.targetDom.children];
                for (let k in children) {
                    if (k >= this.options.max && this.options.max !== 0) {
                        break;
                    }
                    let wrapperDom = children[k],
                        headerDom = wrapperDom.querySelector('[header]'),
                        flexDom = wrapperDom.querySelector('[flex]'),
                        bodyDom = wrapperDom.querySelector('[body]'),
                        contentDom = wrapperDom.querySelector('[content]'),
                        labelDom = headerDom.querySelector('[label]'),
                        arrowDom = headerDom.querySelector('[arrow]'),
                        tipDom = wrapperDom.querySelector('[tip]'),
                        legendDom = wrapperDom.querySelector('[legend]'),
                        headerBreakDom = headerDom.nextElementSibling && headerDom.nextElementSibling.classList.contains('ax-break-line') ? headerDom.nextElementSibling : null,
                        bodyBreakDom = contentDom.nextElementSibling && contentDom.nextElementSibling.classList.contains('ax-break-line') ? contentDom.nextElementSibling : null;
                    let obj = {
                        label: labelDom.innerHTML.trim(),
                        content: contentDom.innerHTML.trim(),
                        wrapperDom: wrapperDom,
                        flexDom: flexDom,
                        labelDom: labelDom,
                        headerDom: headerDom,
                        bodyDom: bodyDom,
                        contentDom: contentDom,
                        arrowDom: arrowDom,
                        tipDom: tipDom,
                        legendDom: legendDom,
                        headerBreakDom: headerBreakDom,
                        bodyBreakDom: bodyBreakDom,
                    }
                    if (wrapperDom.hasAttribute('active')) {
                        obj.active = true;
                    };
                    if (wrapperDom.hasAttribute('disabled')) {
                        obj.disabled = true;
                    }
                    this.data.push(obj);
                }
                this.renderFinish();
            }
        }
    }
    initRender(data) {
        for (let k in data) {
            if (k >= this.options.max && this.options.max !== 0) {
                break;
            }
            this.appendItem(data[k]);
        }
        this.disable(this.options.disabled);
    }
    appendItem(obj, callback) {
        let content;
        if (obj.type === 'async' || obj.type === 'url') {
            content = '';
        } else if (obj.type === 'node') {
            content = axIdToDom(obj.content);
        } else {
            if (typeof obj.content === 'string') {
                if (axStrType(obj.content)) {
                    content = axIdToDom(obj.content).innerHTML;
                } else {
                    content = obj.content
                }
            } else {
                content = obj.content || '';
            }
        }
        let wrapperDom = axAddElem(this.options.itemNode),
            flexDom = axAddElem('div', { flex: '' }),
            labelDom = axAddElem('i', { label: '' }, obj.label),
            headerDom = axAddElem('div', { header: '' }, labelDom),
            bodyDom = axAddElem('div', { body: '' }),
            headerBreakDom = axAddElem('div', { class: 'ax-break-line' }),
            bodyBreakDom = axAddElem('div', { class: 'ax-break-line' }),
            contentDom = axAddElem(obj.type === 'url' ? 'iframe' : 'div', obj.type === 'url' ? { content: '', frameborder: 0 } : { content: '' }, content);
        flexDom.appendChild(labelDom);
        headerDom.appendChild(flexDom);
        wrapperDom.appendChild(headerDom);
        if (this.options.headerBreakShow) {
            headerDom.insertAdjacentElement('afterend', headerBreakDom);
            obj.headerBreakDom = headerBreakDom;
        } else {
            obj.headerBreakDom = null;
        }
        bodyDom.appendChild(contentDom);
        if (this.options.bodyBreakShow) {
            bodyDom.insertAdjacentElement('beforeend', bodyBreakDom);
            obj.bodyBreakDom = bodyBreakDom;
        } else {
            obj.bodyBreakDom = null;
        }
        wrapperDom.appendChild(bodyDom);
        obj.wrapperDom = wrapperDom;
        obj.headerDom = headerDom;
        obj.bodyDom = bodyDom;
        obj.contentDom = contentDom;
        obj.labelDom = labelDom;
        obj.headerBreakDom = headerBreakDom;
        obj.disabled ? wrapperDom.setAttribute('disabled', '') : null;
        if (!axIsEmpty(obj.props)) {
            for (let k in obj.props) {
                wrapperDom.setAttribute(k, obj.props[k]);
            }
        }
        if (obj.tip) {
            let tipDom = axAddElem('i', { tip: '' }, obj.tip);
            if (this.options.tipPosition === 'start') {
                labelDom.insertAdjacentElement('afterend', tipDom);
            } else if (this.options.tipPosition === 'end') {
                headerDom.insertAdjacentElement('beforeend', tipDom);
            }
            obj.tipDom = tipDom;
        }
        if (obj.legend) {
            let legendDom = axAddElem('i', { legend: '', class: obj.legend ? 'ax-iconfont ' + obj.legend : 'ax-iconfont' });
            headerDom.insertAdjacentElement('afterbegin', legendDom);
            obj.legendDom = legendDom;
        }
        if (this.options.arrow.enable) {
            let arrowDom = axAddElem('i', { arrow: '', class: `ax-iconfont ${this.options.arrow.iconClose}` });
            if (this.options.arrow.position === 'start') {
                headerDom.insertAdjacentElement('afterbegin', arrowDom);
            } else if (this.options.arrow.position === 'end') {
                headerDom.insertAdjacentElement('beforeend', arrowDom);
            }
            obj.arrowDom = arrowDom;
        }
        this.targetDom.appendChild(wrapperDom);
        callback && callback(obj);
    }
    initActive() {
        if (this.data.length === 0) {
            return false;
        }
        if (this.options.multiple && !this.options.collapseAll) {
            this.expandAll();
        } else {
            let activeItems = this.data.filter(k => k.active);
            if (this.options.active !== '') {
                let stringArr = axValueToArr(this.options.active),
                    itemArr = [...stringArr.map(k => axFindItem(k, this.data)), ...activeItems].filter(Boolean);
                if (itemArr.length > 0) {
                    if (this.options.multiple) {
                        itemArr.forEach(k => {
                            this.expand(k);
                        });
                    } else {
                        this.expand(itemArr[0]);
                    }
                }
            } else {
                if (this.options.multiple) {
                    activeItems.forEach(k => {
                        this.expand(k);
                    });
                } else {
                    this.expand(activeItems[0]);
                }
            }
        }
    }
    asyncActive(obj, callback) {
        if (obj.contentDom.innerHTML.trim()) {
            return false;
        }
        if (obj.type === 'async' && obj.content && typeof obj.content === 'string') {
            axAjax({
                url: obj.content,
                type: this.options.ajaxType,
                success: function (content) {
                    obj.contentDom.innerHTML = content;
                    callback && callback(content);
                }
            });
        }
    }
    setAttribute() {
        !this.targetDom.classList.contains('ax-accordion') ? this.targetDom.classList.add('ax-accordion') : null;
        this.options.targetClass ? axClass.add(this.targetDom, this.options.targetClass) : null;
        this.options.borderShow ? axClass.add(this.targetDom, 'ax-border') : null;
        this.options.arrow.enable && this.options.arrow.rotate ? this.targetDom.setAttribute('rotate', this.options.arrow.rotate) : null;
    }
    renderFinish() {
        this.initActive();
        if (!this.options.dispose) {
            this.data.forEach(k => {
                if (!k.disabled) {
                    k.headerDom.addEventListener(this.options.trigger, this.triggerShow, false);
                }
            });
        }
        this.save();
    }
    workToggle(item, type = 'disable') {
        if (type === 'enable' && item.disabled) {
            delete item.disabled;
            item.wrapperDom.removeAttribute('disabled');
            item.headerDom.addEventListener(this.options.trigger, this.triggerShow, false);
        } else if (type === 'disable' && !item.disabled) {
            item.disabled = true;
            item.wrapperDom.setAttribute('disabled', '');
            item.headerDom.removeEventListener(this.options.trigger, this.triggerShow, false);
        }
        this.save();
    }
    getDisabled() {
        return this.data.filter(k => k.disabled);
    }
    getActive() {
        return this.data.filter(k => k.active);
    }
    collapseAll(callback) {
        if (this.destroyed) {
            return this;
        }
        this.data.filter(k => k.active).forEach(k => {
            this.collapse(k);
        });
        'collapseAll' in this.handlers ? this.emit('collapseAll', '') : null;
        this.options.onCollapseAll && this.options.onCollapseAll.call(this);
        callback && callback.call(this);
    }
    expandAll(callback) {
        if (this.destroyed || !this.options.multiple) {
            return this;
        }
        this.data.forEach(k => {
            this.expand(k);
        });
        'expandAll' in this.handlers ? this.emit('expandAll', '') : null;
        this.options.onExpandAll && this.options.onExpandAll.call(this);
        callback && callback.call(this);
    }
    disable(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        if (obj !== 0 && axIsEmpty(obj)) {
            return false;
        }
        let disableFun = (k) => {
            let item = axFindItem(k, this.data);
            if (item) {
                this.workToggle(item, 'disable');
            }
        }
        if (Array.isArray(obj)) {
            obj.forEach(k => {
                disableFun(k);
            });
        } else {
            disableFun(obj);
        }
        this.save();
        let disableds = this.data.filter(k => k.disabled);
        'disable' in this.handlers ? this.emit('disable', disableds) : null;
        this.options.onDisable && this.options.onDisable.call(this, disableds);
        callback && callback.call(this, disableds);
    }
    disableAll(callback) {
        this.disable(this.data);
        'disableAll' in this.handlers ? this.emit('disableAll', '') : null;
        this.options.onDisableAll && this.options.onDisableAll.call(this);
        callback && callback.call(this);
    }
    enable(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        if (obj !== 0 && axIsEmpty(obj)) {
            return false;
        }
        let enableFun = (k) => {
            let item = axFindItem(k, this.data);
            if (item) {
                this.workToggle(item, 'enable');
            }
        }
        if (Array.isArray(obj)) {
            obj.forEach(k => {
                enableFun(k);
            });
        } else {
            enableFun(obj);
        }
        this.save();
        let enableds = this.data.filter(k => !k.disabled);
        'enable' in this.handlers ? this.emit('enable', enableds) : null;
        this.options.onEnable && this.options.onEnable.call(this, enableds);
        callback && callback.call(this, enableds);
    }
    enableAll(callback) {
        this.enable(this.data);
        'enableAll' in this.handlers ? this.emit('enableAll', '') : null;
        this.options.onEnableAll && this.options.onEnableAll.call(this);
        callback && callback.call(this);
    }
    updateContent(item, content, callback) {
        if (this.destroyed) {
            return this;
        }
        let me = axFindItem(item, this.data);
        if (me) {
            me.contentDom.innerHTML = '';
            content ? me.content = content : null;
            if (me.type === 'url') {
                me.contentDom.src = content;
            } else if (me.type === 'async') {
                this.asyncActive(me);
            } else if (axType(me.conten).includes('HTML')) {
                me.contentDom.appendChild(me.content);
            } else {
                me.contentDom.innerHTML = me.content;
            }
            this.save();
        }
        'updateContent' in this.handlers ? this.emit('updateContent', me) : null;
        this.options.onUpdateContent && this.options.onUpdateContent.call(this, me);
        callback && callback.call(this, me);
    }
    toggle(item) {
        let me = axFindItem(item, this.data);
        if (me.active) {
            this.collapse(me);
        } else {
            this.expand(me);
        }
    }
    collapse(obj, callback) {
        let type = axType(obj),
            item = type === 'Object' ? obj : axFindItem(obj, this.data);
        if (!item) {
            return false;
        }
        'collapse' in this.handlers ? this.emit('collapse', item) : null;
        this.options.onCollapse && this.options.onCollapse.call(this, item);
        delete item.active;
        item.wrapperDom.removeAttribute('active');
        if (this.options.arrow.enable && !this.options.arrow.rotate) {
            item.arrowDom.classList.remove(this.options.arrow.iconOpen);
            item.arrowDom.classList.add(this.options.arrow.iconClose);
        }
        axSlideUp(item.bodyDom, () => {
            'collapsed' in this.handlers ? this.emit('collapsed', item) : null;
            this.options.onCollapsed && this.options.onCollapsed.call(this, item);
            callback && callback.call(this, item);
        });
        this.save();
    }
    slideDown(obj, callback) {
        let type = axType(obj),
            item = type === 'Object' ? obj : axFindItem(obj, this.data);
        if (!item) {
            return false;
        }
        item.active = true;
        item.wrapperDom.setAttribute('active', '');
        if (this.options.arrow.enable && !this.options.arrow.rotate) {
            item.arrowDom.classList.remove(this.options.arrow.iconClose);
            item.arrowDom.classList.add(this.options.arrow.iconOpen);
        }
        axSlideDown(item.bodyDom, () => {
            'expanded' in this.handlers ? this.emit('expanded', item) : null;
            this.options.onExpanded && this.options.onExpanded.call(this, item);
            callback && callback.call(this, item);
        });
    }
    expand(item, callback) {
        if (this.destroyed) {
            return this;
        }
        let me = axFindItem(item, this.data), others;
        if (!axIsEmpty(me)) {
            'expand' in this.handlers ? this.emit('expand', me) : null;
            this.options.onExpand && this.options.onExpand.call(this, me);
            if (me.type === 'async' && !me.contentDom.innerHTML) {
                me.arrowDom ? me.arrowDom.setAttribute('loading', '') : null;
                this.asyncActive(me, () => {
                    this.slideDown(me, () => {
                        callback && callback.call(this, me);
                    });
                    me.arrowDom ? me.arrowDom.removeAttribute('loading') : null;
                });
            } else {
                if (me.type === 'url' && !me.contentDom.getAttribute('src')) {
                    me.contentDom.setAttribute('src', me.content)
                }
                this.slideDown(me, () => {
                    callback && callback.call(this, me);
                });
            }
            if (!this.options.multiple) {
                others = this.data.filter(k => (k !== me && k.active));
                others.forEach(k => {
                    this.collapse(k);
                });
            }
            this.save();
        }
    }
    add(data, callback) {
        if (this.destroyed) {
            return this;
        }
        if (axIsEmpty(data)) {
            return false;
        }
        if (this.data.length >= this.options.max && this.options.max !== 0) {
            console.warn('The number of children exceeds the maximum!');
            return false;
        }
        let type = axType(data),
            items = [],
            appendFun = (obj) => {
                if (this.data.findIndex(k => k.label === obj.label) === -1) {
                    this.appendItem(obj, () => {
                        this.data.push(obj);
                        items.push(obj);
                    });
                }
            };
        if (type === 'Object') {
            appendFun(data);
        } if (type === 'Array' && data.length > 0) {
            data.forEach(k => {
                appendFun(k);
            });
        }
        if (items.length > 0) {
            if (this.options.addToActive) {
                if (this.options.multiple) {
                    items.forEach(k => {
                        this.expand(k);
                    });
                } else {
                    this.expand(items[items.length - 1]);
                }
            }
            this.renderFinish();
        }
        this.save();
        'add' in this.handlers ? this.emit('add', items) : null;
        this.options.onAdd && this.options.onAdd.call(this, items);
        callback && callback.call(this, items);
        return this;
    }
    remove(data, callback) {
        if (this.destroyed) {
            return this;
        }
        if (axIsEmpty(data)) {
            return false;
        }
        if (this.data.length === 0) {
            console.warn('The data is already empty!');
            return false;
        }
        let removeItem = (child) => {
            let item = axFindItem(child, this.data);
            if (item) {
                item.headerDom.removeEventListener(this.options.trigger, this.triggerShow, false);
                item.wrapperDom.remove();
                this.data = this.data.filter(k => k !== item);
            }
        };
        if (Array.isArray(data)) {
            data.forEach(k => {
                removeItem(k);
            });
        } else {
            removeItem(data);
        }
        this.save();
        'remove' in this.handlers ? this.emit('remove', '') : null;
        this.options.onRemove && this.options.onRemove.call(this);
        callback && callback.call(this);
        return this;
    }
    save(props, callback) {
        if (this.destroyed) {
            return this;
        }
        if (!this.options.storageName) {
            return false;
        }
        setTimeout(() => {
            let idsActive = this.data.filter(k => k.active).map(k => k.id).filter(Boolean),
                idsDisabled = this.data.filter(k => k.disabled).map(k => k.id).filter(Boolean);
            if (!props) {
                axLocalStorage.set(this.options.storageName, { active: idsActive, disabled: idsDisabled, content: this.data });
            } else {
                !props.hasOwnProperty('active') ? props.active = idsActive : null;
                !props.hasOwnProperty('disabled') ? props.disabled = idsDisabled : null;
                !props.hasOwnProperty('content') ? props.content = this.data : null;
                axLocalStorage.set(this.options.storageName, props);
            }
            let getValue = axLocalStorage.get(this.options.storageName);
            'save' in this.handlers ? this.emit('save', getValue) : null;
            this.options.onSave && this.options.onSave.call(this, getValue);
            callback && callback.call(this, getValue);
            return this;
        }, 0)
    }
    destroy(callback) {
        this.data.forEach(k => {
            k.headerDom.removeEventListener(this.options.trigger, this.triggerShow);
        });
        this.destroyed = true;
        this.options.storageName?axLocalStorage.set(this.options.storageName, {}):null;
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        callback && callback.call(this);
        return this;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options = axExtend(this.options, setting);
        this.options.storageName?axLocalStorage.set(this.options.storageName, {}):null;
        this.init();
        'update' in this.handlers ? this.emit('update', '') : null;
        this.options.onUpdate && this.options.onUpdate.call(this);
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
document.querySelectorAll('[axAccordion]').forEach(element => {
    new axAccordion(element);
});
/*!
 * 插件：页签切换；使用方法：axTab('#id',{参数})
 */
class axTab {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            insName: '',
            storageName: '',
            trigger: 'click',
            disabled: '',
            active: 0,
            content: '',
            ajaxType: 'post',
            headerNode: 'ul',
            bodyNode: 'ul',
            headerChildNode: 'li',
            bodyChildNode: 'li',
            max: 0,
            closable: false,
            updatable: false,
            wrapperClass: '',
            headerClass: 'ax-tab-group',
            bodyClass: '',
            swiper: {
                enable: false,
                arrowShow: false,
                options: { slidesPerView: 'auto', threshold: 4 },
            },
            menu: {
                enable: false,
                options: {
                    columns: 4,
                    size: 'lg',
                }
            },
            addToActive: true,
            onInit: '',
            onAdd: '',
            onBeforeRemove: '',
            onRemove: '',
            onDisable: '',
            onEnable: '',
            onDisableALL: '',
            onEnableAll: '',
            onActive: '',
            onUpdate: '',
            onUpdateContent: '',
            onDestroy: '',
            onSave: '',
        }, options, this.targetDom, this.constructor.name);
        let _this = this;
        this.handlers = {};
        this.swiperDom = null;
        this.swiper = null;
        this.triggerShow = function () {
            _this.active(this);
        }
        this.labelClose = (obj) => {
            if (this.options.onBeforeRemove) {
                let flag = this.options.onBeforeRemove.call(_this, obj);
                if (flag) {
                    this.remove(obj);
                }
            } else {
                this.remove(obj);
            }
        }
        this.init();
    }
    init() {
        axInstance.push(this, this.options.insName, 'tab');
        this.destroyed = false;
        this.data = [];
        if (this.options.storageName) {
            let storageVal = axLocalStorage.get(this.options.storageName);
            if (!axIsEmpty(storageVal)) {
                this.options = axExtend(this.options, storageVal);
            } else {
                axLocalStorage.set(this.options.storageName, {});
            }
        }
        this.initDataStd();
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    initDataStd() {
        let _this = this;
        if (!axIsEmpty(this.options.content)) {
            this.targetDom.innerHTML = '';
            if (typeof this.options.content === 'string') {
                axAjax({
                    url: this.options.content,
                    type: this.options.ajaxType,
                    success: (content) => {
                        this.targetDom.innerHTML = '';
                        this.data = content;
                        if (this.data.length > 0) {
                            this.initRender(this.data);
                            this.renderFinish();
                        }
                    }
                }, this.targetDom);
            } else {
                this.data = this.options.content;
                if (this.data.length > 0) {
                    this.initRender(this.data);
                    this.renderFinish();
                }
            }
        } else {
            !this.targetDom.classList.contains('ax-tab') ? this.targetDom.classList.add('ax-tab') : null;
            if (this.targetDom.querySelector('[header]') && this.targetDom.querySelector('[body]')) {
                this.navDom = this.targetDom.querySelector('[nav]');
                this.prevDom = this.navDom ? this.navDom.querySelector('[prev]') : null;
                this.nextDom = this.navDom ? this.navDom.querySelector('[next]') : null;
                this.menuDom = this.navDom ? this.navDom.querySelector('[menu]') : null;
                this.swiperDom = this.targetDom.querySelector('.ax-swiper');
                this.headerWrapperDom = this.targetDom.querySelector('[header]');
                this.bodyWrapperDom = this.targetDom.querySelector('[body]');
                let headerChildren = [...this.headerWrapperDom.children],
                    bodyChildren = [...this.bodyWrapperDom.children];
                for (let i = 0, len = headerChildren.length; i < len; i++) {
                    if (i >= this.options.max && this.options.max !== 0) {
                        break;
                    }
                    let k = headerChildren[i],
                        tabCaptionDom = k.querySelector('[label]'),
                        tabCloseDom = k.querySelector('[close]'),
                        tabUpdateDom = k.querySelector('[update]');
                    let bodyItem = bodyChildren[i];
                    if (bodyItem) {
                        let obj = {
                            label: tabCaptionDom ? tabCaptionDom.innerText : k.innerHTML,
                            content: bodyItem.innerHTML,
                            labelDom: tabCaptionDom,
                            headerDom: k,
                            bodyDom: bodyItem,
                        }
                        if (k.hasAttribute('active')) {
                            obj.active = true;
                        };
                        if (k.hasAttribute('disabled')) {
                            obj.disabled = true;
                        }
                        this.data.push(obj);
                        tabUpdateDom ? obj.updateDom = tabUpdateDom : null;
                        tabCloseDom ? obj.closeDom = tabCloseDom : null;
                    }
                }
                this.createSwiper();
                this.initActive();
                this.renderFinish();
            }
        }
    }
    initRender(data) {
        this.headerWrapperDom = axAddElem(this.options.headerNode, { header: '' });
        this.bodyWrapperDom = axAddElem(this.options.bodyNode, { body: '' });
        for (let i = 0, len = data.length; i < len; i++) {
            if (i >= this.options.max && this.options.max !== 0) {
                break;
            }
            this.appendItem(data[i]);
        }
        this.initActive();
        this.disable(this.options.disabled);
        this.setAttribute();
        if (this.options.swiper.enable) {
            this.headerWrapperDom.classList.add('ax-wrapper');
            this.swiperDom = axAddElem('div', { class: 'ax-swiper' }, this.headerWrapperDom);
            this.navDom = axAddElem('div', { class: 'ax-tab-swiper' }, this.swiperDom);
            if (this.options.swiper.arrowShow) {
                this.prevDom = axAddElem('i', { prev: '' });
                this.nextDom = axAddElem('i', { next: '' });
                this.navDom.insertAdjacentElement('afterbegin', this.prevDom);
                this.navDom.insertAdjacentElement('beforeend', this.nextDom);
            }
            if (this.options.menu.enable) {
                this.menuDom = axAddElem('i', { menu: '' });
                this.navDom.insertAdjacentElement('beforeend', this.menuDom);
            }
            this.targetDom.appendChild(this.navDom);
            this.createSwiper();
        } else {
            this.targetDom.appendChild(this.headerWrapperDom);
        }
        this.targetDom.appendChild(this.bodyWrapperDom);
    }
    appendItem(obj, callback) {
        if (!obj.label) {
            return false;
        }
        let content;
        if (obj.type === 'async' || obj.type === 'url') {
            content = '';
        } else if (obj.type === 'node') {
            content = axIdToDom(obj.content);
        } else {
            if (typeof obj.content === 'string') {
                if (axStrType(obj.content)) {
                    content = axIdToDom(obj.content).innerHTML;
                } else {
                    content = obj.content
                }
            } else {
                content = obj.content || '';
            }
        }
        let headerChildDom = axAddElem(this.options.headerChildNode),
            tabLabelDom = axAddElem('i', { label: '' }, obj.label),
            bodyChildDom = axAddElem(obj.type === 'url' ? 'iframe' : this.options.bodyChildNode, obj.type === 'url' ? { src: obj.content, frameborder: 0 } : '', content),
            tabCloseDom = axAddElem('i', { close: '' }),
            tabUpdateDom = axAddElem('i', { update: '' });
        headerChildDom.appendChild(tabLabelDom);
        obj.active ? (headerChildDom.setAttribute('active', ''), bodyChildDom.setAttribute('active', '')) : null;
        obj.disabled ? headerChildDom.setAttribute('disabled', '') : null;
        if (!axIsEmpty(obj.props)) {
            for (let k in obj.props) {
                bodyChildDom.setAttribute(k, obj.props[k]);
            }
        }
        this.swiper ? headerChildDom.classList.add('ax-slide') : null;
        obj.headerDom = headerChildDom;
        obj.labelDom = tabLabelDom;
        obj.bodyDom = bodyChildDom;
        this.headerWrapperDom.appendChild(headerChildDom);
        if (this.options.updatable) {
            obj.updateDom = tabUpdateDom;
            headerChildDom.appendChild(tabUpdateDom);
        }
        if (this.options.closable) {
            obj.closeDom = tabCloseDom;
            headerChildDom.appendChild(tabCloseDom);
        }
        callback && callback(obj);
    }
    initActive() {
        if (this.data.length === 0) {
            return false;
        }
        let activeTab = this.data.find(k => k.active) || this.data[0];
        if (this.options.active) {
            this.active(this.options.active);
        } else {
            this.active(activeTab);
        }
        /* 
                if (this.options.active) {
                    this.active(this.options.active);
                } else {
                    let activeTab;
                    if (!this.data.find(k => k.active)) {
                        activeTab = this.data[0];
                        activeTab.active = true;
                        activeTab.labelDom.setAttribute('active', '');
                        activeTab.bodyDom.setAttribute('active', '');
                    } else {
                        let activeTabs = this.data.filter(k => k.active);
                        if (activeTabs.length > 1) {
                            activeTabs.slice(1).forEach(k => {
                                k.active ? delete k.active : null;
                                k.labelDom.hasAttribute('active') ? k.labelDom.removeAttribute('active') : null;
                                k.bodyDom.hasAttribute('active') ? k.bodyDom.revoveAttribute('active') : null;
                            });
                        }
                        activeTab = activeTabs[0];
                    }
                    axIsVnode(activeTab.bodyDom) ? this.bodyWrapperDom.appendChild(activeTab.bodyDom) : null;
                    activeTab.type === 'async' ? this.asyncActive(activeTab) : null;
                } */
    }
    asyncActive(obj, callback) {
        if (obj.bodyDom.innerHTML.trim()) {
            return false;
        }
        if (obj.type === 'async' && obj.content && typeof obj.content === 'string') {
            axAjax({
                url: obj.content,
                type: this.options.ajaxType,
                success: function (content) {
                    obj.bodyDom.innerHTML = content;
                    callback && callback(content);
                }
            }, obj.bodyDom);
        }
    }
    getDropDownData() {
        return this.data.map(k => {
            return { value: k.label, label: k.label }
        })
    }
    createSwiper() {
        if (!this.swiperDom) {
            return false;
        }
        let swiperOpt = this.options.swiper.options;
        if (this.prevDom && this.nextDom) {
            swiperOpt.navigation = { nextEl: this.prevDom, prevEl: this.nextDom };
        }
        this.swiper = new axSwiper(this.swiperDom, swiperOpt);
        if (this.menuDom) {
            setTimeout(() => {
                this.dropdown = new axDropdown(this.menuDom, {
                    arrowShow: false,
                    grid: {
                        enable: this.options.menu.options.columns === 0 || this.options.menu.options.columns === 1 ? false : true,
                        columns: this.options.menu.options.columns,
                        fenceShow: true,
                    },
                    type: 'button',
                    popup: {
                        size: this.options.menu.options.size,
                    },
                    content: this.getDropDownData(),
                });
                this.dropdown.popup.on('show', () => {
                    this.getActive() && this.getActive().label ? this.dropdown.updateValues(this.getActive().label) : null;
                });
                this.dropdown.on('set', (value) => {
                    value || value === 0 ? this.active(value) : null;
                    this.swiper.slideTo(this.getIndexActive());
                });
            }, 0);
        }
    }
    setAttribute() {
        !this.targetDom.classList.contains('ax-tab') ? this.targetDom.classList.add('ax-tab') : null;
        this.options.wrapperClass ? axClass.add(this.targetDom, this.options.wrapperClass) : null;
        this.options.headerClass ? axClass.add(this.headerWrapperDom, this.options.headerClass) : null;
        this.options.bodyClass ? axClass.add(this.bodyWrapperDom, this.options.bodyClass) : null;
    }
    renderFinish() {
        this.data.forEach(k => {
            if (!k.disabled) {
                let triggerDom = k.labelDom ? k.labelDom : k.headerDom;
                triggerDom.addEventListener(this.options.trigger, this.triggerShow, false);
                if (k.updateDom) {
                    k.updateDom.onclick = () => {
                        this.updateContent(k);
                    }
                }
                if (k.closeDom) {
                    k.closeDom.onclick = () => { this.labelClose(k) };
                }
            }
        });
        this.save();
    }
    workToggle(item, type = 'disable') {
        let triggerDom = item.labelDom ? item.labelDom : item.headerDom;
        if (type === 'enable' && item.disabled) {
            delete item.disabled;
            item.headerDom.removeAttribute('disabled');
            item.bodyDom.removeAttribute('disabled');
            triggerDom.addEventListener(this.options.trigger, this.triggerShow, false);
            item.closeDom ? item.closeDom.onclick = () => { this.labelClose(item) } : null;
            item.updateDom ? item.updateDom.onclick = () => { this.updateContent(item) } : null;
        } else if (type === 'disable' && !item.disabled) {
            item.disabled = true;
            item.headerDom.setAttribute('disabled', '');
            item.bodyDom.setAttribute('disabled', '');
            triggerDom.removeEventListener(this.options.trigger, this.triggerShow, false);
            item.closeDom ? item.closeDom.onclick = null : null;
            item.updateDom ? item.updateDom.onclick = null : null;
        }
        this.save();
    }
    getIndexActive() {
        return this.data.findIndex(k => k.active);
    }
    getDisabled() {
        return this.data.filter(k => k.disabled);
    }
    getActive() {
        return this.data.find(k => k.active);
    }
    disable(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        if (obj !== 0 && axIsEmpty(obj)) {
            return false;
        }
        let disableFun = (k) => {
            let item = axFindItem(k, this.data);
            if (item) {
                this.workToggle(item, 'disable');
            }
        }
        if (Array.isArray(obj)) {
            obj.forEach(k => {
                disableFun(k);
            });
        } else {
            disableFun(obj);
        }
        let disableds = this.data.filter(k => k.disabled);
        'disable' in this.handlers ? this.emit('disable', disableds) : null;
        this.options.onDisable && this.options.onDisable.call(this, disableds);
        callback && callback.call(this, disableds);
    }
    disableAll(callback) {
        this.disable(this.data);
        'disableAll' in this.handlers ? this.emit('disableAll', '') : null;
        this.options.onDisableAll && this.options.onDisableAll.call(this);
        callback && callback.call(this);
    }
    enable(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        if (obj !== 0 && axIsEmpty(obj)) {
            return false;
        }
        let enableFun = (k) => {
            let item = axFindItem(k, this.data);
            if (item) {
                this.workToggle(item, 'enable');
            }
        }
        if (Array.isArray(obj)) {
            obj.forEach(k => {
                enableFun(k);
            });
        } else {
            enableFun(obj);
        }
        let enableds = this.data.filter(k => !k.disabled);
        'enable' in this.handlers ? this.emit('enable', enableds) : null;
        this.options.onEnable && this.options.onEnable.call(this, enableds);
        callback && callback.call(this, enableds);
    }
    enableAll(callback) {
        this.enable(this.data);
        'enableAll' in this.handlers ? this.emit('enableAll', '') : null;
        this.options.onEnableAll && this.options.onEnableAll.call(this);
        callback && callback.call(this);
    }
    updateContent(tab, content, callback) {
        if (this.destroyed) {
            return this;
        }
        let me = axFindItem(tab, this.data);
        if (me) {
            me.bodyDom.innerHTML = '';
            content ? me.content = content : null;
            if (me.type === 'url') {
                me.bodyDom.src = content;
            } else if (me.type === 'async') {
                this.asyncActive(me);
            } else if (axType(me.conten).includes('HTML')) {
                me.bodyDom.appendChild(me.content);
            } else {
                me.bodyDom.innerHTML = me.content;
            }
            this.save();
        }
        'updateContent' in this.handlers ? this.emit('updateContent', me) : null;
        this.options.onUpdateContent && this.options.onUpdateContent.call(this, me);
        callback && callback.call(this, me);
    }
    active(tab, callback) {
        if (this.destroyed) {
            return this;
        }
        let findMethod = axType(tab).includes('HTML') && tab.hasAttribute('label') ? axFindItem(tab, this.data, { header: 'labelDom' }) : axFindItem(tab, this.data),
            me = findMethod, others;
        if (!axIsEmpty(me)) {
            !me.active ? me.active = true : null;
            me.headerDom.setAttribute('active', '');
            me.bodyDom.setAttribute('active', '');
            axIsVnode(me.bodyDom) ? this.bodyWrapperDom.appendChild(me.bodyDom) : null;
            me.type === 'async' ? this.asyncActive(me) : null;
            others = this.data.filter(k => k !== me);
            others.forEach(k => {
                k.active ? delete k.active : null;
                k.headerDom.removeAttribute('active');
                k.bodyDom.removeAttribute('active');
            });
            this.save();
        }
        'active' in this.handlers ? this.emit('active', me) : null;
        this.options.onActive && this.options.onActive.call(this, me);
        callback && callback.call(this, me);
    }
    add(data, callback) {
        if (this.destroyed) {
            return this;
        }
        if (axIsEmpty(data)) {
            return false;
        }
        if (this.data.length >= this.options.max && this.options.max !== 0) {
            console.warn('The number of tabs exceeds the maximum!');
            return false;
        }
        let type = axType(data),
            items = [],
            appendFun = (obj) => {
                if (this.data.findIndex(k => k.label === obj.label) === -1) {
                    this.appendItem(obj, () => {
                        this.data.push(obj);
                        items.push(obj);
                    });
                }
            };
        if (type === 'Object') {
            appendFun(data);
        } if (type === 'Array' && data.length > 0) {
            data.forEach(k => {
                appendFun(k);
            });
        }
        if (items.length > 0) {
            this.swiper ? this.swiper.update(true) : null;
            if (this.options.addToActive) {
                this.active(items[items.length - 1]);
                this.swiper ? this.swiper.slideTo(items[items.length - 1]) : null;
            }
            this.renderFinish();
            this.dropdown ? this.dropdown.updateContent(this.getDropDownData()) : null;
        }
        'add' in this.handlers ? this.emit('add', items) : null;
        this.options.onAdd && this.options.onAdd.call(this, items);
        callback && callback.call(this, items);
        return this;
    }
    remove(data, callback) {
        if (this.destroyed) {
            return this;
        }
        if (axIsEmpty(data)) {
            return false;
        }
        if (this.data.length === 0) {
            console.warn('The data is already empty!');
            return false;
        }
        let removeItem = (tab) => {
            let item = axFindItem(tab, this.data);
            if (item) {
                !item.labelDom ? item.headerDom.removeEventListener(this.options.trigger, this.triggerShow, false) : null;
                item.headerDom.remove();
                item.bodyDom.remove();
                this.data = this.data.filter(k => k !== item);
                this.swiper ? this.swiper.update(true) : null;
            }
        };
        if (Array.isArray(data)) {
            data.forEach(k => {
                removeItem(k);
            });
        } else {
            removeItem(data);
        }
        this.save();
        this.swiper ? this.swiper.update(true) : null;
        this.dropdown ? this.dropdown.updateContent(this.getDropDownData()) : null;
        'remove' in this.handlers ? this.emit('remove', '') : null;
        this.options.onRemove && this.options.onRemove.call(this);
        callback && callback.call(this);
        return this;
    }
    save(props, callback) {
        if (this.destroyed) {
            return this;
        }
        if (!this.options.storageName) {
            return false;
        }
        setTimeout(() => {
            let idsActive = this.getIndexActive(),
                idsDisabled = this.data.filter(k => k.disabled).map(k => k.id).filter(Boolean);
            if (!props) {
                axLocalStorage.set(this.options.storageName, { active: idsActive, disabled: idsDisabled, content: this.data });
            } else {
                !props.hasOwnProperty('active') ? props.active = idsActive : null;
                !props.hasOwnProperty('disabled') ? props.disabled = idsDisabled : null;
                !props.hasOwnProperty('content') ? props.content = this.data : null;
                axLocalStorage.set(this.options.storageName, props);
            }
            let getValue = axLocalStorage.get(this.options.storageName);
            'save' in this.handlers ? this.emit('save', getValue) : null;
            this.options.onSave && this.options.onSave.call(this, getValue);
            callback && callback.call(this, getValue);
            return this;
        }, 0)
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options = axExtend(this.options, setting);
        this.options.storageName ? axLocalStorage.set(this.options.storageName, {}) : null;
        this.init();
        'update' in this.handlers ? this.emit('update', '') : null;
        this.options.onUpdate && this.options.onUpdate.call(this);
        callback && callback.call(this);
        return this;
    }
    destroy(callback) {
        this.data.forEach(k => {
            let triggerDom = k.labelDom ? k.labelDom : k.headerDom;
            triggerDom.removeEventListener(this.options.trigger, this.triggerShow);
            k.closeDom ? k.closeDom.onclick = null : null;
            k.updateDom ? k.updateDom.onclick = null : null;
        });
        this.swiper ? this.swiper.destroy() : null;
        this.dropdown ? this.dropdown.popup.destroy() : null;
        this.destroyed = true;
        this.options.storageName ? axLocalStorage.set(this.options.storageName, {}) : null;
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
document.querySelectorAll('[axTab]').forEach(element => {
    new axTab(element);
});
/*!
* 插件：抽屉侧边窗；使用方法：new axDrawer({参数},'#id')；#id是可选参数，可以从该dom获取参数值
*/
class axDrawer {
    constructor(options, elem) {
        this.options = axExtend({
            insName: '',
            title: '',
            titleBreak: true,
            overlay: true,
            overlayClose: true,
            duration: 0,
            placement: 'right',
            size: 'sm',
            padding: 'ax-padding',
            offset: '100px', 
            content: '',
            type: 'html',
            url: '',
            btnClass: 'ax-opened',
            close: true,
            footerType: 'center',
            footerShow: true,
            footerBreak: false,
            note: '',
            ajaxType: 'post',
            preventScroll: true,
            onInit: '',
            onShow: '',
            onShwon: '',
            onHide: '',
            onHidden: '',
            onUpdate: '',
            onUpdated: '',
            onUpdateContent: '',
            onDestroy: '',
            confirm: {
                text: '确定',
                classname: '',
                icon: '',
                type: 'close',
                url: '',
                callback: ''
            },
            cancel: {
                text: '关闭',
                classname: '',
                icon: '',
                callback: ''
            },
            diy: {
                text: '',
                classname: '',
                icon: '',
                url: '',
                target: '',
                callback: ''
            }
        }, options, elem, this.constructor.name);
        this.handlers = {};
        this.form = null;
        elem ? this.button = axIdToDom(elem) : null;
        this.shown = false;
        this.init();
        return this;
    }
    init() {
        let _this = this;
        let subset = axInstance.data.find(i => i.instance === this);
        if (!subset) {
            axInstance.push(this, this.options.insName, 'drawer');
        }
        this.destroyed = false;
        this.renderDom();
        this.setAttribute();
        if (this.options.content.nodeType == 1) {
            this.content.innerHTML = '';
            this.content.appendChild(this.options.content);
            this.form = this.content.querySelector('form');
        } else if (this.options.type == 'form' && typeof this.options.content === 'string' && this.options.content.substr(0, 1) == '#') {
            this.form = document.querySelector(this.options.content).querySelector('form');
            if (this.form) {
                this.content.innerHTML = '';
                this.content.appendChild(this.form);
            } else {
                console.error('Form node is required!');
                return false;
            }
        } else {
            let createContent = axCreateContent(this.options, this, this.options.ajaxType, function () {
                _this.options.preventScroll ? axPreventScroll(_this.wrapper, _this.body) : null;
            });
            this.content.innerHTML = createContent.content;
            this.contentXhr = createContent.xhr;
            this.form = this.content.querySelector('form');
        }
        this.footer.innerHTML = axFooterBtns(this.options, this);
        this.targetDom.querySelectorAll('[confirm]').forEach(elem => {
            elem.onclick = function (e) {
                let button = this;
                if (_this.options.confirm.type == 'submit') {
                    if (_this.form && _this.options.type == 'form') {
                        axValidRepeat(e, axValids, _this.form, function () {
                            _this.form.submit();
                        });
                        _this.options.confirm.callback && _this.options.confirm.callback.call(_this, button, '');
                    } else {
                        console.error('Form node is required and type of options must be form string!');
                        return false;
                    }
                } else if (_this.options.confirm.type == 'async') {
                    if (_this.form && _this.options.type == 'form' && _this.options.confirm.url) {
                        axValidRepeat(e, axValids, _this.form, function () {
                            _this.submitXhr = axAjaxSubmit(_this.options.confirm.url, _this.form, button, _this.options.ajaxType, function (content) {
                                _this.options.confirm.callback && _this.options.confirm.callback.call(_this, button, content);
                            });
                        });
                    } else {
                        console.error('Form node is required & type of options must be form string & url of async is required!');
                        return false;
                    }
                } else if (_this.options.confirm.type == 'prevent') {
                    axPreventDefault(e);
                    _this.options.confirm.callback && _this.options.confirm.callback.call(_this, button, '');
                } else {
                    _this.hide();
                    _this.options.confirm.callback && _this.options.confirm.callback.call(_this, button, '');
                }
            };
        });
        this.targetDom.querySelectorAll('[diy]').forEach(elem => {
            elem.onclick = function () {
                _this.options.diy.callback && _this.options.diy.callback.call(_this, elem);
            };
        });
        this.targetDom.querySelectorAll('[cancel]').forEach(elem => {
            elem.onclick = function () {
                _this.hide();
                _this.options.cancel.callback && _this.options.cancel.callback.call(_this, elem);
            };
        });
        this.targetDom.querySelectorAll('[close]').forEach(elem => {
            elem.addEventListener('click', function () {
                _this.hide();
            }, false);
        });
        if (this.button) {
            this.button.onclick = () => {
                this.show();
            }
        }
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    createTemplate() {
        return `
                    <div class="ax-drawer" data-overlay="true" id="${axCreateId('drawer')}">
                        <# if(this.overlay){ #><div class="ax-drawer-overlay" <# if(this.overlayClose){ #>close<# } #>></div><# } #>
                        <div class="ax-drawer-wrapper">
                            <# if(this.close){ #> <a href="###" class="ax-drawer-close" close><i class="ax-iconfont ax-icon-close"></i></a><# } #>
                            <# if(this.title){ #><div class="ax-drawer-header"><div class="ax-col ax-align-center"><# this.title #></div></div><# } #>
                            <# if(this.title && this.titleBreak){ #><div class="ax-break-line"></div><# } #>
                            <div class="ax-drawer-body">
                                <# if(this.padding){ #><div class="<# this.padding #>" <# if(this.type == 'iframe'){ #>style="height:100%;"<# } #>> <# } #>
                                    <div class="ax-drawer-content" <# if(this.type == 'iframe'){ #>style="height:100%;"<# } #>><# this.content #></div>
                                <# if(this.padding){ #></div><# } #>
                            </div>
                            <div class="ax-drawer-footer">
                            </div>
                        </div>
                    </div>
                  `;
    }
    renderDom() {
        this.template = axTplEngine(this.createTemplate(), this.options);
        this.targetDom = axStrToDom(this.template);
        this.wrapper = this.targetDom.querySelector('.ax-drawer-wrapper');
        this.targetDom.querySelector('.ax-drawer-overlay') ? this.overlay = this.targetDom.querySelector('.ax-drawer-overlay') : null;
        this.content = this.targetDom.querySelector('.ax-drawer-content');
        this.body = this.targetDom.querySelector('.ax-drawer-body');
        this.targetDom.querySelector('.ax-drawer-footer') ? this.footer = this.targetDom.querySelector('.ax-drawer-footer') : null;
        this.width = window.getComputedStyle(this.wrapper).width;
        this.height = window.getComputedStyle(this.wrapper).height;
        this.left = window.getComputedStyle(this.wrapper).left;
        this.right = window.getComputedStyle(this.wrapper).right;
        this.top = window.getComputedStyle(this.wrapper).top;
        this.bottom = window.getComputedStyle(this.wrapper).bottom;
    }
    setAttribute() {
        if (this.options.placement == "left") {
            this.targetDom.setAttribute('data-placement', 'left');
        } else if (this.options.placement == "right") {
            this.targetDom.setAttribute('data-placement', 'right');
        } else if (this.options.placement == "top") {
            this.targetDom.setAttribute('data-placement', 'top');
        } else if (this.options.placement == "bottom") {
            this.targetDom.setAttribute('data-placement', 'bottom');
        } else {
            return;
        }
        if (this.options.size == "sm") {
            this.targetDom.setAttribute('data-size', 'sm');
        } else if (this.options.size == 'md') {
            this.targetDom.setAttribute('data-size', 'md');
        } else if (this.options.size == 'lg') {
            this.targetDom.setAttribute('data-size', 'lg');
        } else {
            return;
        }
    }
    show(callback) {
        if (this.destroyed || this.shown) {
            return this;
        }
        document.body.appendChild(this.targetDom);
        this.options.preventScroll ? axPreventScroll(this.wrapper, this.body) : null;
        if (this.options.duration) {
            this.duration = this.options.duration;
        } else {
            this.duration = parseFloat(axStyle(this.wrapper).animationDuration) * 1000
        }
        this.options.onShow && this.options.onShow.call(this);
        'show' in this.handlers ? this.emit('show', '') : null;
        axInstance.data.filter(i => i.type === 'drawer' && !i.instance.destroyed).forEach(item => {
            if (item.instance.isShow && item.instance.options.placement == this.options.placement) {
                let wrapper = item.instance.targetDom.querySelector('.ax-drawer-wrapper');
                switch (this.options.placement) {
                    case 'left':
                        !wrapper.style.left ? wrapper.style.left = this.options.offset : wrapper.style.left = parseInt(wrapper.style.left) + parseInt(this.options.offset) + 'px';
                        break;
                    case 'right':
                        !wrapper.style.right ? wrapper.style.right = this.options.offset : wrapper.style.right = parseInt(wrapper.style.right) + parseInt(this.options.offset) + 'px';
                        break;
                    case 'top':
                        !wrapper.style.top ? wrapper.style.top = this.options.offset : wrapper.style.top = parseInt(wrapper.style.top) + parseInt(this.options.offset) + 'px';
                        break;
                    case 'bottom':
                        !wrapper.style.bottom ? wrapper.style.bottom = this.options.offset : wrapper.style.bottom = parseInt(wrapper.style.bottom) + parseInt(this.options.offset) + 'px';
                        break;
                    default:
                        null;
                }
            }
        });
        this.targetDom.classList.add("ax-show");
        this.button ? this.button.classList.add(this.options.btnClass) : null;
        this.shown = true;
        setTimeout(() => {
            this.options.onShown && this.options.onShown.call(this);
            'shown' in this.handlers ? this.emit('shown', '') : null;
        }, this.duration);
        callback && callback.call(this);
        return this;
    }
    hide(callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onHide && this.options.onHide.call(this);
        'hide' in this.handlers ? this.emit('hide', '') : null;
        this.button ? this.button.classList.remove(this.options.btnClass) : null;
        let timeHide = (instance) => {
            let overlay = instance.targetDom.querySelector('.ax-drawer-overlay'),
                wrapper = instance.targetDom.querySelector('.ax-drawer-wrapper');
            overlay.style.opacity = 0;
            switch (instance.options.placement) {
                case 'left':
                    wrapper.style.left = '-' + getComputedStyle(wrapper).width;
                    break;
                case 'right':
                    wrapper.style.right = '-' + getComputedStyle(wrapper).width;
                    break;
                case 'top':
                    wrapper.style.top = '-' + getComputedStyle(wrapper).height;
                    break;
                case 'bottom':
                    wrapper.style.bottom = '-' + getComputedStyle(wrapper).height;
                    break;
                default:
                    null;
            }
            this.shown = false;
            setTimeout(() => {
                instance.targetDom.classList.remove("ax-show");
                overlay.removeAttribute("style");
                wrapper.removeAttribute("style");
                this.targetDom.remove();
                this.options.onHidden && this.options.onHidden.call(this);
                'hidden' in this.handlers ? this.emit('hidden', '') : null;
            }, this.duration);
        };
        timeHide(this);
        axInstance.data.filter(i => i.type === 'drawer' && !i.instance.destroyed).forEach(item => {
            if (item.instance.targetDom.classList.contains('ax-show') && item.instance.options.placement == this.options.placement) {
                let wrapper = item.instance.targetDom.querySelector('.ax-drawer-wrapper');
                switch (this.options.placement) {
                    case 'left':
                        wrapper.style.left = parseInt(wrapper.style.left) - parseInt(this.options.offset) + 'px';
                        break;
                    case 'right':
                        wrapper.style.right = parseInt(wrapper.style.right) - parseInt(this.options.offset) + 'px';
                        break;
                    case 'top':
                        wrapper.style.top = parseInt(wrapper.style.top) - parseInt(this.options.offset) + 'px';
                        break;
                    case 'bottom':
                        wrapper.style.bottom = parseInt(wrapper.style.bottom) - parseInt(this.options.offset) + 'px';
                        break;
                    default:
                        null;
                }
            }
        });
        this.targetDom.querySelectorAll('video,audio').forEach(elem => {
            elem.pause();
        });
        this.button ? this.button.classList.remove(this.options.btnClass) : null;
        callback && callback.call(this);
        return this;
    }
    destroy(callback) {
        this.targetDom.remove();
        this.button.onclick = null;
        this.contentXhr ? this.contentXhr.abort() : null;
        this.submitXhr ? this.submitXhr.abort() : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.destroyed = true;
        callback && callback.call(this);
        return this;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let targetDom = this.targetDom,
            before = axClone(this.options),
            after = axExtend(this.options, setting),
            isUpdated = false;
        if (setting && JSON.stringify(after) != JSON.stringify(before)) {
            this.options = after;
            if (this.shown) {
                this.init().show();
            } else {
                this.init();
            }
            targetDom.remove();
            isUpdated = true;
        }
        callback && callback.call(this, isUpdated, before, after);
        this.options.onUpdated && this.options.onUpdated.call(this, isUpdated, before, after);
        'updated' in this.handlers ? this.emit('updated', isUpdated, before, after) : null;
        return this;
    }
    updateContent(data, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let before = this.content.innerHTML,
            isUpdated = false;
        if (axType(data) === 'String') {
            if (axStrType(data)) {
                this.content.innerHTML = axIdToDom(data) ? axIdToDom(data).innerHTML : '';
            } else {
                this.content.innerHTML = data;
            }
        } else if (axType(data).includes('HTML')) {
            this.content.innerHTML = '';
            this.content.appendChild(data);
        } else {
            this.content.innerHTML = `No data to update!`;
        }
        if (this.content.innerHTML == before) {
            isUpdated = false;
        } else {
            isUpdated = true;
        }
        callback && callback.call(this, isUpdated, before, this.content.innerHTML);
        this.options.onUpdateContent && this.options.onUpdateContent.call(this, isUpdated, before, this.content.innerHTML);
        'updateContent' in this.handlers ? this.emit('updateContent', isUpdated, before, this.content.innerHTML) : null;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    function eachInstance(arr, parent) {
        arr.forEach(elem => {
            let instance = new axDrawer('', elem);
            parent ? instance.targetDom.style.zIndex = parseInt(getComputedStyle(parent.targetDom).zIndex) + 1 : null;
            eachInstance(instance.targetDom.querySelectorAll('[axDrawer]'), instance);
        });
    }
    let arrInstance = document.querySelectorAll('[axDrawer]');
    eachInstance(arrInstance);
})();
/*!
 * 插件：对话弹窗；使用方法：new axDialog({参数},'#id')；#id是可选参数，可以从该dom获取参数值
 */
class axDialog {
    constructor(options, elem) {
        this.options = axExtend({
            insName: '',
            title: '',
            titleBreak: false,
            overlay: true,
            overlayClose: true,
            duration: 0,
            in: 'springIn',
            out: 'scaleOut',
            multiple: true,
            size: 'md',
            padding: 'ax-padding',
            drag: false,
            content: '',
            type: 'html',
            url: '',
            btnClass: 'ax-opened',
            name: '',
            width: '',
            height: '',
            close: true,
            closePlace: 'inside',
            footerShow: true,
            footerType: 'center',
            footerBreak: false,
            note: '',
            ajaxType: 'post',
            preventScroll: true,
            onDrag: '',
            onDragged: '',
            onInit: '',
            onShow: '',
            onShwon: '',
            onHide: '',
            onHidden: '',
            onUpdate: '',
            onUpdated: '',
            onUpdateContent: '',
            onDestroy: '',
            confirm: {
                text: '确定',
                classname: '',
                icon: '',
                type: 'close',
                url: '',
                callback: ''
            },
            cancel: {
                text: '关闭',
                classname: '',
                icon: '',
                callback: ''
            },
            diy: {
                text: '',
                classname: '',
                icon: '',
                url: '',
                target: '',
                callback: ''
            }
        }, options, elem, this.constructor.name);
        this.wrapper = '';
        this.content = '';
        this.overlay = '';
        this.handlers = {};
        this.wrapPosition = '';
        this.wrapLeft = '';
        this.wrapTop = '';
        this.form = null;
        elem ? this.button = axIdToDom(elem) : null;
        this.shown = false;
        this.init();
        return this;
    }
    init() {
        let _this = this;
        let subset = axInstance.data.find(i => i.instance === this);
        if (!subset) {
            axInstance.push(this, this.options.insName, 'dialog');
        }
        this.destroyed = false;
        this.renderDom();
        this.setAttribute();
        if (this.options.content.nodeType == 1) {
            this.content.innerHTML = '';
            this.content.appendChild(this.options.content);
            this.form = this.content.querySelector('form');
        } else if (this.options.type == 'form' && typeof this.options.content === 'string' && this.options.content.substr(0, 1) == '#') {
            this.form = document.querySelector(this.options.content).querySelector('form');
            if (this.form) {
                this.content.innerHTML = '';
                this.content.appendChild(this.form);
            } else {
                console.error('Form node is required!');
                return false;
            }
        } else {
            let createContent = axCreateContent(this.options, this, this.options.ajaxType, function () {
                _this.options.preventScroll ? axPreventScroll(_this.wrapper, _this.body) : null;
            })
            this.content.innerHTML = createContent.content;
            this.contentXhr = createContent.xhr;
            this.form = this.content.querySelector('form');
        }
        this.footer.innerHTML = axFooterBtns(this.options, this);
        if (this.options.drag) {
            this.drag();
        }
        this.targetDom.querySelectorAll('[confirm]').forEach(elem => {
            elem.onclick = function (e) {
                let button = this;
                if (_this.options.confirm.type == 'submit') {
                    if (_this.form && _this.options.type == 'form') {
                        axValidRepeat(e, axValids, _this.form, function () {
                            _this.form.submit();
                        });
                        _this.options.confirm.callback && _this.options.confirm.callback.call(_this, button, '');
                    } else {
                        console.error('Form node is required and type of options must be form string!');
                        return false;
                    }
                } else if (_this.options.confirm.type == 'async') {
                    if (_this.form && _this.options.type == 'form' && _this.options.confirm.url) {
                        axValidRepeat(e, axValids, _this.form, function () {
                            _this.submitXhr = axAjaxSubmit(_this.options.confirm.url, _this.form, button, _this.options.ajaxType, function (content) {
                                _this.options.confirm.callback && _this.options.confirm.callback.call(_this, button, content);
                            });
                        })
                    } else {
                        console.error('Form node is required & type of options must be form string & url of async is required!');
                        return false;
                    }
                } else if (_this.options.confirm.type == 'prevent') {
                    axPreventDefault(e);
                    _this.options.confirm.callback && _this.options.confirm.callback.call(_this, button, '');
                } else {
                    _this.hide();
                    _this.options.confirm.callback && _this.options.confirm.callback.call(_this, button, '');
                }
            };
        });
        this.targetDom.querySelectorAll('[diy]').forEach(elem => {
            elem.onclick = function () {
                _this.options.diy.callback && _this.options.diy.callback.call(_this, elem);
            };
        });
        this.targetDom.querySelectorAll('[cancel]').forEach(elem => {
            elem.onclick = function () {
                _this.hide();
                _this.options.cancel.callback && _this.options.cancel.callback.call(_this, elem);
            };
        });
        this.targetDom.querySelectorAll('[close]').forEach(elem => {
            elem.addEventListener('click', function () {
                _this.hide();
            }, false);
        });
        if (this.button) {
            this.button.onclick = () => {
                this.show();
            }
        }
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    createTemplate() {
        return `
        <div class="ax-dialog" data-overlay="true" id="${axCreateId('dialog')}">
        <# if(this.overlay){ #><div class="ax-dialog-overlay" <# if(this.overlayClose){ #>close<# } #>></div><# } #>
            <div class="ax-dialog-wrapper">
                <# if(this.close){ #><a href="###" class="ax-dialog-close" close><i class="ax-iconfont ax-icon-close"></i></a><# } #>
                <# if(this.title){ #><div class="ax-dialog-header"><# this.title #></div><# } #>
                <# if(this.titleBreak){ #><div class="ax-break-line"></div><# } #>
                <div class="ax-dialog-body">
                    <# if(typeof this.padding == 'string'){ #><div class="<# this.padding #>"> <# }else if(this.padding){ #><div class="ax-padding"> <# } #>
                    <div class="ax-dialog-content"><# this.content #></div>
                    <# if(this.padding){ #></div><# } #>
                </div>
                <div class="ax-dialog-footer">
                </div>
            </div>
        </div>
      `
    }
    renderDom() {
        this.template = axTplEngine(this.createTemplate(), this.options);
        this.targetDom = axStrToDom(this.template);
        this.wrapper = this.targetDom.querySelector('.ax-dialog-wrapper');
        this.header = this.targetDom.querySelector('.ax-dialog-header');
        this.content = this.targetDom.querySelector('.ax-dialog-content');
        this.body = this.targetDom.querySelector('.ax-dialog-body');
        this.overlay = this.targetDom.querySelector('.ax-dialog-overlay');
        this.footer = this.targetDom.querySelector('.ax-dialog-footer');
    }
    setAttribute() {
        this.options.size ? this.targetDom.setAttribute('data-size', this.options.size) : null;
        this.options.footerType ? this.targetDom.setAttribute('data-footerType', this.options.footerType) : null;
        this.options.height ? this.content.style.height = this.options.height : null;
        this.oldStyle = this.options.width ? `width:${this.options.width};` : null;
        this.options.type ? this.targetDom.setAttribute('data-type', this.options.type) : null;
        !this.options.overlay ? this.targetDom.setAttribute('data-overlay', 'false') : null;
        if (!this.options.title && this.options.close) {
            if (this.options.size == 'lg') {
                this.targetDom.setAttribute('data-closePlace', 'bottom');
            } else if (!this.options.title && this.options.closePlace == 'inside') {
                this.targetDom.setAttribute('data-closePlace', 'outside');
            } else {
                this.targetDom.setAttribute('data-closePlace', this.options.closePlace)
            }
        } else if (this.options.closePlace && this.options.close) {
            this.targetDom.setAttribute('data-closePlace', this.options.closePlace)
        }
    }
    drag(callback) {
        if (this.destroyed) {
            return false;
        }
        if (this.options.title) {
            let _this = this,
                header = this.targetDom.querySelector('.ax-dialog-header');
            this.targetDom.setAttribute('data-drag', this.options.drag);
            header.onmousedown = function (e) {
                _this.options.onDrag && _this.options.onDrag.call(this);
                'drag' in _this.handlers ? _this.emit('drag', '') : null;
                this.style.cursor = 'move';
                let moveDiv = this.parentNode;
                moveDiv.style.cssText += 'position:fixed ;';
                _this.wrapPosition = 'fixed';
                let x = e.clientX - moveDiv.offsetLeft;
                let y = e.clientY - moveDiv.offsetTop;
                document.onmousemove = function (ev) {
                    let _x = ev.clientX - x;
                    let _y = ev.clientY - y;
                    let maxX = document.documentElement.clientWidth - moveDiv.clientWidth;
                    let maxY = document.documentElement.clientHeight - moveDiv.clientHeight;
                    if (_x < 0) {
                        _x = 0;
                    }
                    if (_x > maxX) {
                        _x = maxX;
                    }
                    if (_y < 0) {
                        _y = 0;
                    }
                    if (_y > maxY) {
                        _y = maxY;
                    }
                    moveDiv.style.left = _x + 'px';
                    moveDiv.style.top = _y + 'px';
                    _this.wrapLeft = moveDiv.style.left;
                    _this.wrapTop = moveDiv.style.top;
                };
            };
            header.onmouseup = function () {
                document.onmousemove = null;
                document.onmouseup = null;
                _this.options.onDragged && _this.options.onDragged.call(this);
                'dragged' in _this.handlers ? _this.emit('dragged', '') : null;
            }
            header.ondragstart = function (ev) {
                axPreventDefault(ev);
            };
            header.ondragend = function (ev) {
                axPreventDefault(ev);
            };
            callback && callback.call(this);
        } else {
            return false;
        }
        return this;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let targetDom = this.targetDom,
            before = axClone(this.options),
            after = axExtend(this.options, setting),
            isUpdated = false;
        if (setting && JSON.stringify(after) != JSON.stringify(before)) {
            this.options = after;
            if (this.shown) {
                this.init().show();
            } else {
                this.init();
            }
            targetDom.remove();
            isUpdated = true;
        }
        callback && callback.call(this, isUpdated, before, after);
        this.options.onUpdated && this.options.onUpdated.call(this, isUpdated, before, after);
        'updated' in this.handlers ? this.emit('updated', isUpdated, before, after) : null;
        return this;
    }
    updateContent(data, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let before = this.content.innerHTML,
            isUpdated = false;
        if (axType(data) === 'String') {
            if (axStrType(data)) {
                this.content.innerHTML = axIdToDom(data) ? axIdToDom(data).innerHTML : '';
            } else {
                this.content.innerHTML = data;
            }
        } else if (axType(data).includes('HTML')) {
            this.content.innerHTML = '';
            this.content.appendChild(data);
        } else {
            this.content.innerHTML = `No data to update!`;
        }
        if (this.content.innerHTML == before) {
            isUpdated = false;
        } else {
            isUpdated = true;
        }
        callback && callback.call(this, isUpdated, before, this.content.innerHTML);
        this.options.onUpdateContent && this.options.onUpdateContent.call(this, isUpdated, before, this.content.innerHTML);
        'updateContent' in this.handlers ? this.emit('updateContent', isUpdated, before, this.content.innerHTML) : null;
        return this;
    }
    destroy(callback) {
        this.targetDom.remove();
        this.button.onclick = null;
        this.contentXhr ? this.contentXhr.abort() : null;
        this.submitXhr ? this.submitXhr.abort() : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.destroyed = true;
        callback && callback.call(this);
        return this;
    }
    show(callback) {
        if (this.destroyed || this.shown) {
            return this;
        }
        document.body.appendChild(this.targetDom);
        this.options.preventScroll ? axPreventScroll(this.wrapper, this.body) : null;
        this.wrapperHeight = axArrHeight(this.wrapper).height;
        if (this.options.duration) {
            this.duration = this.options.duration;
        } else if (this.wrapperHeight) {
            this.duration = Math.floor(this.wrapperHeight / 3 + 250);
        } else {
            this.duration = parseFloat(axStyle(this.wrapper).animationDuration) * 1000
        }
        if (!this.options.multiple) {
            let items = axInstance.data.filter(i => i.type.dialog && i.instance !== this && i.instance.isShow)
            items.forEach(i => {
                i.instance.hide();
            });
        }
        this.options.onShow && this.options.onShow.call(this);
        'show' in this.handlers ? this.emit('show', '') : null;
        this.targetDom.classList.remove('ax-hide');
        this.targetDom.classList.add('ax-show');
        this.button ? this.button.classList.add(this.options.btnClass) : null;
        let dragStyle = '';
        this.wrapPosition ? dragStyle = `position:${this.wrapPosition};left:${this.wrapLeft};top:${this.wrapTop};` : null;
        if (this.options.in == 'slideDown') {
            axHeightDown(this.wrapper, { height: this.wrapperHeight }, '', this.duration);
        } else {
            this.options.duration ? this.targetDom.style.animationDuration = `${this.options.duration}ms` : null;
            this.options.in ? this.wrapper.style.cssText = `animation-name: ${this.options.in};${dragStyle};${this.oldStyle}` : null;
        }
        this.shown = true;
        setTimeout(() => {
            this.options.onShown && this.options.onShown.call(this);
            'shown' in this.handlers ? this.emit('shown', '') : null;
        }, this.duration);
        callback && callback.call(this);
        return this;
    }
    hide(callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onHide && this.options.onHide.call(this);
        'hide' in this.handlers ? this.emit('hide', '') : null;
        let _this = this;
        this.button ? this.button.classList.remove(this.options.btnClass) : null;
        this.options.duration ? this.targetDom.style.animationDuration = this.options.duration : null;
        this.targetDom.classList.add('ax-hide');
        let dragStyle = '';
        this.wrapPosition ? dragStyle = `position:${this.wrapPosition};left:${this.wrapLeft};top:${this.wrapTop};` : null;
        if (this.options.out == 'slideUp') {
            axHeightUp(_this.wrapper, { height: this.wrapperHeight }, '', this.duration);
        } else {
            this.options.out ? this.wrapper.style.cssText = `animation-name: ${this.options.out};${dragStyle};${this.oldStyle}` : null;
        }
        this.targetDom.querySelectorAll('video,audio').forEach(elem => {
            elem.pause();
        });
        this.shown = false;
        setTimeout(() => {
            this.targetDom.classList.remove('ax-show');
            this.targetDom.remove();
            this.options.onHidden && this.options.onHidden.call(this);
            'hidden' in this.handlers ? this.emit('hidden', '') : null;
            this.wrapper.style.cssText = this.oldStyle;
        }, this.duration);
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    function eachInstance(arr, parent) {
        arr.forEach(elem => {
            let instance = new axDialog('', elem);
            parent ? instance.targetDom.style.zIndex = parseInt(getComputedStyle(parent.targetDom).zIndex) + 1 : null;
            eachInstance(instance.targetDom.querySelectorAll('[axDialog]'), instance);
        });
    }
    let arrInstance = document.querySelectorAll('[axDialog]');
    eachInstance(arrInstance);
})();
/*!
* 插件：气泡定位；使用方法：new axPopupPosition(btnDom, boxDom,{参数})
*/
class axPopupPosition {
    constructor(btnDom, boxDom, options) {
        if (!btnDom || !boxDom) {
            return false;
        }
        this.btnDom = axIdToDom(btnDom);
        this.boxDom = axIdToDom(boxDom);
        this.options = axExtend({
            placement: 'top',
            arrowShow: true, 
            arrowOffset: '2.8rem',
            gap: '.8rem',
            observer: document.body,
            onInit: '',
            onUpdated: '',
        }, options);
        this.handlers = {};
        this.gap = this.strToNum(this.options.gap);
        this.observer = axIdToDom(this.options.observer);
        this.placement = this.options.placement;
        this.init();
    }
    init() {
        if (this.placement !== 'center') {
            this.createArrow();
        }
        this.setAttribute();
        this.resetPlacement();
        window.addEventListener("resize", () => {
            this.resetPlacement();
        });
        window.addEventListener('scroll', () => {
            this.resetPlacement();
        });
        new MutationObserver(() => {
            if (!this.unsettable('btn') && this.btnData) {
                if (axOffset(this.btnDom).left !== this.btnData.left || axOffset(this.btnDom).top !== this.btnData.top) {
                    this.resetPlacement();
                }
            }
        }).observe(this.observer, {
            childList: true, 
            subtree: true, 
            characterData: true, 
        });
        this.options.onInit && this.options.onInit.call(this, this.placement);
        return this;
    }
    strToNum(str) {
        if (!str) {
            return 0;
        }
        let num;
        if (str.endsWith('rem') || str.endsWith('REM')) {
            num = str.replace('rem', '').replace('REM', '') * 10;
        } else if (str.endsWith('px') || str.endsWith('PX')) {
            num = ~~str.replace('px', '').replace('PX', '');
        } else {
            num = ~~str;
        }
        return num;
    }
    setAttribute() {
        if (getComputedStyle(this.boxDom).position !== 'absolute') {
            this.boxDom.style.position = 'absolute';
        }
    }
    createArrow() {
        if (this.options.arrowShow) {
            this.arrow = axAddElem('i', { style: 'position:absolute', arrow: '' });
            this.boxDom.appendChild(this.arrow);
        }
    }
    setArrow(placement) {
        let exceedWidth = this.btnData.width > this.boxData.width / 2,
            exceedHeight = this.btnData.height > this.boxData.height / 2,
            arrowHalf = this.strToNum(getComputedStyle(this.arrow).width) / 2;
        this.boxDom.setAttribute('placement', placement);
        if (placement.includes('top') || placement.includes('bottom')) {
            if (placement.includes('start')) {
                if (!exceedWidth) {
                    this.arrow.style.left = Math.floor(this.btnData.width / 2 - arrowHalf) + 'px';
                    this.arrow.style.right = 'auto';
                } else {
                    this.arrow.style.left = this.options.arrowOffset;
                    this.arrow.style.right = 'auto';
                }
            } else if (placement.includes('end')) {
                if (!exceedWidth) {
                    this.arrow.style.left = 'auto';
                    this.arrow.style.right = Math.floor(this.btnData.width / 2 - arrowHalf) + 'px';
                } else {
                    this.arrow.style.left = 'auto';
                    this.arrow.style.right = this.options.arrowOffset;
                }
            } else {
                this.arrow.style.left = this.boxData.width / 2 - 1 - arrowHalf + 'px';
            }
        } else if (placement.includes('left') || placement.includes('right')) {
            if (placement.includes('start')) {
                if (!exceedHeight) {
                    this.arrow.style.top = Math.floor(this.btnData.height / 2 - arrowHalf) + 'px';
                    this.arrow.style.bottom = 'auto';
                } else {
                    this.arrow.style.top = this.options.arrowOffset;
                    this.arrow.style.bottom = 'auto';
                }
            } else if (placement.includes('end')) {
                if (!exceedHeight) {
                    this.arrow.style.top = 'auto';
                    this.arrow.style.bottom = Math.floor(this.btnData.height / 2 - arrowHalf) + 'px';
                } else {
                    this.arrow.style.top = 'auto';
                    this.arrow.style.bottom = this.options.arrowOffset;
                }
            } else {
                this.arrow.style.top = this.boxData.height / 2 - 1 - arrowHalf + 'px';
            }
        }
    }
    getRectData() {
        this.browserData = {
            width: document.documentElement.clientWidth,
            height: document.documentElement.clientHeight
        }
        this.btnData = {
            width: this.btnDom.getBoundingClientRect().width,
            height: this.btnDom.getBoundingClientRect().height,
            offsetLeft: this.btnDom.getBoundingClientRect().left,
            offsetLeftAlt: this.btnDom.getBoundingClientRect().right,
            offsetRight: this.browserData.width - this.btnDom.getBoundingClientRect().right,
            offsetTop: this.btnDom.getBoundingClientRect().top,
            offsetTopAlt: this.btnDom.getBoundingClientRect().bottom,
            offsetBottom: this.browserData.height - this.btnDom.getBoundingClientRect().bottom,
            ...axOffset(this.btnDom)
        };
        this.boxData = {
            width: this.boxDom.getBoundingClientRect().width,
            height: this.boxDom.getBoundingClientRect().height,
            offsetLeft: this.boxDom.getBoundingClientRect().left,
            offsetLeftAlt: this.boxDom.getBoundingClientRect().right,
            offsetRight: this.browserData.width - this.boxDom.getBoundingClientRect().right,
            offsetTop: this.boxDom.getBoundingClientRect().top,
            offsetTopAlt: this.boxDom.getBoundingClientRect().bottom,
            offsetBottom: this.browserData.height - this.boxDom.getBoundingClientRect().bottom
        };
    }
    setPlacement(placement) {
        let [left, right, top, bottom] = ['auto', 'auto', 'auto', 'auto'];
        if (placement.includes('bottom')) {
            if (placement === 'bottom') {
                left = this.btnData.left - (this.boxData.width - this.btnData.width) / 2;
            } else if (placement === 'bottom-start') {
                left = this.btnData.left
            } else if (placement === 'bottom-end') {
                left = this.btnData.left + this.btnData.width - this.boxData.width;
            }
            top = `${Math.ceil(this.btnData.top + this.btnData.height + this.gap)}px`;
            left = `${Math.ceil(left)}px`;
        } else if (placement.includes('top')) {
            if (placement === 'top') {
                left = this.btnData.left - (this.boxData.width - this.btnData.width) / 2;
            } else if (placement === 'top-start') {
                left = this.btnData.left
            } else if (placement === 'top-end') {
                left = this.btnData.left + this.btnData.width - this.boxData.width;
            }
            bottom = this.browserData.height - this.btnData.top + this.gap;
            bottom = `${Math.ceil(bottom)}px`;
            left = `${Math.ceil(left)}px`;
        } else if (placement.includes('left')) {
            if (placement === 'left') {
                top = `${Math.ceil(this.btnData.top - (this.boxData.height - this.btnData.height) / 2)}px`;
            } else if (placement === 'left-start') {
                top = `${Math.ceil(this.btnData.top)}px`;
            } else if (placement === 'left-end') {
                bottom = `${Math.ceil(this.browserData.height - this.btnData.top - this.btnData.height)}px`;
            }
            right = `${Math.ceil(this.browserData.width - this.btnData.left + this.gap)}px`;
        } else if (placement.includes('right')) {
            if (placement === 'right') {
                top = `${Math.ceil(this.btnData.top - (this.boxData.height - this.btnData.height) / 2)}px`;
            } else if (placement === 'right-start') {
                top = `${Math.ceil(this.btnData.top)}px`;
            } else if (placement === 'right-end') {
                bottom = `${Math.ceil(this.browserData.height - this.btnData.top - this.btnData.height)}px`;
            }
            left = `${Math.ceil(this.btnData.left + this.btnData.width + this.gap)}px`;
        } else if (placement === 'center') {
            this.boxDom.style.position = 'fixed';
            this.boxDom.style.marginLeft = `-${Math.ceil(this.boxData.width / 2)}px`;
            this.boxDom.style.marginTop = `-${Math.ceil(this.boxData.height / 2)}px`;
            left = '50%';
            top = '50%';
        }
        this.boxDom.style.left = left;
        this.boxDom.style.right = right;
        this.boxDom.style.top = top;
        this.boxDom.style.bottom = bottom;
        if (this.arrow) {
            this.setArrow(placement);
        }
    }
    getRectOffset() {
        let left = this.btnData.offsetLeft - this.boxData.width - this.gap,
            top = this.btnData.offsetTop - this.boxData.height - this.gap,
            right = this.browserData.width - this.btnData.offsetLeftAlt - this.boxData.width - this.gap,
            bottom = this.browserData.height - this.btnData.offsetTopAlt - this.boxData.height - this.gap,
            startTop = this.btnData.offsetTop,
            startBottom = this.browserData.height - (startTop + this.boxData.height),
            centerTop = this.btnData.offsetTop - (this.boxData.height - this.btnData.height) / 2,
            centerBottom = this.browserData.height - (centerTop + this.boxData.height),
            endTop = this.btnData.offsetTopAlt - this.boxData.height,
            endBottom = this.browserData.height - this.btnData.offsetTopAlt,
            startLeft = this.btnData.offsetLeft,
            startRight = this.browserData.width - (startLeft + this.boxData.width),
            centerLeft = this.btnData.offsetLeft - (this.boxData.width - this.btnData.width) / 2,
            centerRight = this.browserData.width - (centerLeft + this.boxData.width),
            endLeft = this.btnData.offsetLeftAlt - this.boxData.width,
            endRight = this.browserData.width - this.btnData.offsetLeftAlt;
        return {
            left: left,
            right: right,
            top: top,
            bottom: bottom,
            startTop: startTop,
            startBottom: startBottom,
            centerTop: centerTop,
            centerBottom: centerBottom,
            endTop: endTop,
            endBottom: endBottom,
            startLeft: startLeft,
            startRight: startRight,
            centerLeft: centerLeft,
            centerRight: centerRight,
            endLeft: endLeft,
            endRight: endRight
        };
    }
    edgeResponse(pos, arr) {
        let placement;
        if (arr.length === 1) {
            if (arr[0].name === 'center') {
                placement = pos;
            } else {
                placement = `${pos}-${arr[0].name}`;
            }
        } else if (arr.length === 2) {
            if (pos === 'top' || pos === 'bottom') {
                if (this.btnData.offsetLeft === this.boxData.offsetLeft && this.boxData.offsetLeft < this.boxData.offsetRight) {
                    placement = `${pos}-start`;
                } else if (this.btnData.offsetLeftAlt === this.boxData.offsetLeftAlt && this.boxData.offsetLeft > this.boxData.offsetRight) {
                    placement = `${pos}-end`;
                } else {
                    placement = `${pos}-end`;
                }
            }
            if (pos === 'left' || pos === 'right') {
                if (this.btnData.offsetTop === this.boxData.offsetTop && this.boxData.offsetTop < this.boxData.offsetBottom) {
                    placement = `${pos}-start`;
                } else if (this.btnData.offsetTopAlt === this.boxData.offsetTopAlt && this.boxData.offsetTop > this.boxData.offsetBottom) {
                    placement = `${pos}-end`;
                } else {
                    placement = pos;
                }
            }
        } else if (arr.length === 3) {
            placement = this.options.placement;
        } else {
            placement = this.placement;
        }
        return placement;
    }
    fixPlacement() {
        let rectOffset = this.getRectOffset(),
            initPlacement = this.options.placement,
            placement = this.placement,
            xOffsetArr = [{
                name: 'start',
                left: rectOffset.startLeft,
                right: rectOffset.startRight
            }, {
                name: 'center',
                left: rectOffset.centerLeft,
                right: rectOffset.centerRight
            }, {
                name: 'end',
                left: rectOffset.endLeft,
                right: rectOffset.endRight
            }],
            availableX = xOffsetArr.filter(i => i.left >= 0 && i.right >= 0),
            yOffsetArr = [{
                name: 'start',
                top: rectOffset.startTop,
                bottom: rectOffset.startBottom
            }, {
                name: 'center',
                top: rectOffset.centerTop,
                bottom: rectOffset.centerBottom
            }, {
                name: 'end',
                top: rectOffset.endTop,
                bottom: rectOffset.endBottom
            }],
            availableY = yOffsetArr.filter(i => i.top >= 0 && i.bottom >= 0);
        if (initPlacement.includes('bottom')) {
            placement = this.edgeResponse('bottom', availableX);
            if (rectOffset.bottom < 0 && rectOffset.top > 0) {
                placement = placement.replace('bottom', 'top');
            }
        } else if (initPlacement.includes('top')) {
            placement = this.edgeResponse('top', availableX);
            if (rectOffset.top < 0 && rectOffset.bottom > 0) {
                placement = placement.replace('top', 'bottom');
            }
        } else if (initPlacement.includes('left')) {
            placement = this.edgeResponse('left', availableY);
            if (rectOffset.left < 0 && rectOffset.right > 0) {
                placement = initPlacement.replace('left', 'right');
            }
        } else if (initPlacement.includes('right')) {
            placement = this.edgeResponse('right', availableY);
            if (rectOffset.right < 0 && rectOffset.left > 0) {
                placement = initPlacement.replace('right', 'left');
            }
        }
        this.placement = placement;
        return placement;
    }
    unsettable(type) {
        let dom = type === 'btn' ? this.btnDom : this.boxDom;
        return (axIsVnode(dom) || getComputedStyle(dom).display === 'none');
    }
    resetPlacement() {
        if (this.unsettable()) {
            return false;
        }
        this.getRectData();
        this.fixPlacement();
        this.setPlacement(this.placement);
        this.options.onUpdated && this.options.onUpdated.call(this, this.placement);
        'updated' in this.handlers ? this.emit('updated', this.placement) : null;
    }
    update(callback) {
        this.resetPlacement();
        callback && callback.call(this, this.placement);
        return this;
    }
    change(elem, callback) {
        this.btnDom = axIdToDom(elem);
        this.resetPlacement();
        callback && callback.call(this, this.placement);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/*!
* 插件：气泡弹窗；使用方法：new axPopup('#id',{参数})
*/
class axPopup {
    constructor(elem, options) {
        this.options = axExtend({
            insName: '',
            title: '',
            titleBreak: false,
            placement: 'top',
            arrow: true,
            trigger: 'click',
            pageClose: true,
            size: 'md',
            duration: 0,
            in: 'fadeIn',
            out: 'fadeOut',
            multiple: false,
            offsetShow: true,
            rel: '',
            triggerRel: 'click',
            theme: '',
            stay: false,
            fixDistance: '2.4rem',
            name: '',
            width: '',
            height: '',
            padding: 'ax-padding',
            content: '',
            type: 'html',
            url: '',
            btnClass: 'ax-opened',
            close: true,
            footerShow: true,
            footerType: 'line',
            footerBreak: false,
            note: '',
            ajaxType: 'post',
            preventScroll: true,
            onInit: '',
            onShow: '',
            onShwon: '',
            onHide: '',
            onHidden: '',
            onUpdate: '',
            onUpdated: '',
            onUpdateContent: '',
            onUpdatePosition: '',
            onDestroy: '',
            confirm: {
                text: '确定',
                classname: '',
                icon: '',
                type: 'close',
                url: '',
                callback: ''
            },
            cancel: {
                text: '关闭',
                classname: '',
                icon: '',
                callback: ''
            },
            diy: {
                text: '',
                classname: '',
                icon: '',
                url: '',
                target: '',
                callback: ''
            }
        }, options, elem, this.constructor.name);
        this.handlers = {};
        this.form = null;
        this.button = axIdToDom(elem);
        this.shown = false;
        this.bound = false;
        this.triggerShow = () => {
            if (this.options.trigger === 'click') {
                if (!this.shown) {
                    this.show();
                    if (!this.options.multiple) {
                        let items = axInstance.data.filter(i => i.type === 'popup' && i.instance !== this && i.instance.isShow);
                        items.forEach(i => {
                            i.instance.hide();
                        });
                    }
                } else {
                    this.hide();
                }
            } else if (this.options.trigger === 'input') {
                if (!this.button.value) {
                    this.hide();
                } else {
                    this.show();
                }
            }
        }
        this.toggleShow = (ev) => {
            let relOut = true;
            for (let i = 0; i < this.rel.length; i++) {
                if (!axIsOutside(ev, this.rel[i])) {
                    relOut = false;
                    break;
                }
            }
            if (axIsOutside(ev, this.targetDom) && axIsOutside(ev, this.button) && relOut && this.shown) {
                this.hide();
            };
        }
        this.init();
        return this;
    }
    init() {
        let _this = this;
        let subset = axInstance.data.find(i => i.instance === this);
        if (!subset) {
            axInstance.push(this, this.options.insName, 'popup');
        }
        this.destroyed = false;
        this.rel = [];
        if (Array.isArray(this.options.rel)) {
            this.rel = this.options.rel;
        } else {
            this.rel.push(this.options.rel);
        }
        if (this.rel.length > 0) {
            this.rel = this.rel.filter(Boolean).map(i => axIdToDom(i)).filter(Boolean);
        }
        this.renderDom();
        this.setAttribute();
        if (this.options.content.nodeType === 1) {
            this.content.innerHTML = '';
            this.content.appendChild(this.options.content);
            this.form = this.content.querySelector('form');
        } else if (this.options.type === 'form' && typeof this.options.content === 'string' && this.options.content.substr(0, 1) === '#') {
            this.form = document.querySelector(this.options.content).querySelector('form');
            if (this.form) {
                this.content.innerHTML = '';
                this.content.appendChild(this.form);
            } else {
                console.error('Form node is required!');
                return false;
            }
        } else {
            let createContent = axCreateContent(this.options, this, this.options.ajaxType, function () {
                _this.options.preventScroll ? axPreventScroll(_this.wrapper, _this.body) : null;
            });
            this.content.innerHTML = createContent.content;
            this.contentXhr = createContent.xhr;
            this.form = this.content.querySelector('form');
        }
        this.footer.innerHTML = axFooterBtns(this.options, this);
        this.createPopup();
        this.targetDom.querySelectorAll('[confirm]').forEach(elem => {
            elem.onclick = function (e) {
                let button = this;
                if (_this.options.confirm.type === 'submit') {
                    if (_this.form && _this.options.type === 'form') {
                        axValidRepeat(e, axValids, _this.form, function () {
                            _this.form.submit();
                        });
                        _this.options.confirm.callback && _this.options.confirm.callback.call(_this, button, '');
                    } else {
                        console.error('Form node is required and type of options must be form string!');
                        return false;
                    }
                } else if (_this.options.confirm.type === 'async') {
                    if (_this.form && _this.options.type === 'form' && _this.options.confirm.url) {
                        axValidRepeat(e, axValids, _this.form, function () {
                            _this.submitXhr = axAjaxSubmit(_this.options.confirm.url, _this.form, button, _this.options.ajaxType, function (content) {
                                _this.options.confirm.callback && _this.options.confirm.callback.call(_this, button, content);
                            });
                        });
                    } else {
                        console.error('Form node is required & type of options must be form string & url of async is required!');
                        return false;
                    }
                } else if (_this.options.confirm.type === 'prevent') {
                    axPreventDefault(e);
                    _this.options.confirm.callback && _this.options.confirm.callback.call(_this, button, '');
                } else {
                    _this.hide();
                    _this.options.confirm.callback && _this.options.confirm.callback.call(_this, button, '');
                }
            };
        });
        this.targetDom.querySelectorAll('[diy]').forEach(elem => {
            elem.onclick = function () {
                _this.options.diy.callback && _this.options.diy.callback.call(_this, elem);
            };
        });
        this.targetDom.querySelectorAll('[cancel]').forEach(elem => {
            elem.onclick = function () {
                _this.hide();
                _this.options.cancel.callback && _this.options.cancel.callback.call(_this, elem);
            };
        });
        this.targetDom.querySelectorAll('[close]').forEach(elem => {
            elem.addEventListener('click', () => {
                _this.hide();
            }, false);
        });
        this.showEvent();
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    createTemplate() {
        return `
                            <div class="ax-popup" id="popup${new Date().getTime()}">
                                <div class="ax-popup-wrapper">
                                    <# if(this.close){ #><i close></i><# } #>
                                    <# if(this.title){ #><div class="ax-popup-header"><# this.title #></div><# } #>
                                    <# if(this.titleBreak){ #><div class="ax-break-line"></div><# } #>
                                    <div class="ax-popup-body">
                                        <# if(typeof this.padding === 'string'){ #><div class="<# this.padding #>"> <# }else if(this.padding){ #><div class="ax-padding"> <# } #>
                                        <# this.media #>
                                        <div class="ax-popup-content"><# this.content #></div>
                                        <# if(this.padding){ #></div><# } #>
                                    </div>
                                    <div class="ax-popup-footer">
                                    </div>
                                </div>
                            </div>
                            `
    }
    renderDom() {
        this.template = axTplEngine(this.createTemplate(), this.options);
        this.targetDom = axStrToDom(this.template);
        this.wrapper = this.targetDom.querySelector('.ax-popup-wrapper');
        this.content = this.targetDom.querySelector('.ax-popup-content');
        this.body = this.targetDom.querySelector('.ax-popup-body');
        this.targetDom.querySelector('.ax-popup-header') ? this.header = this.targetDom.querySelector('.ax-popup-header') : null;
        this.footer = this.targetDom.querySelector('.ax-popup-footer');
    }
    setAttribute() {
        this.options.size ? this.targetDom.setAttribute('data-size', this.options.size) : null;
        this.options.type ? this.targetDom.setAttribute('data-type', this.options.type) : null;
        this.options.footerType ? this.targetDom.setAttribute('data-footerType', this.options.footerType) : null;
        this.options.height ? this.content.style.height = this.options.height : null;
        this.options.theme ? this.targetDom.setAttribute('data-theme', this.options.theme) : null;
    }
    createPopup() {
        let placement;
        if (this.options.placement === 'center' || axIsMobi()) {
            placement = 'center';
        } else {
            placement = this.options.placement;
        }
        this.popupPosition = new axPopupPosition(this.button, this.targetDom, {
            placement: placement,
            arrowShow: this.options.arrow,
            gap: this.options.arrow ? '.8rem' : '.4rem',
            arrowOffset: this.options.fixDistance,
        });
        this.oldStyle = this.options.width ? `width:${this.options.width};` : '';
    }
    showEvent() {
        let _this = this;
        if (this.options.trigger === 'click' || this.options.trigger === 'input') {
            !this.bound ? this.button.addEventListener(this.options.trigger, this.triggerShow, false) : null;
            if (this.rel.length > 0) {
                this.rel.forEach(item => {
                    !this.bound ? item.addEventListener(this.options.triggerRel || this.options.trigger, this.triggerShow, false) : null;
                });
            }
        } else if (this.options.trigger === 'hover') {
            this.hover = new axHover(_this.button, {
                enter: () => {
                    _this.show();
                },
                leave: () => {
                    _this.hide();
                },
                hold: _this.targetDom,
            });
        } else if (this.options.trigger === 'sticky') {
            this.show();
        }
        if (this.options.pageClose && !_this.options.multiple) {
            !this.bound ? document.addEventListener('click', this.toggleShow, false) : null;
        }
        this.bound = true;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let before = axClone(this.options),
            after = axExtend(this.options, setting),
            isUpdated = false;
        if (setting && JSON.stringify(after) != JSON.stringify(before)) {
            this.options = after;
            this.targetDom.remove();
            this.popupPosition = '';
            if (this.shown) {
                this.init().show();
            } else {
                this.init();
            }
            isUpdated = true;
        }
        callback && callback.call(this, isUpdated, before, after);
        this.options.onUpdated && this.options.onUpdated.call(this, isUpdated, before, after);
        'updated' in this.handlers ? this.emit('updated', isUpdated, before, after) : null;
        return this;
    }
    updateContent(data, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let before = this.content.innerHTML,
            isUpdated = false;
        if (axType(data) === 'String') {
            if (axStrType(data)) {
                this.content.innerHTML = axIdToDom(data) ? axIdToDom(data).innerHTML : '';
            } else {
                this.content.innerHTML = data;
            }
        } else if (axType(data).includes('HTML')) {
            this.content.innerHTML = '';
            this.content.appendChild(data);
        } else {
            this.content.innerHTML = `No data to update!`;
        }
        if (this.content.innerHTML == before) {
            isUpdated = false;
        } else {
            isUpdated = true;
        }
        callback && callback.call(this, isUpdated, before, this.content.innerHTML);
        this.options.onUpdateContent && this.options.onUpdateContent.call(this, isUpdated, before, this.content.innerHTML);
        'updateContent' in this.handlers ? this.emit('updateContent', isUpdated, before, this.content.innerHTML) : null;
        return this;
    }
    updatePosition(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        let newButton = axIdToDom(obj);
        this.popupPosition.change(newButton, (placement) => {
            this.options.onUpdatePosition && this.options.onUpdatePosition.call(this, placement);
            'updatePosition' in this.handlers ? this.emit('updatePosition', placement) : null;
        });
        callback && callback.call(this);
        return this;
    }
    show(callback) {
        if (this.destroyed || this.shown) {
            return this;
        }
        if (!getComputedStyle(this.targetDom).display) {
            document.body.appendChild(this.targetDom);
        }
        this.options.preventScroll ? axPreventScroll(this.wrapper, this.body) : null;
        this.wrapperHeight = axArrHeight(this.wrapper).height;
        if (this.options.duration) {
            this.duration = this.options.duration;
        } else if (this.wrapperHeight) {
            this.duration = Math.floor(this.wrapperHeight / 3 + 250);
        } else {
            this.duration = parseFloat(axStyle(this.targetDom).animationDuration) * 1000
        }
        this.popupPosition.update();
        this.options.onShow && this.options.onShow.call(this);
        'show' in this.handlers ? this.emit('show', '') : null;
        this.targetDom.classList.add('ax-show');
        this.button ? this.button.classList.add(this.options.btnClass) : null;
        if (this.options.in === 'slideDown') {
            axHeightDown(this.wrapper, { height: this.wrapperHeight }, '', this.duration)
        } else {
            this.options.duration ? this.targetDom.style.animationDuration = `${this.options.duration}ms` : null;
            this.options.in ? this.targetDom.style.animationName = this.options.in : null;
        }
        this.targetDom.style.cssText += `;${this.oldStyle}`;
        this.shown = true;
        this.hover ? this.hover.isActive = true : null;
        setTimeout(() => {
            this.options.onShown && this.options.onShown.call(this);
            'shown' in this.handlers ? this.emit('shown', '') : null;
        }, this.duration);
        callback && callback.call(this);
        return this;
    }
    hide(callback) {
        if (this.destroyed || !this.shown) {
            return this;
        }
        if (!this.options.stay) {
            this.options.onHide && this.options.onHide.call(this);
            'hide' in this.handlers ? this.emit('hide', '') : null;
            this.button ? this.button.classList.remove(this.options.btnClass) : null;
            if (this.options.out === 'slideUp') {
                axHeightUp(this.wrapper, { height: this.wrapperHeight }, '', this.duration)
            } else {
                this.options.out ? this.targetDom.style.animationName = this.options.out : null;
            }
            this.targetDom.style.cssText += `;${this.oldStyle}`;
            this.targetDom.querySelectorAll('video,audio').forEach(elem => {
                elem.pause();
            });
            this.shown = false;
            this.hover ? this.hover.isActive = false : null;
            setTimeout(() => {
                this.targetDom.classList.remove('ax-show');
                this.targetDom.remove();
                this.options.onHidden && this.options.onHidden.call(this);
                'hidden' in this.handlers ? this.emit('hidden', '') : null;
                this.options.out === 'slideUp' ? this.wrapper.style.height = 'auto' : null;
            }, this.duration);
            callback && callback.call(this);
        }
        return this;
    }
    destroy(callback) {
        this.targetDom.remove();
        this.popupPosition = null;
        this.hover = null;
        this.button.removeEventListener(this.options.trigger, this.triggerShow);
        this.rel.forEach(i => {
            i.removeEventListener(this.options.triggerRel || this.options.trigger, this.triggerShow);
        });
        this.toggleShow ? document.removeEventListener('click', this.toggleShow) : null;
        this.bound = false;
        this.contentXhr ? this.contentXhr.abort() : null;
        this.submitXhr ? this.submitXhr.abort() : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.destroyed = true;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    function eachInstance(arr, parent) {
        arr.forEach(elem => {
            let instance = new axPopup(elem, '');
            parent ? instance.targetDom.style.zIndex = parseInt(getComputedStyle(parent.targetDom).zIndex) + 1 : null;
            eachInstance(instance.targetDom.querySelectorAll('[axPopup]'), instance);
        });
    }
    let arrInstance = document.querySelectorAll('[axPopup]');
    eachInstance(arrInstance);
})();
/*!
 * 插件：小窗文字提示；使用方法：axTooltip('#id',{参数})
 */
class axTooltip {
    constructor(elem, options) {
        this.button = axIdToDom(elem);
        this.options = axExtend({
            placement: 'top', 
            arrow: true, 
            trigger: 'hover', 
            size: '', 
            multiple: true, 
            theme: 'dark', 
            content: '', 
        }, options, this.button, 'axTooltip');
        this.init();
    }
    init() {
        let btnAttr = this.button.getAttribute('axTooltip');
        if (!this.options.content && btnAttr) {
            !btnAttr.includes(':') ? this.options.content = btnAttr : null;
        }
        let popOptions = Object.assign({
            type: 'html',
            close: false,
            footerShow: false,
            padding: false,
        }, this.options);
        this.popup = new axPopup(this.button, popOptions);
        this.content = this.popup.content;
        this.setAttribute();
    }
    setAttribute() {
        this.popup.targetDom.classList.add('ax-tooltip');
        if (this.options.theme) {
            this.popup.targetDom.setAttribute('theme', this.options.theme)
        }
    }
    updateContent(str, callback) {
        this.content.innerHTML = str;
        callback && callback.call(this, update, before, this.content.innerHTML, this.options.content);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axTooltip]').forEach(element => {
        new axTooltip(element);
    });
})();
/*!
 * 插件：文件上传；使用方法：new axUpload('#id',{参数})
 */
class axUpload {
    constructor(elem, options) {
        this.targetDom = elem ? axIdToDom(elem) : '';
        this.options = axExtend({
            type: 'beautify', 
            accept: 'jpg,jpeg,gif,png,svg,doc,docx,xls,xlsx,txt,mp4,mp3,pdf', 
            mime: '',
            multiple: true, 
            name: '', 
            separator: ',',
            columns: 0,
            min: 0, 
            max: 0, 
            size: 0, 
            url: '', 
            fileType: [], 
            action: 'auto', 
            tipsShow: true, 
            summaryShow: false,
            cloud: '',
            pastable: {
                before: '请点击使用ctrl+v粘贴上传',
                ing: '使用ctrl+v粘贴进来',
                after: 'ctrl+v粘贴上传成功',
            },
            icons: {
                file: 'ax-iconfont ax-icon-file-text',
                attach: 'ax-iconfont ax-icon-attach',
                image: 'ax-iconfont ax-icon-image',
                video: 'ax-iconfont ax-icon-video',
                audio: 'ax-iconfont ax-icon-music'
            },
            beautify: {
                placeholder: '请选择文件...', 
                text: '选择文件', 
                className: 'ax-file',
                display: '',
                callback: '',
            },
            message: {
                passed: '通过文件校验!',
                exceeded: '超过了文件数量限制!',
                tooLarge: '文件体积太大了!',
                errorSuffix: '不支持该文件格式!',
                success: '上传成功!',
                failed: '提交地址可能错误!',
            },
            chooseBtn: {
                icon: '<i class="ax-iconfont ax-icon-plus"></i>',
                text: '选择文件',
                className: '',
                props: {},
                show: true,
            },
            uploadBtn: {
                icon: '<i class="ax-iconfont ax-icon-upload"></i>',
                text: '立即上传',
                className: '',
                props: {},
                show: false,
            },
            clearBtn: {
                icon: '<i class="ax-iconfont ax-icon-trash"></i>',
                text: '删除全部',
                className: '',
                props: {},
                show: false,
            },
            cubeBtn: {
                icon: '<i class="ax-iconfont ax-icon-plus-t"></i>',
                text: '',
                className: '',
                props: {},
                show: true,
            },
            boxBtn: {
                icon: '<i class="ax-iconfont ax-icon-addpic"></i>',
                text: '点击或拖拽上传',
                className: '',
                props: {},
                show: true,
            },
            onBeforeUpload: '',
            onUploaded: '', 
            onError: '', 
            onChange: '', 
            onRemove: '', 
            onBeforeRemove: '', 
            onClear: '', 
            onBeforeClear: '', 
        }, options, this.targetDom, 'axUpload');
        this.name = this.targetDom && this.targetDom.nodeName == 'INPUT' ? this.targetDom.getAttribute('name') : this.options.name;
        this.handlers = {};
        this.sizeLimit = this.options.size * 1024 * 1024; 
        let dftTypes = [{
            name: 'image',
            icon: this.options.icons.image,
            suffix: ['png', 'jpg', 'jpeg', 'bmp', 'gif', 'webp', 'svg', 'tiff']
        }, {
            name: 'video',
            icon: this.options.icons.video,
            suffix: ['mp4', 'mpeg', 'avi', 'wmv', 'mov', 'm4v', 'flv', 'rmvb', '3gp']
        }, {
            name: 'audio',
            icon: this.options.icons.audio,
            suffix: ['mp3', 'wma', 'm4a', 'ogg']
        }];
        if (!axIsEmpty(this.options.fileType)) {
            this.fileTypes = [...this.options.fileType, ...dftTypes];
        } else {
            this.fileTypes = [...dftTypes];
        }
        this.files = [];
        this.details = [];
        this.history = [];
        this.value = [];
        this.inputValue = '';
        this.summary = axAddElem('div', { summary: '' });
        this.init();
    }
    init() {
        let _this = this;
        this.createTips();
        this.createButton();
        this.createSkeleton();
        this.setAttribute();
        if (this.options.type == 'beautify') {
            return false;
        }
        this.chooseBtn.onclick = () => {
            _this.inputFile.click();
        }
        this.readyUpload();
        return this;
    }
    createTips() {
        this.tipsText = '';
        this.options.size ? this.tipsText += `要求大小不超过${this.options.size}MB,` : null;
        this.options.min ? this.tipsText += `至少上传${this.options.min}个文件,` : null;
        this.options.max ? this.tipsText += `最多上传${this.options.max}个文件` : null;
        this.tips = axAddElem('div', { tips: '' }, this.tipsText);
    }
    createButton() {
        if (this.options.type == 'gallery') {
            this.chooseBtn = axAddElem('div', Object.assign({ choose: '' }, this.options.boxBtn.props), this.options.boxBtn.icon + '<div text>' + this.options.boxBtn.text + '</div>');
        } else if (this.options.type == 'picture') {
            this.chooseBtn = axAddElem('li', Object.assign(this.options.cubeBtn.className ? { class: this.options.cubeBtn.className } : { choose: '' }, this.options.cubeBtn.props), this.options.cubeBtn.icon + this.options.cubeBtn.text);
        } else {
            this.chooseBtn = axAddElem('a', Object.assign({ href: '###', class: this.options.chooseBtn.className ? 'ax-btn ' + this.options.chooseBtn.className : 'ax-btn', choose: '' }, this.options.chooseBtn.props), this.options.chooseBtn.icon + this.options.chooseBtn.text);
        }
    }
    createSkeleton() {
        if (this.targetDom) {
            if (this.targetDom.nodeName == 'INPUT' && this.targetDom.type == 'file') {
                this.inputFile = this.targetDom;
                this.inputFile.name ? this.inputFile.setAttribute('name', this.name) : null;
                this.parent = axAddElem('div', { class: 'ax-upload' });
                this.inputFile.insertAdjacentElement('beforeBegin', this.parent);
            } else if (this.targetDom.nodeName == 'INPUT' && (this.targetDom.type == 'hidden' || this.targetDom.type == 'text')) {
                this.inputText = this.targetDom;
                this.inputText.name ? this.inputText.setAttribute('name', this.name) : null;
                this.inputText.setAttribute('readonly', '');
                this.inputFile = axAddElem('input', { type: 'file' });
                this.parent = axAddElem('div', { class: 'ax-upload' });
                this.inputText.insertAdjacentElement('beforeBegin', this.parent);
                this.options.multiple ? this.inputFile.setAttribute('multiple', '') : null;
            } else {
                this.parent = this.targetDom;
                this.inputFile = axAddElem('input', { type: 'file' });
                this.inputText = axAddElem('input', { type: 'hidden', readonly: '', name: this.name });
                this.options.multiple ? this.inputFile.setAttribute('multiple', '') : null;
            }
        } else {
            this.parent = axAddElem('div', { class: 'ax-upload' });
            this.inputFile = axAddElem('input', { type: 'file' });
            this.options.multiple ? this.inputFile.setAttribute('multiple', '') : null;
            this.inputText = axAddElem('input', { type: 'hidden', readonly: '', name: this.options.name });
        }
        this.options.mime ? this.inputFile.setAttribute('accept', this.options.mime) : null;
        this.parent.appendChild(this.inputFile);
        if (this.options.type == 'beautify') {
            this.parent.appendChild(this.inputFile);
            this.parent.dataset.placeholder = this.options.beautify.placeholder;
            this.parent.dataset.text = this.options.beautify.text;
            this.parent.classList.add(this.options.beautify.className);
            this.fileChange(this.parent, this.inputFile);
        } else {
            this.list = axAddElem('ul');
            this.parent.appendChild(this.list);
            this.parent.appendChild(this.inputText);
            let info = axAddElem('div', { info: '' }),
                footer = axAddElem('div', { footer: '' }, info);
            if (this.options.tipsShow && this.tipsText) {
                info.appendChild(this.tips);
                this.parent.setAttribute('withtips', '');
            }
            if (this.options.summaryShow) {
                info.appendChild(this.summary);
                this.summary.innerHTML = this.getSummary();
                this.parent.setAttribute('withtips', '');
            }
            if (this.options.type == 'gallery') {
                this.createCtrlv();
                this.parent.appendChild(footer);
                this.parent.insertAdjacentElement('afterBegin', this.chooseBtn);
                this.list.classList.add('ax-grid', 'ax-space-xs');
                this.options.columns ? this.list.classList.add('ax-grid-' + this.options.columns) : null;
                if (this.options.clearBtn.show) {
                    this.clearBtn = axAddElem('a', Object.assign({ href: '###', class: this.options.clearBtn.className ? 'ax-btn ' + this.options.clearBtn.className : 'ax-btn', clear: '' }, this.options.clearBtn.props), this.options.clearBtn.icon + this.options.clearBtn.text);
                    footer.appendChild(this.clearBtn);
                    this.parent.setAttribute('withtips', '');
                }
                if (this.options.uploadBtn.show) {
                    this.uploadBtn = axAddElem('a', Object.assign({ href: '###', class: this.options.uploadBtn.className ? 'ax-btn ' + this.options.uploadBtn.className : 'ax-btn', upload: '' }, this.options.uploadBtn.props), this.options.uploadBtn.icon + this.options.uploadBtn.text);
                    footer.appendChild(this.uploadBtn);
                    this.parent.setAttribute('withtips', '');
                }
            } else if (this.options.type == 'picture') {
                this.parent.appendChild(footer);
                this.list.appendChild(this.chooseBtn);
                if (this.options.clearBtn.show) {
                    this.clearBtn = axAddElem('li', Object.assign({ class: this.options.clearBtn.className, clear: '' }, this.options.clearBtn.props), this.options.clearBtn.icon + this.options.clearBtn.text);
                    this.chooseBtn.insertAdjacentElement('afterEnd', this.clearBtn);
                }
                if (this.options.uploadBtn.show) {
                    this.uploadBtn = axAddElem('li', Object.assign({ class: this.options.uploadBtn.className, upload: '' }, this.options.uploadBtn.props), this.options.uploadBtn.icon + this.options.uploadBtn.text);
                    this.chooseBtn.insertAdjacentElement('afterEnd', this.uploadBtn);
                }
            } else {
                let header = axAddElem('div', { header: '' });
                this.list.insertAdjacentElement('beforeBegin', footer);
                this.parent.insertAdjacentElement('afterBegin', header);
                header.appendChild(this.chooseBtn);
                if (this.options.uploadBtn.show) {
                    this.uploadBtn = axAddElem('a', Object.assign({ href: '###', class: this.options.uploadBtn.className ? 'ax-btn ' + this.options.uploadBtn.className : 'ax-btn', upload: '' }, this.options.uploadBtn.props), this.options.uploadBtn.icon + this.options.uploadBtn.text);
                    header.appendChild(this.uploadBtn);
                }
                if (this.options.clearBtn.show) {
                    this.clearBtn = axAddElem('a', Object.assign({ href: '###', class: this.options.clearBtn.className ? 'ax-btn ' + this.options.clearBtn.className : 'ax-btn', clear: '' }, this.options.clearBtn.props), this.options.clearBtn.icon + this.options.clearBtn.text);
                    header.appendChild(this.clearBtn);
                }
            }
        }
    }
    createCtrlv() {
        if (this.options.pastable) {
            this.ctrlv = axAddElem('i', { ctrlv: '' }, this.options.pastable.before);
            this.parent.appendChild(this.ctrlv);
            this.parent.onclick = () => {
                this.ctrlv.innerHTML = this.options.pastable.ing;
            }
            this.parent.onmouseleave = () => {
                this.ctrlv.innerHTML = this.options.pastable.before;
            }
        }
    }
    sizeStr(data) {
        let str = ''
        if (data / 1024 >= 1024) {
            str = '<i>' + (data / (1024 * 1024)).toFixed(2) + '</i>MB'
        } else if (data / 1024 >= 1) {
            str = '<i>' + (data / 1024).toFixed(2) + '</i>KB'
        } else {
            str = '<i>' + data + '</i>B'
        }
        return str;
    }
    getSummary() {
        let originalSize = 0,
            realSize,
            totalNum = this.details.length,
            uploadedItems = this.details.filter(i => i.progress == 'uploaded'),
            okNum = uploadedItems.length;
        uploadedItems.forEach(i => {
            originalSize += i.file.size;
        });
        realSize = this.sizeStr(originalSize);
        return `提交了<i>${totalNum}</i>个文件,成功上传了<i>${okNum}</i>个,共${realSize}`;
    }
    createItem(file, state) {
        let tpl = '';
        if (this.options.type == 'gallery') {
            tpl = `
            <li valid=${(state && !state.valid) ? "error" : 'success'}>
                <div file>
                    <div overlay>
                        <i view class="ax-iconfont ax-icon-zoomin"></i>
                        <a down href="###" class="ax-iconfont ax-icon-download"></a>
                        <i remove class="ax-iconfont ax-icon-trash"></i>
                    </div>
                    <div track><div bar></div></div>
                    <i percent></i>
                    <div message>${(state && !state.valid) ? state.message : ''}</div>
                </div>
                <div info>
                    <div title>${file.name}</div>
                    <div size>${this.sizeStr(file.size)}</div>
                    <div url></div>
                </div>
            </li>
            `;
        } else if (this.options.type == 'picture') {
            tpl = `
            <li valid=${(state && !state.valid) ? "error" : 'success'}>
                <div file></div>
                <div overlay>
                    <i view class="ax-iconfont ax-icon-zoomin"></i>
                    <a down href="###" class="ax-iconfont ax-icon-download"></a>
                    <i remove class="ax-iconfont ax-icon-trash"></i>
                </div>
                <div track><div bar></div></div>
                <i percent></i>
                <div message>${(state && !state.valid) ? state.message : ''}</div>
            </li>
            `;
        } else if (this.options.type == 'info') {
            tpl = `
            <li valid=${(state && !state.valid) ? "error" : 'success'}>
                <a href="###" file></a>
                <div info>
                    <a href="###" title>${file.name}</a>
                </div>
                <div track><div bar></div></div>
                <i percent></i>
                <i message>${(state && !state.valid) ? state.message : ''}</i>
                <i remove class="ax-iconfont ax-icon-trash"></i>
            </li>
            `;
        } else {
            tpl = `
            <li valid=${(state && !state.valid) ? "error" : 'success'}>
                <i icon class="${this.options.icons.attach}"></i>
                <div info>
                    <a href="###" title>${file.name}</a>
                </div>
                <div track><div bar></div></div>
                <i percent></i>
                <i message>${(state && !state.valid) ? state.message : ''}</i>
                <i remove class="ax-iconfont ax-icon-trash"></i>
            </li>
            `;
        }
        let li = axStrToDom(tpl),
            fileDom = li.querySelector('[file]');
        fileDom ? this.fillHeader(file, fileDom) : null;
        if (this.options.type == 'picture') {
            this.chooseBtn.insertAdjacentElement('beforeBegin', li);
        } else {
            this.list.appendChild(li);
        }
        return li;
    }
    fileChange(item, file) {
        let _this = this;
        let text = item.getAttribute('data-text'),
            placeholder = item.getAttribute('data-placeholder');
        if (!text) {
            item.classList.add('ax-simple');
        }
        if (file.classList.contains("ax-xs")) {
            item.classList.add('ax-xs');
        } else if (file.classList.contains('ax-sm')) {
            item.classList.add('ax-sm');
        } else if (file.classList.contains('ax-lg')) {
            item.classList.add('ax-lg');
        }
        let imgWrapper;
        if (this.options.beautify.display) {
            imgWrapper = axIdToDom(this.options.beautify.display);
        }
        file.addEventListener('change', function () {
            item.classList.add('ax-active');
            item.setAttribute('data-placeholder', this.value.replace(/.*(\/|\\)/, ''));
            if (!this.value) {
                item.setAttribute('data-placeholder', placeholder);
                item.classList.remove('ax-active');
            }
            if ([...this.files].length > 0) {
                [...this.files].forEach(i => {
                    _this.value.push({ name: i.name, size: i.size, time: i.lastModified, url: '' })
                });
                if (imgWrapper) {
                    imgWrapper.innerHTML = '';
                    [...this.files].forEach(i => {
                        if (i.type.startsWith('image')) {
                            _this.readFile(i, (data) => {
                                imgWrapper.appendChild(axAddElem('img', { src: data }));
                            });
                        }
                    });
                }
            }
            _this.options.beautify.callback && _this.options.beautify.callback.call(_this, this.files);
            _this.options.onChange && _this.options.onChange.call(_this, this.files);
            'changed' in _this.handlers ? _this.emit('changed', this.files) : null;
            _this.options.onChanged && _this.options.onChanged.call(_this, this.files);
        }, false);
        file.onfocus = () => {
            item.classList.add("ax-focus");
        };
        file.onblur = () => {
            item.classList.remove("ax-focus");
        };
    }
    setAttribute() {
        this.options.type ? this.parent.setAttribute('type', this.options.type) : null;
        this.options.pastable ? this.parent.setAttribute('pastable', '') : null;
        this.parent.setAttribute('state', 'ready');
    }
    readyUpload() {
        this.inputFile.addEventListener('change', () => {
            let files = [...this.inputFile.files];
            this.renderList(files);
            this.inputFile.value = '';
            'changed' in this.handlers ? this.emit('changed', files) : null;
            this.options.changed && this.options.changed.call(this, files);
        }, false);
        if (this.options.pastable) {
            this.parent.addEventListener('paste', (e) => {
                let data = e.clipboardData ? e.clipboardData : window.clipboardData;
                if (data) {
                    let item = data.items[0];
                    if (item && item.kind === 'file' && item.type.includes('image')) {
                        this.renderList([item.getAsFile()]);
                        this.ctrlv ? this.ctrlv.innerHTML = this.options.pastable.after : null;
                    }
                    'pasted' in this.handlers ? this.emit('pasted', item) : null;
                }
            }, false);
        }
        this.parent.addEventListener("dragleave", (e) => {
            e.preventDefault();
            this.parent.removeAttribute('drag');
        });
        this.parent.addEventListener("dragover", (e) => {
            e.preventDefault();
        });
        this.parent.addEventListener("dragenter", (e) => {
            e.preventDefault();
            this.parent.setAttribute('drag', '');
        });
        this.parent.addEventListener("drop", (e) => {
            e.preventDefault();
            this.parent.removeAttribute('drag');
            let items = e.dataTransfer.items;
            for (let i = 0; i < items.length; i++) {
                let item = items[i];
                if (item.kind === "file") {
                    let entry = item.webkitGetAsEntry();
                    this.getEntries(entry);
                }
            }
            'dropped' in this.handlers ? this.emit('dropped', items) : null;
        }, false);
        if (this.clearBtn) {
            this.clearBtn.onclick = () => {
                if (this.details.length == 0) {
                    return false;
                }
                if (this.options.onBeforeClear) {
                    this.options.onBeforeClear.call(this);
                } else {
                    this.clear.call(this);
                }
            }
        }
    }
    renderItem(file) {
        let elem,
            fileValid = this.fileValid(file),
            obj = { file: file, state: fileValid },
            render = (obj, elem) => {
                obj.dom = elem;
                obj.progress = 'rendered';
                elem.setAttribute('progress', 'rendered');
            };
        if (fileValid.valid) {
            this.files.push(file);
            elem = this.createItem(file);
        } else {
            elem = this.createItem(file, fileValid);
        }
        render(obj, elem);
        this.details.push(obj);
        let removeDom = elem.querySelector('[remove]');
        if (removeDom) {
            removeDom.onclick = () => {
                if (this.options.onBeforeRemove) {
                    this.options.onBeforeRemove.call(this, obj);
                } else {
                    this.remove(obj.file);
                }
            }
        }
        'rendered' in this.handlers ? this.emit('rendered', obj) : null;
        return elem;
    }
    getEntries(entry) {
        if (entry.isFile) {
            entry.file(i => this.renderList([i]));
        } else {
            let reader = entry.createReader();
            reader.readEntries(k => {
                k.forEach(i => this.getEntries(i));
            }
            );
        }
    }
    renderList(files, callback) {
        if (files.length == 0) {
            return false;
        }
        for (let x = 0, len = files.length; x < len; x++) {
            let item = files[x];
            if (this.history.length == 0) {
                this.history.push(item);
                this.renderItem(item);
            } else {
                if (this.history.every(i => (i.name != item.name && i.size != item.size))) {
                    this.history.push(item);
                    this.renderItem(item);
                } else {
                    continue;
                }
            }
        }
        if (this.options.action == 'auto') {
            this.upload();
        } else {
            if (this.uploadBtn) {
                this.uploadBtn.onclick = () => {
                    this.upload();
                }
            }
        }
        this.parent.setAttribute('state', 'processing');
        callback && callback.call(this);
    }
    upload(callback) {
        if (!this.options.url) {
            console.error('The url is required!');
            return false;
        }
        let globalValid = this.globalValid();
        if (!globalValid.valid) {
            new axMessage({
                content: globalValid.message,
                result: 'error',
            });
            return false;
        }
        let uploadingFiles = this.getUploadingFiles();
        if (this.options.onBeforeUpload && !this.options.onBeforeUpload.call(this, uploadingFiles)) {
            return false;
        }
        uploadingFiles.forEach(i => {
            this.uploadFile(i);
        });
        /* for (let i = 0, len = this.details.length; i < len; i++) {
            let item = this.details[i];
            if (!item.state.valid) {
                continue;
            }
            item.progress != 'uploaded' ? this.uploadFile(item) : null;
        } */
        'uploading' in this.handlers ? this.emit('uploading', '') : null;
        callback && callback.call(this);
    }
    getUploadingFiles() {
        return this.details.filter(i => i.state.valid && i.progress != 'uploaded');
    }
    activeOperate(file, dom, url, name) {
        dom.setAttribute('valid', 'success');
        dom.setAttribute('progress', 'uploaded');
        if (!dom.querySelector('[state]')) {
            dom.querySelector('[percent]').insertAdjacentHTML('afterend', `<i state class="ax-iconfont ax-icon-check"></i>`);
        }
        if (this.options.cloud) {
            url = this.options.cloud.server + url;
        }
        let downBtn = dom.querySelector('[down]'),
            viewBtn = dom.querySelector('[view]');
        if (downBtn) {
            if (this.options.cloud) {
                downBtn.onclick = () => {
                    this.downloadFile(url, file.name);
                }
            } else {
                downBtn.setAttribute('download', '');
                downBtn.setAttribute('href', url);
            }
        }
        if (viewBtn) {
            let mediaSrc = { media: url, caption: name, type: '' };
            if (this.h5Type(file) == 'image') {
                mediaSrc.type = 'image';
            } else if (this.h5Type(file) == 'video') {
                mediaSrc.type = 'video';
            } else if (this.h5Type(file) == 'audio') {
                mediaSrc.type = 'audio';
            }
            if (mediaSrc.type) {
                viewBtn.onclick = function () {
                    new axLightbox({
                        src: mediaSrc,
                    }).init().show();
                }
            }
        }
        if (this.options.type == 'text' || this.options.type == 'info') {
            let titleDom = dom.querySelector('[title]'),
                fileDom = dom.querySelector('[file]');
            titleDom.setAttribute('href', url);
            titleDom.setAttribute('target', '_blank');
            if (fileDom) {
                fileDom.setAttribute('href', url);
                fileDom.setAttribute('target', '_blank');
            }
        }
    }
    downloadFile(url, fileName) {
        let xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = 'blob';
        xhr.onload = function () {
            let url = window.URL.createObjectURL(xhr.response),
                dom = axAddElem('a');
            dom.href = url;
            dom.download = fileName;
            dom.click();
        }
        xhr.send();
    }
    uploadFile(obj) {
        let _this = this,
            data = new FormData(),
            file = obj.file,
            dom = obj.dom,
            valid = obj.state.valid,
            fixDom = (flag, url, message, dom) => {
                if (flag) {
                    this.activeOperate(file, dom, url, file.name);
                } else {
                    dom.setAttribute('valid', 'error');
                    dom.querySelector('[message]').innerText = message;
                }
                this.options.summaryShow ? this.summary.innerHTML = this.getSummary() : null;
            }
        if (!valid || obj.progress == 'uploaded') {
            return false;
        }
        obj.progress = 'uploading';
        dom.setAttribute('progress', 'uploading');
        if (this.options.cloud) {
            data.append(this.options.cloud.field ? this.options.cloud.field : 'file', file);
            for (let k in this.options.cloud.append) {
                data.append(k, this.options.cloud.append[k]);
            }
        } else {
            data.append(this.name ? this.name : 'file', file);
        }
        axAjax({
            url: this.options.url,
            data: data,
            uploading(result, percent) {
                dom.querySelector('[percent]').innerText = result;
                dom.querySelector('[bar]').style.width = result;
                'completed' in _this.handlers ? _this.emit('completed', obj) : null;
                if (percent >= 100) {
                    dom.setAttribute('completed', '');
                    obj.completed = true;
                    'completed' in _this.handlers ? _this.emit('completed', obj) : null;
                    if (_this.details.every(i => i.state.valid && i.completed && i.completed == true)) {
                        'allCompleted' in _this.handlers ? _this.emit('allCompleted', '') : null;
                    }
                }
            },
            success: (content) => {
                let msg = '', url = '', size = 0, time = 0, valid,
                    getKeys = (obj, str) => {
                        s
                        if (!str) {
                            return '';
                        }
                        if (!str.includes('.')) {
                            return obj[str];
                        }
                        let arr = str.split("."),
                            value;
                        if (arr.length == 1) {
                            value = obj[arr[0]]
                        } else if (arr.length == 2) {
                            value = obj[arr[0]][arr[1]]
                        } else {
                            value = '';
                        }
                        return value;
                    };
                if (this.options.cloud) {
                    let keys = this.options.cloud.keys;
                    url = getKeys(content, keys.url);
                    size = getKeys(content, keys.size);
                    time = getKeys(content, keys.time);
                    msg = getKeys(content, keys.message);
                    valid = this.options.cloud.code == content.code ? true : false;
                } else {
                    url = content.url;
                    size = file.size;
                    time = content.time;
                    msg = content.message;
                    valid = content.valid === true ? true : false;
                }
                obj.state.valid = valid;
                obj.state.time = time;
                obj.state.url = url;
                obj.state.message = msg;
                if (!valid) {
                    _this.files = _this.files.filter(i => i != file);
                    'error' in _this.handlers ? _this.emit('error', obj) : null;
                    _this.options.onError && _this.options.onError.call(_this, obj);
                } else {
                    _this.value.push({ name: file.name, url: url, size: size, time: time });
                    _this.valueToValue(_this.value);
                    obj.progress = 'uploaded';
                    'uploaded' in _this.handlers ? _this.emit('uploaded', obj) : null;
                    _this.options.onUploaded && _this.options.onUploaded.call(_this, obj);
                    if (_this.details.every(i => i.state.valid && i.progress == 'uploaded')) {
                        'allUploaded' in _this.handlers ? _this.emit('allUploaded', '') : null;
                    }
                }
                fixDom(valid, url, msg, dom);
            },
            error: () => {
                fixDom(false, '', this.options.message.failed, dom);
            }
        })
    }
    valueToValue(value) {
        let arr = [];
        value.forEach(i => {
            arr.push(i.url);
        });
        this.inputValue = arr.join(this.options.separator);
        if (this.inputText) {
            this.inputText.value = this.inputValue;
            this.inputText.onchange ? this.inputText.onchange() : null;
        }
    }
    getSuffix(file) {
        return file.name.substring(file.name.lastIndexOf('.') + 1);
    }
    h5Type(file) {
        let mediaType;
        if (file.type.startsWith('image')) {
            mediaType = 'image';
        } else if (['mp4', 'ogg', 'webm'].includes(this.getSuffix(file))) {
            mediaType = 'video';
        } else if (['mp3', 'ogg', 'wav'].includes(this.getSuffix(file))) {
            mediaType = 'audio';
        }
        return mediaType;
    }
    readFile(file, callback) {
        let reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = (e) => {
            callback(e.target.result);
        }
    };
    fillHeader(file, dom) {
        let elem,
            type = this.h5Type(file),
            iconType = this.fileTypes.filter(i => i.suffix.includes(this.getSuffix(file)))[0];
        if (type == 'image') {
            this.readFile(file, (data) => {
                elem = axAddElem('img', { src: data });
                dom.appendChild(elem);
            });
        } else if (type == 'video') {
            this.readFile(file, (data) => {
                elem = axAddElem('video', { src: data, controls: '' });
                dom.appendChild(elem);
            });
        } else if (type == 'audio') {
            this.readFile(file, (data) => {
                elem = axAddElem('audio', { src: data, controls: '' });
                dom.appendChild(elem);
            });
        } else {
            elem = axAddElem('i', { class: iconType ? iconType.icon : this.options.icons.file, icon: '' });
            dom.appendChild(elem);
        }
    }
    fileValid(file) {
        let msg = this.options.message.passed,
            pass = true,
            suffix = this.getSuffix(file);
        if (this.history.length > this.options.max && this.options.max) {
            msg = this.options.message.exceeded;
            pass = false;
        } else if (this.history.length < this.options.min && this.options.min) {
            msg = this.options.message.exceeded;
            pass = false;
        } else if (this.sizeLimit && (file.size > this.sizeLimit)) {
            msg = this.options.message.tooLarge;
            pass = false;
        } else if (!this.options.accept.includes(suffix)) {
            msg = this.options.message.errorSuffix;
            pass = false;
        }
        return { valid: pass, message: msg }
    }
    globalValid() {
        let msg = this.options.message.passed,
            pass = true;
        if (this.history.length < this.options.min) {
            msg = `请至少上传${this.options.min}个文件!`;
            pass = false;
        } else if (this.history.length < this.options.min) {
            msg = `最多只能上传${this.options.max}个文件!`;
            pass = false;
        }
        return { valid: pass, message: msg }
    }
    remove(file, callback) {
        this.history = this.history.filter(i => i != file);
        this.files = this.files.filter(i => i != file);
        let item = this.details.find(i => i.file == file),
            name = file.name,
            size = file.size,
            url = item.state.url,
            time = item.state.time;
        item.dom.remove();
        this.details = this.details.filter(i => i.file != file);
        if (this.details.length == 0) {
            this.parent.setAttribute('state', 'ready');
        }
        this.value = this.value.filter(i => i.time != time);
        this.valueToValue(this.value);
        this.options.summaryShow ? this.summary.innerHTML = this.getSummary() : null;
        this.options.onRemove ? this.options.onRemove.call(this, url, name, size) : null;
        'remove' in this.handlers ? this.emit('remove', url, name, size) : null;
        callback && callback.call(this, url, name, size);
    }
    clear(callback) {
        this.details.forEach(i => {
            i.dom.remove();
        });
        this.details = [];
        this.history = [];
        this.files = [];
        this.value = [];
        this.valueToValue(this.value);
        this.parent.setAttribute('state', 'ready');
        this.options.summaryShow ? this.summary.innerHTML = this.getSummary() : null;
        this.options.onClear ? this.options.onClear.call(this) : null;
        'clear' in this.handlers ? this.emit('clear', '') : null;
        callback && callback.call(this);
        return this;
    }
    getUrlFile(url, fileName, callback) {
        axAjax({
            url: url,
            type: 'get',
            responseType: 'blob',
            headers: { 'Accept': '' },
            success: (response) => {
                let file = new File([response], fileName, { type: response.type });
                callback && callback(file);
            }
        });
    }
    show(data) {
        let newData = [];
        if (typeof data == 'string') {
            let arr = data.trim().split(',');
            arr.forEach(i => {
                let obj = { url: i, name: i }
                newData.push(obj);
            });
        } else if (Array.isArray(data) && typeof data[0] == 'string') {
            data.forEach(i => {
                let obj = { url: i, name: i }
                newData.push(obj);
            });
        } else {
            newData = data;
        }
        if (newData.length == 0) {
            return false;
        }
        this.parent.setAttribute('state', 'processing');
        newData.forEach(i => {
            this.getUrlFile(i.url, i.name, (file) => {
                this.history.push(file);
                let elem = this.renderItem(file),
                    item = this.details.find(i => i.file == file);
                item.progress = 'uploaded';
                item.state.message = this.options.message.success;
                item.state.url = i.url;
                item.state.time = i.time || file.lastModified;
                this.activeOperate(file, elem, i.url, i.name || i.url);
                elem.setAttribute('completed', '');
                this.options.summaryShow ? this.summary.innerHTML = this.getSummary() : null;
            })
        });
        this.details.forEach(i => {
            let obj = { name: i.file.name, url: i.state.url, size: i.file.size, time: i.state.time }
            this.value.push(obj);
        });
        this.valueToValue(this.value);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axUpload]').forEach(element => {
        new axUpload(element);
    });
})();
/*!
* 插件：即时消息/警告小窗；使用方法：new axMessage({参数})
*/
const axMessages = [];
class axMessage {
    constructor(options) {
        this.options = axExtend({
            className: '',
            placement: 'center-top',
            content: '',
            result: 'info',
            delay: 3000,
            progress: true,
            title: {
                warning: '操作警告！',
                success: '操作成功！',
                error: '操作失败！',
                question: '操作疑问！',
                info: '信息提示！',
            },
            close: false,
            iconShow: false,
            style: 'simple',
            icon: '',
        }, options);
        this.handlers = {};
        this.init();
    }
    init() {
        let _this = this;
        if (this.options.style == 'simple' || !this.options.style) {
            switch (this.options.result) {
                case 'success':
                    this.options.icon = axIcon.font.success;
                    !this.options.content ? this.options.content = this.options.title.success : null;
                    break;
                case 'error':
                    this.options.icon = axIcon.font.error;
                    !this.options.content ? this.options.content = this.options.title.error : null;
                    break;
                case 'question':
                    this.options.icon = axIcon.font.question;
                    !this.options.content ? this.options.content = this.options.title.question : null;
                    break;
                case 'warning':
                    this.options.icon = axIcon.font.warning;
                    !this.options.content ? this.options.content = this.options.title.warning : null;
                    break;
                default:
                    this.options.icon = axIcon.font.info;
                    !this.options.content ? this.options.content = this.options.title.info : null;
            }
        } else if (this.options.style == 'complex') {
            switch (this.options.result) {
                case 'success':
                    this.options.icon = axIcon.svg.success;
                    break;
                case 'error':
                    this.options.icon = axIcon.svg.error;
                    break;
                case 'question':
                    this.options.icon = axIcon.svg.question;
                    break;
                case 'warning':
                    this.options.icon = axIcon.svg.warning;
                    break;
                default:
                    this.options.icon = axIcon.svg.info;
            }
        }
        if (this.options.style == 'simple' || !this.options.style) {
            this.template = axTplEngine(`
            <section data-style="simple">
                <div class="ax-message-content">
                    <# if(this.iconShow){ #><span class="ax-message-icon"><# this.icon #></span><# } #>
                    <div class="ax-message-body"><# this.content #></div>
                    <# if(this.close){ #><i close></i> <# } #>
                </div>
            </section>
            `, this.options);
        } else if (this.options.style == 'complex') {
            this.template = axTplEngine(`
            <section data-style="complex">
                <div class="ax-message-content">
                    <div class="ax-message-header">
                    <# if(this.iconShow){ #><span class="ax-message-icon ax-result ax-result-show"><# this.icon #></span><# } #>
                    <span class="ax-message-title"><# if(this.result == 'success'){ #> <# this.title.success #> <# }else if(this.result == 'error'){ #> <# this.title.error #> <# }else if(this.result == 'question'){#> <# this.title.question #> <# }else if(this.result == 'warning'){#> <# this.title.warning #> <# } else {#> <# this.title.info #> <# } #></span></div>
                    <div class="ax-message-body"><# this.content #></div>
                </div>
                <# if(this.close){ #><i close></i> <# } #>
                <# if(this.progress){ #><div class="ax-message-progress" style="transition-duration:<# this.delay #>ms;"></div><# } #>
            </section>
            `, this.options);
        }
        this.targetDom = axStrToDom(this.template);
        this.content = this.targetDom.querySelector('.ax-message-body');
        this.title = this.targetDom.querySelector('.ax-message-title');
        this.close = this.targetDom.querySelector('[close]');
        this.progress = this.targetDom.querySelector('.ax-message-progress');
        switch (this.options.result) {
            case 'success':
                this.targetDom.setAttribute('data-result', 'success');
                break;
            case 'error':
                this.targetDom.setAttribute('data-result', 'error');
                break;
            case 'question':
                this.targetDom.setAttribute('data-result', 'question');
                break;
            case 'warning':
                this.targetDom.setAttribute('data-result', 'warning');
                break;
            default:
                this.targetDom.setAttribute('data-result', 'info');
        }
        let className = '';
        !this.options.className ? className = ' ' + this.options.className : className = '';
        this.options.close ? this.targetDom.setAttribute('data-close', 'true') : null;
        this.content.innerHTML = this.options.content;
        this.event = (position) => {
            if (JSON.stringify(axMessages).indexOf(position) === -1) {
                let dom = axAddElem('div', { 'class': 'ax-message' + className, 'data-placement': position });
                axMessages.push({
                    postion: position,
                    parent: dom,
                });
                dom.appendChild(_this.targetDom);
                document.body.appendChild(dom);
                axSlideDown(_this.targetDom, () => {
                    'shown' in _this.handlers ? _this.emit('shown', '') : null;
                });
                if (!_this.options.close) {
                    _this.options.progress && _this.progress ? _this.progress.style.cssText += `width:0;` : null;
                    setTimeout(() => {
                        axSlideUp(_this.targetDom, () => {
                            _this.targetDom.remove();
                            'hidden' in _this.handlers ? _this.emit('hidden', '') : null;
                        });
                    }, this.options.delay);
                } else {
                    _this.close.addEventListener('click', () => {
                        axSlideUp(_this.targetDom, () => {
                            _this.targetDom.remove();
                            'hidden' in _this.handlers ? _this.emit('hidden', '') : null;
                        });
                    }, false);
                }
            } else {
                let _item = axMessages.find(item => {
                    return item.postion == position;
                });
                _item.parent.insertAdjacentElement('beforeend', _this.targetDom);
                axSlideDown(_this.targetDom, () => {
                    'shown' in _this.handlers ? _this.emit('shown', '') : null;
                });
                if (!_this.options.close) {
                    _this.options.progress && _this.progress ? _this.progress.style.cssText += `width:0;` : null;
                    setTimeout(() => {
                        axSlideUp(_this.targetDom, () => {
                            _this.targetDom.remove();
                            'hidden' in _this.handlers ? _this.emit('hidden', '') : null;
                        });
                    }, this.options.delay);
                } else {
                    _this.close.addEventListener('click', () => {
                        axSlideUp(_this.targetDom, () => {
                            _this.targetDom.remove();
                            'hidden' in _this.handlers ? _this.emit('hidden', '') : null;
                        });
                    }, false);
                }
            }
        }
        switch (this.options.placement) {
            case 'left-top':
                this.event('left-top');
                break;
            case 'center-top':
                this.event('center-top');
                break;
            case 'right-top':
                this.event('right-top');
                break;
            case 'left-center':
                this.event('left-center');
                break;
            case 'center-center':
                this.event('center-center');
                break;
            case 'right-center':
                this.event('right-center');
                break;
            case 'left-bottom':
                this.event('left-bottom');
                break;
            case 'center-bottom':
                this.event('center-bottom');
                break;
            case 'right-bottom':
                this.event('right-bottom');
                break;
            case 'left':
                this.event('left-top');
                break;
            case 'top':
                this.event('center-top');
                break;
            case 'right':
                this.event('right-top');
                break;
            case 'center':
                this.event('center-center');
                break;
            default:
                this.event('center-top');
        }
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/*!
 * 插件：折叠菜单；使用方法：new axMenu('#id',{参数})
 */
class axMenu {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            insName: '',
            storageName: '',
            theme: 'light',
            content: '',
            dispose: false,
            active: '',
            disabled: '',
            multiple: false,
            collapseAll: true,
            ajaxType: 'post',
            trigger: 'click',
            firstFloor: -1, 
            idStart: 0,
            arrowShow: true,
            max: 0,
            targetClass: '',
            addToActive: true,
            gapless: false,
            lamp: '',
            full: false,
            nav: {
                enable: false,
                headerWidth: '',
                bodyWidth: '',
                marginLeft: '',
                marginRight: '',
                align: 'left',
            },
            onInit: '',
            onAdd: '',
            onRemove: '',
            onDisable: '',
            onEnable: '',
            onDisableALL: '',
            onEnableAll: '',
            onExpand: '',
            onExpanded: '',
            onCollapse: '',
            onCollapsed: '',
            onUpdate: '',
            onUpdateContent: '',
            onDestroy: '',
            onSave: '',
            onExpandAll: '',
            onCollapseAll: '',
        }, options, this.targetDom, this.constructor.name);
        let _this = this;
        this.handlers = {};
        this.triggerShow = function () {
            _this.toggle(this);
        }
        this.triggerSelected = (item) => {
            item.headerDom.setAttribute('selected', '');
            item.selected = true;
            let others = this.flatData.filter(i => i !== item && i.selected && !i.children);
            others.forEach(i => {
                i.headerDom.removeAttribute('selected');
                delete i.selected;
            });
            _this.save();
        }
        this.rawHTML = ''
        this.init();
    };
    init() {
        axInstance.push(this, this.options.insName, 'menu');
        this.destroyed = false;
        this.flatData = [];
        this.treeData = [];
        if (this.options.storageName) {
            let storageVal = axLocalStorage.get(this.options.storageName);
            if (!axIsEmpty(storageVal)) {
                this.options = axExtend(this.options, storageVal);
            } else {
                axLocalStorage.set(this.options.storageName, {});
            }
        }
        this.resolveSource();
        return this;
    }
    resolveSource() {
        if (!axIsEmpty(this.options.content)) {
            this.targetDom.innerHTML = '';
            if (axType(this.options.content) === 'String') {
                axAjax({
                    url: this.options.content,
                    type: this.options.ajaxType,
                    success: (content) => {
                        if (axIsEmpty(content)) {
                            console.warn('No data obtained from json!');
                            return false;
                        }
                        this.toTreeWithPathPid(content);
                        this.targetDom.innerHTML = '';
                        this.arrayToDom(this.treeData);
                        this.processDataFormat(this.treeData);
                    }
                }, this.targetDom);
            } else if (axType(this.options.content) === 'Array') {
                if (this.options.content.length === 0) {
                    console.warn('Array is empty!');
                    return false;
                }
                this.toTreeWithPathPid(this.options.content);
                this.arrayToDom(this.treeData);
                this.processDataFormat(this.treeData);
            }
        } else {
            if (this.targetDom.innerHTML) {
                this.rawHTML = this.targetDom.innerHTML;
                this.treeData = this.ulToArr();
                this.toTreeWithPathPid(this.treeData);
                this.processDataFormat(this.treeData);
            }
        }
    }
    processDataFormat(data) {
        this.flatData = axArrToFlat(data); 
        this.initParms();
        this.renderFinish();
        this.options.onInit && this.options.onInit.call(this);
        'init' in this.handlers ? this.emit('init', '') : null;
    }
    initParms() {
        this.initAttribute();
        this.initActive();
        this.initDisabled();
    }
    toTreeWithPathPid(data) {
        if (data[0].hasOwnProperty('pId') && data[0].hasOwnProperty('id')) {
            this.treeData = axArrToTree(data, this.options.firstFloor);
        } else {
            this.treeData = axTreeMethod.addPath(data, this.options.firstFloor, this.options.idStart).data;
        }
    }
    ulToArr() {
        let data = [],
            start = this.options.idStart,
            getJson = (elem, index) => {
                let obj = {}, ul = elem.querySelector('ul');
                obj.id = index;
                obj.wrapperDom = elem;
                obj.headerDom = elem.firstElementChild;
                obj.labelDom = obj.headerDom.querySelector('[label]');
                obj.label = obj.labelDom.textContent.trim();
                obj.tipDom = obj.headerDom.querySelector('[tip]');
                obj.tip = obj.tipDom ? obj.tipDom.textContent.trim() : '';
                obj.url = obj.labelDom.href && !obj.labelDom.href.includes('##') ? obj.labelDom.href : '';
                obj.target = obj.labelDom.target;
                obj.arrowDom = obj.headerDom.querySelector('[arrow]');
                obj.legendDom = obj.headerDom.querySelector('[legend]');
                obj.legendDom ? obj.legend = obj.legendDom.getAttribute('class') : null;
                elem.hasAttribute('expanded') ? obj.expanded = true : null;
                obj.headerDom.hasAttribute('selected') ? obj.selected = true : null;
                obj.headerDom.hasAttribute('disabled') ? obj.disabled = true : null;
                if (ul) {
                    obj.children = [];
                    obj.bodyDom = ul;
                    [...ul.children].forEach(item => {
                        start++;
                        obj.children.push(getJson(item, start));
                    });
                }
                return obj;
            }
        let getData = () => {
            [...this.targetDom.children].forEach(item => {
                data.push(getJson(item, start));
                start++;
            });
        }
        getData();
        return data;
    }
    childToParent(item) {
        item.headerDom.onclick = null;
        item.expanded = true;
        item.wrapperDom.setAttribute('expanded', '');
        item.arrowDom = this.options.arrowShow && item.children ? axAddElem('i', { arrow: '', class: 'ax-iconfont ax-icon-right' }) : null;
        item.headerDom.appendChild(item.arrowDom);
        item.bodyDom = axAddElem('ul', { style: 'display:block' });
        return item;
    }
    createHeaderDom(item) {
        item.labelDom = axAddElem(item.url ? 'a' : 'i', { label: '' }, item.label);
        item.url ? item.labelDom.href = item.url : null;
        item.target ? item.labelDom.target = item.target : null;
        item.legendDom = item.legend ? axAddElem('i', { legend: '', class: `ax-iconfont ${item.legend}` }) : null;
        item.arrowDom = this.options.arrowShow && item.children ? axAddElem('i', { arrow: '', class: 'ax-iconfont ax-icon-right' }) : null;
        item.headerDom = axAddElem('div');
        item.tipDom = item.tip ? axAddElem('i', { tip: '' }, item.tip) : null;
        item.wrapperDom = axAddElem('li');
        item.wrapperDom.appendChild(item.headerDom);
        item.legendDom ? item.headerDom.appendChild(item.legendDom) : null;
        item.headerDom.appendChild(item.labelDom);
        item.tipDom ? item.headerDom.appendChild(item.tipDom) : null;
        item.arrowDom ? item.headerDom.appendChild(item.arrowDom) : null;
        item.callback && item.callback.call(this, item);
    }
    arrayToDom(data) {
        let outer = axAddElem('ul'),
            fragment = document.createDocumentFragment();
        let plantTree = (parent, data) => {
            let ul = axAddElem('ul');
            data.forEach(item => {
                this.createHeaderDom(item);
                if (item.hasOwnProperty('children')) {
                    item.bodyDom = plantTree(item.wrapperDom, item.children);
                }
                ul.appendChild(item.wrapperDom);
            });
            parent.appendChild(ul);
            return ul;
        }
        plantTree(outer, data);
        let list = outer.childNodes[0].childNodes;
        [...list].forEach(item => {
            fragment.appendChild(item);
        });
        this.targetDom.appendChild(fragment);
        this.options.onPlanted && this.options.onPlanted.call(this);
        'planted' in this.handlers ? this.emit('planted', '') : null;
    }
    initAttribute() {
        !this.targetDom.classList.contains('ax-menu') ? this.targetDom.classList.add('ax-menu') : null;
        this.options.targetClass ? axClass.add(this.targetDom, this.options.targetClass) : null;
        this.targetDom.setAttribute('theme', this.options.theme);
        this.options.gapless ? this.targetDom.setAttribute('gapless', '') : null;
        this.options.lamp ? this.targetDom.setAttribute('lamp', this.options.lamp) : null;
        this.options.full && !this.options.nav.enable ? this.targetDom.setAttribute('full', '') : null;
        if (this.options.nav.enable) {
            this.targetDom.setAttribute('nav', '');
            this.options.nav.align ? this.targetDom.setAttribute('align', this.options.nav.align) : null;
            if (this.options.nav.headerWidth) {
                let firstObj = this.flatData.filter(k => k.floor === 1);
                firstObj.forEach(k => {
                    k.wrapperDom.style.width = this.options.nav.headerWidth;
                });
            }
            if (this.options.nav.bodyWidth) {
                this.flatData.forEach(k => {
                    k.bodyDom ? k.bodyDom.style.width = this.options.nav.bodyWidth : null;
                })
            }
            if (this.options.nav.marginLeft) {
                this.flatData.filter(k => k.floor === 1).forEach(k => {
                    k.wrapperDom.style.marginLeft = this.options.nav.marginLeft;
                })
            }
            if (this.options.nav.marginRight) {
                this.flatData.filter(k => k.floor === 1).forEach(k => {
                    k.wrapperDom.style.marginRight = this.options.nav.marginRight;
                })
            }
        }
    }
    getPathIds(data) {
        if (data.length === 0) {
            return [];
        }
        let idsArr = [],
            idsItems = !this.options.multiple ? data.slice(0, 1) : data;
        idsItems.forEach(k => {
            let item = axFindItem(k, this.flatData), idsPath;
            if (item) {
                idsPath = item.path.split('>');
                idsArr.push(...idsPath);
            }
        });
        return [...new Set(idsArr)].map(k => parseInt(k));
    }
    initActive() {
        if (this.flatData.length === 0) {
            return false;
        }
        if (this.options.multiple && !this.options.collapseAll) {
            this.expandAll();
        } else {
            let itemsActive = this.options.active !== '' ? axValueToArr(this.options.active) : [],
                idsActive;
            itemsActive.push(...this.flatData.filter(k => k.selected), ...this.flatData.filter(k => k.expanded));
            idsActive = this.getPathIds(itemsActive);
            this.flatData.forEach(k => {
                if (idsActive.includes(k.id)) {
                    if (k.children) {
                        this.expand(k);
                    } else {
                        this.triggerSelected(k);
                    }
                }
            });
        }
    }
    initDisabled() {
        if (this.flatData.length === 0) {
            return false;
        }
        let items = this.flatData.filter(k => k.disabled),
            itemArr = this.options.disabled !== '' ? axValueToArr(this.options.disabled) : [];
        itemArr.push(...items);
        itemArr.forEach(k => {
            let item = axFindItem(k, this.flatData);
            if (item) {
                item.disabled = true;
                item.headerDom.setAttribute('disabled', '');
            }
        });
    }
    renderFinish() {
        if (!this.options.dispose) {
            this.flatData.forEach(k => {
                if (k.children) {
                    if (!k.disabled) {
                        let triggerDom = k.url && k.arrowDom ? k.arrowDom : k.headerDom;
                        if (this.options.trigger === 'click') {
                            triggerDom.addEventListener(this.options.trigger, this.triggerShow, false);
                        } else if (this.options.trigger === 'hover') {
                            this.hover = new axHover(k.wrapperDom, {
                                enter: () => {
                                    this.expand(k);
                                },
                                leave: () => {
                                    this.collapse(k);
                                }
                            });
                        }
                    }
                } else {
                    if (!k.disabled) {
                        k.headerDom.onclick = () => {
                            this.triggerSelected(k);
                        }
                    }
                }
            });
        }
       this.save();
    }
    workToggle(item, type = 'disable') {
        let triggerDom = item.url && item.arrowDom ? item.arrowDom : item.headerDom;
        if (type === 'enable') {
            item.disabled ? delete item.disabled : null;
            item.headerDom.removeAttribute('disabled');
            if (!item.children) {
                item.headerDom.onclick = () => {
                    this.triggerSelected(item);
                }
            } else {
                triggerDom.addEventListener(this.options.trigger, this.triggerShow, false);
            }
        } else if (type === 'disable') {
            item.disabled = true;
            item.headerDom.setAttribute('disabled', '');
            if (!item.children) {
                item.headerDom.onclick = null;
            } else {
                triggerDom.removeEventListener(this.options.trigger, this.triggerShow, false);
            }
        }
        this.save();
    }
    getDisabled() {
        return this.flatData.filter(k => k.disabled);
    }
    getExpanded() {
        return this.flatData.filter(k => k.expanded);
    }
    getActive() {
        return this.flatData.filter(k => k.expanded || k.selected);
    }
    getSelected() {
        return this.flatData.find(k => k.selected);
    }
    collapseAll(callback) {
        if (this.destroyed) {
            return this;
        }
        this.flatData.filter(k => k.expanded).forEach(k => {
            this.collapse(k);
        });
        'collapseAll' in this.handlers ? this.emit('collapseAll', '') : null;
        this.options.onCollapseAll && this.options.onCollapseAll.call(this);
        callback && callback.call(this);
    }
    expandAll(callback) {
        if (this.destroyed || !this.options.multiple) {
            return this;
        }
        this.flatData.forEach(k => {
            this.expand(k);
        });
        'expandAll' in this.handlers ? this.emit('expandAll', '') : null;
        this.options.onExpandAll && this.options.onExpandAll.call(this);
        callback && callback.call(this);
    }
    disable(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        if (obj !== 0 && axIsEmpty(obj)) {
            return false;
        }
        let disableFun = (k) => {
            let item = axFindItem(k, this.flatData);
            if (item) {
                this.workToggle(item, 'disable');
            }
        }
        if (Array.isArray(obj)) {
            obj.forEach(k => {
                disableFun(k);
            });
        } else {
            disableFun(obj);
        }
        this.save();
        let disableds = this.flatData.filter(k => k.disabled);
        'disable' in this.handlers ? this.emit('disable', disableds) : null;
        this.options.onDisable && this.options.onDisable.call(this, disableds);
        callback && callback.call(this, disableds);
    }
    disableAll(callback) {
        this.disable(this.flatData);
        'disableAll' in this.handlers ? this.emit('disableAll', '') : null;
        this.options.onDisableAll && this.options.onDisableAll.call(this);
        callback && callback.call(this);
    }
    enable(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        if (obj !== 0 && axIsEmpty(obj)) {
            return false;
        }
        let enableFun = (k) => {
            let item = axFindItem(k, this.flatData);
            if (item) {
                this.workToggle(item, 'enable');
            }
        }
        if (Array.isArray(obj)) {
            obj.forEach(k => {
                enableFun(k);
            });
        } else {
            enableFun(obj);
        }
        this.save();
        let enableds = this.flatData.filter(k => !k.disabled);
        'enable' in this.handlers ? this.emit('enable', enableds) : null;
        this.options.onEnable && this.options.onEnable.call(this, enableds);
        callback && callback.call(this, enableds);
    }
    enableAll(callback) {
        this.enable(this.flatData);
        'enableAll' in this.handlers ? this.emit('enableAll', '') : null;
        this.options.onEnableAll && this.options.onEnableAll.call(this);
        callback && callback.call(this);
    }
    toggle(obj) {
        let item = axFindItem(obj, this.flatData) || axFindItem(obj, this.flatData, { header: 'arrowDom' });
        if (item.expanded) {
            this.collapse(item);
        } else {
            this.expand(item);
        }
    }
    collapse(obj, callback) {
        let type = axType(obj),
            item = type === 'Object' ? obj : axFindItem(obj, this.flatData);
        if (!item || !item.children) {
            return false;
        }
        'collapse' in this.handlers ? this.emit('collapse', item) : null;
        this.options.onCollapse && this.options.onCollapse.call(this, item);
        delete item.expanded;
        item.wrapperDom.removeAttribute('expanded');
        axSlideUp(item.bodyDom, () => {
            'collapsed' in this.handlers ? this.emit('collapsed', item) : null;
            this.options.onCollapsed && this.options.onCollapsed.call(this, item);
            callback && callback.call(this, item);
        });
        this.save();
    }
    expand(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        let item = axFindItem(obj, this.flatData), others;
        if (!axIsEmpty(item) && item.children) {
            'expand' in this.handlers ? this.emit('expand', item) : null;
            this.options.onExpand && this.options.onExpand.call(this, item);
            item.expanded = true;
            item.wrapperDom.setAttribute('expanded', '');
            axSlideDown(item.bodyDom, () => {
                'expanded' in this.handlers ? this.emit('expanded', item) : null;
                this.options.onExpanded && this.options.onExpanded.call(this, item);
                callback && callback.call(this, item);
            });
            if (!this.options.multiple) {
                others = this.flatData.filter(k => (k !== item && k.expanded && k.floor === item.floor && k.children));
                others.forEach(k => {
                    this.collapse(k);
                });
            }
            this.save();
        }
    }
    active(obj, callback) {
        if (this.destroyed) {
            return this;
        }
        let activeArr = [],
            activeItems = [],
            activeFun = (k) => {
                let item = axFindItem(k, this.flatData);
                if (item) {
                    let ids = item.path.split('>').map(k => parseInt(k));
                    ids.forEach(k => {
                        this.expand(k);
                    });
                    if (!item.children) {
                        this.triggerSelected(item);
                    }
                }
            }
        if (Array.isArray(obj)) {
            if (!this.options.multiple) {
                activeArr = obj.slice(0, 1);
            } else {
                activeArr = obj
            }
        } else {
            activeArr = [obj]
        }
        activeItems = activeArr.map(k => axFindItem(k, this.flatData)).filter(Boolean);
        activeArr.forEach(k => {
            activeFun(k);
        });
        'active' in this.handlers ? this.emit('active', activeItems) : null;
        this.options.onActive && this.options.onActive.call(this, activeItems);
        callback && callback.call(this, activeItems);
        this.save();
    }
    add(data, target, isChild = false, isFront = false, callback) {
        if (this.destroyed) {
            return this;
        }
        if (this.flatData.length >= this.options.max && this.options.max !== 0) {
            console.warn('The number of children exceeds the maximum!');
            return false;
        }
        let type = axType(data),
            items = [],
            appendFun = (source, target, isChild, isFront) => {
                let targetData;
                if (source.hasOwnProperty('pId') && source.pId !== this.options.firstFloor) {
                    targetData = axFindItem(source.pId, this.flatData);
                    isChild = true;
                } else {
                    if (target === undefined || target === 'end') {
                        targetData = this.flatData.filter(k => k.floor === 1).slice(-1)[0];
                    } else if (target === 'start') {
                        targetData = this.flatData.filter(k => k.floor === 1)[0];
                        isFront = true;
                    } else {
                        targetData = axFindItem(target, this.flatData);
                    }
                }
                let sourceData = axTreeMethod.createData(source, targetData, this.flatData, isChild);
                this.createHeaderDom(sourceData);
                if (isChild) {
                    if (targetData.children) {
                        axTreeMethod.existChildPush(sourceData, targetData);
                    } else {
                        axTreeMethod.noExistChildPush(sourceData, targetData, () => {
                            return this.childToParent(targetData);
                        });
                    }
                } else {
                    let parent = this.flatData.find(i => i.id == targetData.pId),
                        children = parent ? parent.children : this.treeData,
                        index = children.indexOf(targetData);
                    if (isFront) {
                        index == 0 ? children.unshift(sourceData) : children.splice(index, 0, sourceData);
                        targetData.wrapperDom.insertAdjacentElement('beforeBegin', sourceData.wrapperDom);
                    } else {
                        children.splice(index + 1, 0, sourceData);
                        targetData.wrapperDom.insertAdjacentElement('afterEnd', sourceData.wrapperDom);
                    }
                }
                this.flatData.push(sourceData);
                items.push(sourceData);
            };
        if (type === 'Array' && data.length > 0) {
            data.forEach(k => {
                appendFun(k, target, isChild, isFront);
            });
        } else {
            appendFun(data, target, isChild, isFront);
        }
        if (items.length > 0) {
            if (this.options.addToActive) {
                if (this.options.multiple) {
                    items.forEach(k => {
                        k.children ? this.expand(k) : null;
                    });
                } else {
                    let lastItem = items[items.length - 1];
                    lastItem.children ? this.expand(lastItem) : null;
                }
            }
            this.renderFinish();
        }
        'add' in this.handlers ? this.emit('add', items) : null;
        this.options.onAdd && this.options.onAdd.call(this, items);
        callback && callback.call(this, items);
        return this;
    }
    remove(data, callback) {
        if (this.destroyed) {
            return this;
        }
        if (axIsEmpty(data)) {
            return false;
        }
        if (this.flatData.length === 0) {
            console.warn('The data is already empty!');
            return false;
        }
        let removeItem = (child) => {
            let item = axFindItem(child, this.flatData),
                data;
            if (item) {
                data = axTreeMethod.remove(item, this.flatData, this.treeData);
                this.flatData = data.flat;
                this.treeData = data.tree;
            }
        };
        if (Array.isArray(data)) {
            data.forEach(k => {
                removeItem(k);
            });
        } else {
            removeItem(data);
        }
        this.save();
        'remove' in this.handlers ? this.emit('remove', '') : null;
        this.options.onRemove && this.options.onRemove.call(this);
        callback && callback.call(this);
        return this;
    }
    save(props, callback) {
        if (this.destroyed) {
            return this;
        }
        if (!this.options.storageName) {
            return false;
        }
        setTimeout(() => {
            let idsActive = [...this.flatData.filter(k => k.selected), ...this.flatData.filter(k => k.expanded)].filter(Boolean).map(k => k.id),
                idsDisabled = this.flatData.filter(k => k.disabled).map(k => k.id);
            if (!props) {
                axLocalStorage.set(this.options.storageName, { active: idsActive, disabled: idsDisabled, content: this.flatData });
            } else {
                !props.hasOwnProperty('active') ? props.active = idsActive : null;
                !props.hasOwnProperty('disabled') ? props.disabled = idsDisabled : null;
                !props.hasOwnProperty('content') ? props.content = this.flatData : null;
                axLocalStorage.set(this.options.storageName, props);
            }
            let getValue = axLocalStorage.get(this.options.storageName);
            'save' in this.handlers ? this.emit('save', getValue) : null;
            this.options.onSave && this.options.onSave.call(this, getValue);
            callback && callback.call(this, getValue);
            return this;
        }, 0)
    }
    destroy(callback) {
        this.flatData.forEach(k => {
            let triggerDom = k.url && k.arrowDom ? k.arrowDom : k.headerDom;
            triggerDom.removeEventListener(this.options.trigger, this.triggerShow);
            k.headerDom.onclick = null;
        });
        this.destroyed = true;
        this.options.storageName ? axLocalStorage.set(this.options.storageName, {}) : null;
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.options.onDestroy && this.options.onDestroy.call(this);
        callback && callback.call(this);
        return this;
    }
    updateContent(item, content, callback) {
        if (this.destroyed) {
            return this;
        }
        let me = axFindItem(item, this.flatData);
        if (me) {
            if (axType(content) === 'String') {
                me.label = content;
                me.labelDom.innerHTML = content;
            } else if (axType(content) === 'Object') {
                if (content.label) {
                    me.label = content.label;
                    me.labelDom.innerHTML = content.label;
                }
                if (content.url && me.url) {
                    me.url = content.url;
                    me.labelDom.href = content.url;
                }
                if (content.target && me.url) {
                    me.target = content.target;
                    me.labelDom.target = content.target;
                }
            }
            'updateContent' in this.handlers ? this.emit('updateContent', me) : null;
            this.options.onUpdateContent && this.options.onUpdateContent.call(this, me);
            callback && callback.call(this, me);
            this.save();
        }
        return this;
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        this.options = axExtend(this.options, setting);
        this.options.storageName ? axLocalStorage.set(this.options.storageName, {}) : null;
        this.targetDom.innerHTML = this.rawHTML ? this.rawHTML : '';
        this.init();
        'update' in this.handlers ? this.emit('update', '') : null;
        this.options.onUpdate && this.options.onUpdate.call(this);
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
document.querySelectorAll('[axMenu]').forEach(element => {
    new axMenu(element);
});
/*!
* 插件：黏住顶部或盒子；使用方法：new axStick('#id',{参数})
*/
const axSticks = [];
class axStick {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            refer: 'body',
            space: '0px',
            width: '',
            zIndex: '',
        }, options, this.targetDom,'axStick');
        let _this = this;
        this.handlers = {};
        this.height = this.targetDom.offsetHeight;
        this.width = this.targetDom.offsetWidth;
        this.left = axOffset(this.targetDom).left;
        this.top = axOffset(this.targetDom).top;
        this.bottom = axOffset(this.targetDom).top + this.height;
        this.style = this.targetDom.getAttribute('style');
        this.placeholder = axAddElem('DIV', { style: `width:${this.width}px;height:${this.height}px;display:none;` });
        this.targetDom.insertAdjacentElement('beforebegin', this.placeholder);
        !!this.targetDom.getAttribute('axStick') ? this.referName = this.targetDom.getAttribute('axStick') : this.referName = '';
        this.init();
    }
    init() {
        this.refer = this.targetDom.closest(this.options.refer);
        this.referHeight = this.refer.offsetHeight;
        this.referWidth = this.refer.offsetWidth;
        this.referLeft = axOffset(this.refer).left;
        this.referTop = axOffset(this.refer).top;
        this.referBottom = axOffset(this.refer).top + this.referHeight;
        if (this.options.refer !== 'body' && (getComputedStyle(this.refer).position !== 'fixed' || getComputedStyle(this.refer).position !== 'absolute')) {
            this.refer.style.position = 'relative';
        }
        this.options.zIndex ? this.targetDom.style.zIndex = this.options.zIndex : null;
        getComputedStyle(this.targetDom).float !== 'none' ? this.placeholder.style.float = getComputedStyle(this.targetDom).float : null;
        let _this = this;
        window.addEventListener("scroll", () => {
            if (_this.height > window.innerHeight) {
                if (_this.bottom < document.documentElement.scrollTop + window.innerHeight && _this.referBottom > document.documentElement.scrollTop + window.innerHeight) {
                    _this.targetDom.style.cssText += `width:${_this.targetDom.offsetWidth}px;`;
                    _this.targetDom.style.cssText += `left:${axOffset(_this.targetDom).left}px;`
                    _this.targetDom.style.cssText += `position:fixed;bottom:${_this.options.space};margin:0;`;
                    _this.placeholder.style.display = 'block';
                    'sticked' in _this.handlers ? _this.emit('sticked', 'fixed') : null;
                } else if (_this.referBottom < document.documentElement.scrollTop + window.innerHeight) {
                    _this.targetDom.style.position = 'absolute';
                    _this.targetDom.style.left = _this.left - _this.referLeft + 'px';
                    _this.targetDom.style.cssText += `position:absolute;bottom:${_this.options.space};margin:0;`;
                    _this.placeholder.style.display = 'none';
                    'sticked' in _this.handlers ? _this.emit('sticked', 'absolute') : null;
                } else if (axOffset(_this.refer).top > document.documentElement.scrollTop) {
                    _this.targetDom.setAttribute('style', _this.style);
                    _this.placeholder.style.display = 'none';
                    'unsticked' in _this.handlers ? _this.emit('unsticked', '') : null;
                }
            } else {
                if (_this.top < document.documentElement.scrollTop) {
                    if (!_this.options.width) {
                        _this.targetDom.style.cssText += `width:${_this.targetDom.offsetWidth}px;`;
                        _this.targetDom.style.cssText += `left:${_this.left}px;`
                    } else {
                        _this.targetDom.style.cssText += `width:${_this.options.width};`;
                        _this.targetDom.style.cssText += `left:calc(50% - ${_this.options.width}/2);`;
                    }
                    _this.targetDom.style.cssText += `position:fixed;top:${_this.options.space};bottom:auto;margin:0;`;
                    _this.placeholder.style.display = 'block';
                    'sticked' in _this.handlers ? _this.emit('sticked', 'fixed') : null;
                    if (_this.height > _this.referBottom - document.documentElement.scrollTop) {
                        _this.targetDom.style.position = 'absolute';
                        _this.targetDom.style.left = _this.left - _this.referLeft + 'px';
                        _this.targetDom.style.top = 'auto';
                        _this.targetDom.style.bottom = 0;
                        'sticked' in _this.handlers ? _this.emit('sticked', 'absolute') : null;
                    }
                } else {
                    _this.targetDom.setAttribute('style', _this.style);
                    _this.placeholder.style.display = 'none';
                    'unsticked' in _this.handlers ? _this.emit('unsticked', '') : null;
                }
            }
        }, false);
        if (this.referName) {
            if (axIsEmpty(axSticks)) {
                axSticks.push({ name: this.referName, instance: this });
            } else {
                if (!axSticks.some(item => (item.name == this.referName))) {
                    axSticks.push({ name: this.referName, instance: this });
                }
                /* for (let i = 0; i < axSticks.length; i++) {
                    if (axSticks[i].name == this.referName) {
                        axSticks[i].instance = this;
                        break;
                    } else {
                        axSticks.push({ name: this.referName, instance: this });
                    }
                } */
            }
        }
    }
    destroy(callback) {
        this.targetDom.lastChild.removeEventListener('click', this.event, false);
        this.targetDom.innerHTML = this.html;
        callback && callback.call(this);
    }
    update(setting, callback) {
        let _this = this;
        this.targetDom.style = this.style;
        this.options = axExtend(this.options, setting);
        this.init();
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axStick]').forEach(element => {
        new axStick(element);
    });
})();
/*!
* 插件：轮滑选择；改造自mobile-select 20201110更新 https://github.com/onlyhom/mobile-select；使用方法：new axScrollSelect('#id',{参数})
*/
const axScrollSelects = [];
(() => {
    const getClass = (dom, string) => {
        return dom.getElementsByClassName(string);
    }
    const wheel = (dom, handle, callback, capture) => {
        let eventCompat = function (event) {
            let type = event.type;
            if (type == 'DOMMouseScroll' || type == 'mousewheel') {
                event.delta = (event.wheelDelta) ? event.wheelDelta / 120 : -(event.detail || 0) / 3;
            }
            if (event.srcElement && !event.target) {
                event.target = event.srcElement;
            }
            axPreventDefault(event);
            /* if (!event.preventDefault && event.returnValue !== undefined) {
                event.preventDefault = function () {
                    event.returnValue = false;
                };
            } */
            return event;
        };
        return function () {
            if (handle === "mousewheel" && document.mozFullScreen !== undefined) {
                handle = "DOMMouseScroll";
            }
            dom.addEventListener(handle, function (event) {
                callback.call(this, eventCompat(event));
            }, capture || false);
        }();
    }
    class axScrollSelect {
        constructor(targetDom, options) {
            this.targetDom = axIdToDom(targetDom);
            this.options = axExtend({
                wheels: [],
                title: '',
                position: [],
                final: false,
                connector: ' ',
                confirmText: '确认',
                cancelText: '取消',
                className: '',
                type: 'actionbar',
                labels: '',
                keyMap: { id: 'id', name: 'name', value: 'value', children: 'children' },
                triggerDisplayData: true,
                callback: function () { },
                transitionEnd: function () { },
                cancel: function () { },
                onShow: function () { },
                onHide: function () { },
            }, options, this.targetDom,'axScrollSelect');
            this.jsonType = false;
            this.cascadeJsonData = [];
            this.displayJson = [];
            this.curValue = null;
            this.curIndexArr = [];
            this.cascade = false;
            this.startY;
            this.moveEndY;
            this.moveY;
            this.oldMoveY;
            this.offset = 0;
            this.offsetSum = 0;
            this.oversizeBorder;
            this.curDistance = [];
            this.clickStatus = false;
            this.init();
            this.targetDom.setAttribute('autocomplete', 'off');
            this.targetDom.setAttribute('readonly', 'true');
        }
        init() {
            let _this = this;
            if (typeof _this.options.wheels === 'string' && _this.options.wheels.indexOf('#') != -1) {
                if (document.querySelector(_this.options.wheels).nodeName == 'UL') {
                    _this.options.wheels = [{ data: axUlToArr(_this.options.wheels) }]
                } else if (document.querySelector(_this.options.wheels).nodeName == 'SELECT') {
                    _this.options.wheels = [{ data: axSelectToArr(_this.options.wheels) }]
                }
            } else if (_this.options.wheels.indexOf('date') == 0) {
                let dateArr = _this.options.wheels.split("-"),
                    dateStart = dateArr[1],
                    dateEnd = dateArr[2],
                    dateFormat = dateArr[3];
                _this.options.wheels = _this.getDate(dateStart, dateEnd, dateFormat);
            }
            _this.checkDataType();
            _this.renderWheels(_this.options.wheels, this.options.cancelText, this.options.confirmText);
            if (!_this.targetDom) {
                console.error('SwiperSelect instance has been created , but there is no trigger is found on page.');
                return false;
            }
            _this.targetDom.style.cursor = 'pointer';
            _this.checkCascade();
            _this.addListenerAll();
            if (_this.cascade) {
                _this.initCascade();
            }
            let colHTML = '';
            for (let i = 0; i < _this.wheel.length; i++) {
                if (!axIsEmpty(_this.options.labels)) {
                    colHTML += '<li>' + _this.options.labels[i] + '</li>';
                }
            }
            _this.group.innerHTML = colHTML;
            if (_this.options.position.length < _this.slider.length) {
                let diff = _this.slider.length - _this.options.position.length;
                for (let i = 0; i < diff; i++) {
                    _this.options.position.push(0);
                }
            }
            _this.setCurDistance(_this.options.position);
            _this.cancelBtn.addEventListener('click', function (event) {
                _this.hide();
                _this.popup ? _this.popup.hide() : null;
            });
            _this.ensureBtn.addEventListener('click', function (event) {
                _this.hide();
                _this.popup ? _this.popup.hide() : null;
                if (!_this.liHeight) {
                    _this.liHeight = _this.mobileSelect.querySelector('li').offsetHeight;
                }
                _this.setValue();
                _this.curIndexArr = _this.getIndexArr();
                _this.curValue = _this.getCurValue();
                _this.options.callback.call(_this, _this.curIndexArr, _this.curValue);
            });
            _this.targetDom.addEventListener('click', function (event) {
                _this.show();
            });
            if (_this.grayLayer) {
                _this.grayLayer.addEventListener('click', function (event) {
                    _this.hide();
                });
            }
            _this.wrapper.addEventListener('click', function (event) {
                event.stopPropagation();
            });
            _this.fixRowStyle(); 
        }
        setValue(value) {
            let _this = this;
            let tempValue = '';
            if (_this.options.final) {
                tempValue = _this.getCurValue()[_this.getCurValue().length - 1].value;
            } else {
                for (let i = 0; i < _this.wheel.length; i++) {
                    i == _this.wheel.length - 1 ? tempValue += _this.getInnerHtml(i) : tempValue += _this.getInnerHtml(i) + _this.options.connector;
                }
            }
            if (_this.options.triggerDisplayData) {
                if (_this.targetDom.nodeName == 'INPUT') {
                    value ? _this.targetDom.value = value : _this.targetDom.value = tempValue;
                } else {
                    value ? _this.targetDom.innerHTML = value : _this.targetDom.innerHTML = tempValue;
                }
            }
        }
        getDate(start, end, format) {
            let _this = this,
                _start = start,
                _end = end,
                loadArr = [];
            let now = new Date();
            if (_start == 'auto' && _end == 'auto') {
                start = now.getFullYear() - 20;
                end = now.getFullYear();
                now.getDate()
                loadArr.push(0, now.getMonth());
            } else if (_end > _start) {
                loadArr.push(0, 0);
            }
            let dateData = [{ data: [] }];
            let returnDayLen = function (year, month) {
                if ([1,3,5,7,8,10,12].includes(month)) {
                    return 31
                } else if (month == 2) {
                    if (year % 4 == 0 && year % 100 != 0) {
                        return 29
                    } else if (year % 400 == 0) {
                        return 29
                    } else {
                        return 28
                    }
                } else {
                    return 30
                }
            };
            for (let i = end; i >= start; i--) {
                if (i == 0) {
                    return;
                }
                let data = { id: i, name: i + "年", value: i, children: [] };
                for (let k = 1; k <= 12; k++) {
                    if (format.toUpperCase() == 'YMD') {
                        let dayArr = [];
                        let len = returnDayLen(i, k);
                        for (let x = 1; x <= len; x++) {
                            dayArr.push({ id: x, name: x + "日", value: x })
                        }
                        data.children.push({ id: k, name: k + "月", value: k, children: dayArr });
                        if (_start == 'auto' && _end == 'auto') {
                            loadArr.push(now.getDate() - 1);
                        } else if (_end > _start) {
                            loadArr.push(0);
                        }
                    } else if (format.toUpperCase() == 'YM') {
                        data.children.push({ id: k, name: k + "月", value: k });
                    }
                }
                dateData[0].data.push(data);
            }
            axIsEmpty(_this.options.position) ? _this.options.position = loadArr : null;
            _this.options.connector = '-';
            return dateData
        }
        show() {
            this.mobileSelect.classList.add('ax-show');
            if (typeof this.options.onShow === 'function') {
                this.options.onShow(this);
            }
        }
        hide() {
            this.mobileSelect.classList.remove('ax-show');
            if (typeof this.options.onHide === 'function') {
                this.options.onHide(this);
            }
        }
        renderWheels(wheelsData) {
            let _this = this;
            let tempHTML = '';
            for (let i = 0; i < wheelsData.length; i++) {
                tempHTML += '<div class="ax-wheel"><ul class="ax-item-list">';
                if (_this.jsonType) {
                    for (let j = 0; j < wheelsData[i].data.length; j++) {
                        tempHTML += '<li data-id="' + wheelsData[i].data[j][_this.options.keyMap.id] + '">' + wheelsData[i].data[j][_this.options.keyMap.name] + '</li>';
                    }
                } else {
                    for (let j = 0; j < wheelsData[i].data.length; j++) {
                        tempHTML += '<li>' + wheelsData[i].data[j] + '</li>';
                    }
                }
                tempHTML += '</ul></div>';
            }
            if (!this.options.title) {
                if (this.targetDom.nodeName == 'INPUT') {
                    if (this.targetDom.getAttribute('placeholder')) {
                        this.options.title = this.targetDom.getAttribute('placeholder');
                    } else if (this.targetDom.getAttribute('value')) {
                        this.options.title = this.targetDom.getAttribute("value");
                    } else {
                        this.options.title = '';
                    }
                } else {
                    this.options.title = this.targetDom.textContent.trim().replace(/<[^>]+>/g, '').replace(/ +/g, ' ');
                }
            }
            this.template =
                axTplEngine(`
            <div class="ax-scrollSelect<# if(this.className){ #> <# this.className #><# } #>" data-type="<# this.type #>" id="scrollSelect${new Date().getTime()}">
            <# if(this.type == 'actionbar'){ #><div class="ax-scrollSelect-overlay"></div><# } #>
            <div class="ax-scrollSelect-wrapper">
                <div class="ax-scrollSelect-header">
                    <div class="ax-inner">
                        <a href="###" class="ax-cancel"><# this.cancelText #></a>
                        <div class="ax-title"><# this.title #></div>
                        <a href="###" class="ax-confirm"><# this.confirmText #></a>
                    </div>
                </div>
                <div class="ax-group"></div>
                <div class="ax-scrollSelect-body">
                    <div class="ax-inner">
                        <div class="ax-wheels"></div>
                        <div class="ax-line"></div>
                        <div class="ax-mask"></div>
                    </div>
                </div>
            </div>
        </div>
          `, this.options);
            _this.mobileSelect = axStrToDom(this.template);
            _this.wheels = _this.mobileSelect.querySelector('.ax-wheels')
            _this.wheels.innerHTML = tempHTML;
            if (_this.options.type == 'actionbar') {
                document.body.appendChild(_this.mobileSelect);
            } else if (_this.options.type == 'popup') {
                _this.popup = new axPopup(this.targetDom, {
                    content: _this.mobileSelect,
                    padding: false,
                    placement: 'bottom-start',
                    close: false,
                    footerShow: false,
                });
            } else if (_this.options.type == 'inline') {
                _this.targetDom.insertAdjacentElement('afterEnd', _this.mobileSelect);
                _this.header = _this.mobileSelect.querySelector('.ax-scrollSelect-header');
                _this.header.style.display = 'none';
            }
            _this.wheel = getClass(_this.mobileSelect, 'ax-wheel');
            _this.slider = getClass(_this.mobileSelect, 'ax-item-list');
            _this.wheels = _this.mobileSelect.querySelector('.ax-wheels');
            _this.liHeight = _this.mobileSelect.querySelector('li').offsetHeight;
            _this.ensureBtn = _this.mobileSelect.querySelector('.ax-confirm');
            _this.cancelBtn = _this.mobileSelect.querySelector('.ax-cancel');
            _this.grayLayer = _this.mobileSelect.querySelector('.ax-scrollSelect-overlay');
            _this.wrapper = _this.mobileSelect.querySelector('.ax-scrollSelect-wrapper');
            _this.body = _this.mobileSelect.querySelector('.ax-scrollSelect-body');
            _this.group = _this.mobileSelect.querySelector('.ax-group');
            _this.title = _this.mobileSelect.querySelector('.ax-title');
            axPreventScroll(_this.wrapper);
        }
        addListenerAll() {
            let _this = this;
            for (let i = 0; i < _this.slider.length; i++) {
                (function (i) {
                    _this.addListenerWheel(_this.wheel[i], i);
                })(i);
            }
        }
        addListenerWheel(theWheel, index) {
            let _this = this;
            theWheel.addEventListener('touchstart', function (event) {
                _this.touch(event, this.firstChild, index);
            }, false);
            theWheel.addEventListener('touchend', function (event) {
                _this.touch(event, this.firstChild, index);
            }, false);
            theWheel.addEventListener('touchmove', function (event) {
                _this.touch(event, this.firstChild, index);
            }, false);
            if (!axIsMobi()) {
                theWheel.addEventListener('mousedown', function (event) {
                    _this.dragClick(event, this.firstChild, index);
                }, false);
                theWheel.addEventListener('mousemove', function (event) {
                    _this.dragClick(event, this.firstChild, index);
                }, false);
                theWheel.addEventListener('mouseup', function (event) {
                    _this.dragClick(event, this.firstChild, index);
                }, true);
                wheel(theWheel, "mousewheel", function (event) {
                    if (event.delta < 0) {
                        event.direction = 'wheelUp';
                    } else if (event.delta > 0) {
                        event.direction = 'wheelDown';
                    }
                    _this.dragClick(event, this.firstChild, index);
                });
            }
        }
        checkDataType() {
            let _this = this;
            if (typeof (_this.options.wheels[0].data[0]) == 'object') {
                _this.jsonType = true;
            }
        }
        checkCascade() {
            let _this = this;
            if (_this.jsonType) {
                let node = _this.options.wheels[0].data;
                for (let i = 0; i < node.length; i++) {
                    if (_this.options.keyMap.children in node[i] && node[i][_this.options.keyMap.children].length > 0) {
                        _this.cascade = true;
                        _this.cascadeJsonData = _this.options.wheels[0].data;
                        break;
                    }
                }
            } else {
                _this.cascade = false;
            }
        }
        generateArrData(targetArr) {
            let tempArr = [];
            let keyMap_id = this.options.keyMap.id;
            let keyMap_value = this.options.keyMap.value;
            let keyMap_name = this.options.keyMap.name;
            for (let i = 0; i < targetArr.length; i++) {
                let tempObj = {};
                tempObj[keyMap_id] = targetArr[i][this.options.keyMap.id];
                tempObj[keyMap_value] = targetArr[i][this.options.keyMap.value];
                tempObj[keyMap_name] = targetArr[i][this.options.keyMap.name];
                tempArr.push(tempObj);
            }
            return tempArr;
        }
        initCascade() {
            let _this = this;
            _this.displayJson.push(_this.generateArrData(_this.cascadeJsonData));
            if (_this.options.position.length > 0) {
                _this.initDeepCount = 0;
                _this.initCheckArrDeep(_this.cascadeJsonData[_this.options.position[0]]);
            } else {
                _this.checkArrDeep(_this.cascadeJsonData[0]);
            }
            _this.reRenderWheels();
        }
        initCheckArrDeep(parent) {
            let _this = this;
            if (parent) {
                if (_this.options.keyMap.children in parent && parent[_this.options.keyMap.children].length > 0) {
                    _this.displayJson.push(_this.generateArrData(parent[_this.options.keyMap.children]));
                    _this.initDeepCount++;
                    let nextNode = parent[_this.options.keyMap.children][_this.options.position[_this.initDeepCount]];
                    if (nextNode) {
                        _this.initCheckArrDeep(nextNode);
                    } else {
                        _this.checkArrDeep(parent[_this.options.keyMap.children][0]);
                    }
                }
            }
        }
        checkArrDeep(parent) {
            let _this = this;
            if (parent) {
                if (_this.options.keyMap.children in parent && parent[_this.options.keyMap.children].length > 0) {
                    _this.displayJson.push(_this.generateArrData(parent[_this.options.keyMap.children])); 
                    _this.checkArrDeep(parent[_this.options.keyMap.children][0]);
                }
            }
        }
        checkRange(index, posIndexArr) {
            let _this = this;
            let deleteNum = _this.displayJson.length - 1 - index;
            for (let i = 0; i < deleteNum; i++) {
                _this.displayJson.pop(); 
            }
            let resultNode;
            for (let i = 0; i <= index; i++) {
                if (i == 0)
                    resultNode = _this.cascadeJsonData[posIndexArr[0]];
                else {
                    resultNode = resultNode[_this.options.keyMap.children][posIndexArr[i]];
                }
            }
            _this.checkArrDeep(resultNode);
            _this.reRenderWheels();
            _this.fixRowStyle();
            _this.setCurDistance(_this.resetPosition(index, posIndexArr));
        }
        resetPosition(index, posIndexArr) {
            let _this = this;
            let tempPosArr = posIndexArr;
            let tempCount;
            if (_this.slider.length > posIndexArr.length) {
                tempCount = _this.slider.length - posIndexArr.length;
                for (let i = 0; i < tempCount; i++) {
                    tempPosArr.push(0);
                }
            } else if (_this.slider.length < posIndexArr.length) {
                tempCount = posIndexArr.length - _this.slider.length;
                for (let i = 0; i < tempCount; i++) {
                    tempPosArr.pop();
                }
            }
            for (let i = index + 1; i < tempPosArr.length; i++) {
                tempPosArr[i] = 0;
            }
            return tempPosArr;
        }
        reRenderWheels() {
            let _this = this;
            if (_this.wheel.length > _this.displayJson.length) {
                let count = _this.wheel.length - _this.displayJson.length;
                for (let i = 0; i < count; i++) {
                    _this.wheels.removeChild(_this.wheel[_this.wheel.length - 1]);
                }
            }
            for (let i = 0; i < _this.displayJson.length; i++) {
                (function (i) {
                    let tempHTML = '';
                    if (_this.wheel[i]) {
                        for (let j = 0; j < _this.displayJson[i].length; j++) {
                            let name = _this.displayJson[i][j][_this.options.keyMap.name] ? _this.displayJson[i][j][_this.options.keyMap.name] : _this.displayJson[i][j][_this.options.keyMap.value];
                            tempHTML += '<li data-id="' + _this.displayJson[i][j][_this.options.keyMap.id] + '" data-value="' + _this.displayJson[i][j][_this.options.keyMap.value] + '" >'
                                + name + '</li>';
                        }
                        _this.slider[i].innerHTML = tempHTML;
                    } else {
                        let tempWheel = document.createElement("div");
                        tempWheel.className = "ax-wheel";
                        tempHTML = '<ul class="ax-item-list">';
                        for (let j = 0; j < _this.displayJson[i].length; j++) {
                            let name = _this.displayJson[i][j][_this.options.keyMap.name] ? _this.displayJson[i][j][_this.options.keyMap.name] : _this.displayJson[i][j][_this.options.keyMap.value];
                            tempHTML += '<li data-id="' + _this.displayJson[i][j][_this.options.keyMap.id] + '" data-value="' + _this.displayJson[i][j][_this.options.keyMap.value] + '">'
                                + name + '</li>';
                        }
                        tempHTML += '</ul>';
                        tempWheel.innerHTML = tempHTML;
                        _this.addListenerWheel(tempWheel, i);
                        _this.wheels.appendChild(tempWheel);
                    }
                })(i);
            }
            let colHTML = '';
            for (let i = 0; i < _this.wheel.length; i++) {
                if (!axIsEmpty(_this.options.labels)) {
                    colHTML += '<li>' + _this.options.labels[i] + '</li>';
                }
            }
            _this.group.innerHTML = colHTML;
        }
        updateWheels(data) {
            let _this = this;
            if (_this.cascade) {
                _this.cascadeJsonData = data;
                _this.displayJson = [];
                _this.initCascade();
                if (_this.options.position.length < _this.slider.length) {
                    let diff = _this.slider.length - _this.options.position.length;
                    for (let i = 0; i < diff; i++) {
                        _this.options.position.push(0);
                    }
                }
                _this.setCurDistance(_this.options.position);
                _this.fixRowStyle();
            }
        }
        updateWheel(sliderIndex, data) {
            let _this = this;
            let tempHTML = '';
            if (_this.cascade) {
                console.error('级联格式不支持updateWheel(),请使用updateWheels()更新整个数据源');
                return false;
            }
            else if (_this.jsonType) {
                for (let j = 0; j < data.length; j++) {
                    let name = data[j][_this.options.keyMap.name] ? data[j][_this.options.keyMap.name] : data[j][_this.options.keyMap.value];
                    tempHTML += '<li data-id="' + data[j][_this.options.keyMap.id] + '" data-value="' + data[j][_this.options.keyMap.value] + '">'
                        + name + '</li>';
                }
                _this.options.wheels[sliderIndex] = { data: data };
            } else {
                for (let j = 0; j < data.length; j++) {
                    tempHTML += '<li>' + data[j] + '</li>';
                }
                _this.options.wheels[sliderIndex] = data;
            }
            _this.slider[sliderIndex].innerHTML = tempHTML;
        }
        fixRowStyle() {
            let _this = this;
            let width = (100 / _this.wheel.length).toFixed(2);
            for (let i = 0; i < _this.wheel.length; i++) {
                _this.wheel[i].style.width = width + '%';
            }
        }
        getIndex(distance) {
            return Math.round((2 * this.liHeight - distance) / this.liHeight);
        }
        getIndexArr() {
            let _this = this;
            let temp = [];
            for (let i = 0; i < _this.curDistance.length; i++) {
                temp.push(_this.getIndex(_this.curDistance[i]));
            }
            return temp;
        }
        getCurValue() {
            let _this = this;
            let temp = [];
            let positionArr = _this.getIndexArr();
            if (_this.cascade) {
                for (let i = 0; i < _this.wheel.length; i++) {
                    temp.push(_this.displayJson[i][positionArr[i]]);
                }
            }
            else if (_this.jsonType) {
                for (let i = 0; i < _this.curDistance.length; i++) {
                    temp.push(_this.options.wheels[i].data[_this.getIndex(_this.curDistance[i])]);
                }
            } else {
                for (let i = 0; i < _this.curDistance.length; i++) {
                    temp.push(_this.getInnerHtml(i));
                }
            }
            return temp;
        }
        getValue() {
            return this.curValue;
        }
        calcDistance(index) {
            return 2 * this.liHeight - index * this.liHeight;
        }
        setCurDistance(indexArr) {
            let _this = this;
            let temp = [];
            for (let i = 0; i < _this.slider.length; i++) {
                temp.push(_this.calcDistance(indexArr[i]));
                _this.movePosition(_this.slider[i], temp[i]);
            }
            _this.curDistance = temp;
        }
        fixPosition(distance) {
            return -(this.getIndex(distance) - 2) * this.liHeight;
        }
        movePosition(theSlider, distance) {
            theSlider.style.webkitTransform = 'translate3d(0,' + distance + 'px, 0)';
            theSlider.style.transform = 'translate3d(0,' + distance + 'px, 0)';
        }
        locatePosition(index, posIndex) {
            let _this = this;
            this.curDistance[index] = this.calcDistance(posIndex);
            this.movePosition(this.slider[index], this.curDistance[index]);
            if (_this.cascade) {
                _this.checkRange(index, _this.getIndexArr());
            }
        }
        updateCurDistance(theSlider, index) {
            if (theSlider.style.transform) {
                this.curDistance[index] = parseInt(theSlider.style.transform.split(',')[1]);
            } else {
                this.curDistance[index] = parseInt(theSlider.style.webkitTransform.split(',')[1]);
            }
        }
        getDistance(theSlider) {
            if (theSlider.style.transform) {
                return parseInt(theSlider.style.transform.split(',')[1]);
            } else {
                return parseInt(theSlider.style.webkitTransform.split(',')[1]);
            }
        }
        getInnerHtml(sliderIndex) {
            let _this = this;
            let lengthOfList = _this.slider[sliderIndex].getElementsByTagName("li").length;
            let index = _this.getIndex(_this.curDistance[sliderIndex]);
            if (index >= lengthOfList) {
                index = lengthOfList - 1;
            } else if (index < 0) {
                index = 0;
            }
            if (_this.slider[sliderIndex].getElementsByTagName('li')[index].getAttribute('data-value')) {
                return _this.slider[sliderIndex].getElementsByTagName('li')[index].getAttribute('data-value');
            } else {
                return _this.slider[sliderIndex].getElementsByTagName('li')[index].textContent;
            }
        }
        setActive() {
            let _this = this;
            setTimeout(function () {
                if (!axIsEmpty(_this.getIndexArr())) {
                    for (let i = 0; i < _this.getIndexArr().length; i++) {
                        let list = [..._this.wheel][i].firstChild.children;
                        for (let k = 0; k < list.length; k++) {
                            list[k].classList.remove('ax-active');
                        }
                        list[_this.getIndexArr()[i]].classList.add('ax-active');
                    }
                }
            }, 100);
        }
        setTitle() {
            let _this = this;
            let titleArr = '';
            _this.getCurValue().forEach(item => {
                if (item.name) {
                    titleArr += item.name;
                } else if (item.value) {
                    titleArr += item.value;
                } else {
                    titleArr += item;
                }
            });
            _this.title.innerHTML = titleArr;
        }
        touch(event, theSlider, index) {
            let _this = this;
            event = event || window.event;
            switch (event.type) {
                case "touchstart":
                    _this.startY = event.touches[0].clientY;
                    _this.startY = parseInt(_this.startY);
                    _this.oldMoveY = _this.startY;
                    break;
                case "touchend":
                    _this.moveEndY = parseInt(event.changedTouches[0].clientY);
                    _this.offsetSum = _this.moveEndY - _this.startY;
                    _this.oversizeBorder = -(theSlider.getElementsByTagName('li').length - 3) * _this.liHeight;
                    if (_this.offsetSum == 0) {
                        let clickOffetNum = parseInt((document.documentElement.clientHeight - _this.moveEndY) / 40);
                        if (clickOffetNum != 2) {
                            let offset = clickOffetNum - 2;
                            let newDistance = _this.curDistance[index] + (offset * _this.liHeight);
                            if ((newDistance <= 2 * _this.liHeight) && (newDistance >= _this.oversizeBorder)) {
                                _this.curDistance[index] = newDistance;
                                _this.movePosition(theSlider, _this.curDistance[index]);
                                _this.options.transitionEnd.call(_this, _this.getIndexArr(), _this.getCurValue());
                            }
                        }
                        _this.options.type == 'inline' ? _this.setValue() : null;
                        _this.setTitle()
                        _this.setActive();
                    } else {
                        _this.updateCurDistance(theSlider, index);
                        _this.curDistance[index] = _this.fixPosition(_this.curDistance[index]);
                        _this.movePosition(theSlider, _this.curDistance[index]);
                        if (_this.curDistance[index] + _this.offsetSum > 2 * _this.liHeight) {
                            _this.curDistance[index] = 2 * _this.liHeight;
                            setTimeout(function () {
                                _this.movePosition(theSlider, _this.curDistance[index]);
                            }, 100);
                        } else if (_this.curDistance[index] + _this.offsetSum < _this.oversizeBorder) {
                            _this.curDistance[index] = _this.oversizeBorder;
                            setTimeout(function () {
                                _this.movePosition(theSlider, _this.curDistance[index]);
                            }, 100);
                        }
                        _this.options.transitionEnd(_this.getIndexArr(), _this.getCurValue());
                    }
                    if (_this.cascade) {
                        _this.checkRange(index, _this.getIndexArr());
                    }
                    break;
                case "touchmove":
                    axPreventDefault(event);
                    _this.moveY = event.touches[0].clientY;
                    _this.offset = _this.moveY - _this.oldMoveY;
                    _this.updateCurDistance(theSlider, index);
                    _this.curDistance[index] = _this.curDistance[index] + _this.offset;
                    _this.movePosition(theSlider, _this.curDistance[index]);
                    _this.oldMoveY = _this.moveY;
                    break;
            }
        }
        dragClick(event, theSlider, index) {
            let _this = this;
            event = event || window.event;
            _this.oversizeBorder = -(theSlider.getElementsByTagName('li').length - 3) * _this.liHeight;
            switch (event.type) {
                case "mousedown":
                    _this.startY = event.clientY;
                    _this.oldMoveY = _this.startY;
                    _this.clickStatus = true;
                    break;
                case "mouseup":
                    _this.moveEndY = event.clientY;
                    _this.offsetSum = _this.moveEndY - _this.startY;
                    if (_this.offsetSum == 0) {
                        let clickOffetNum = parseInt((document.documentElement.clientHeight - _this.moveEndY) / 40);
                        if (clickOffetNum != 2) {
                            let offset = clickOffetNum - 2;
                            let newDistance = _this.curDistance[index] + (offset * _this.liHeight);
                            if ((newDistance <= 2 * _this.liHeight) && (newDistance >= _this.oversizeBorder)) {
                                _this.curDistance[index] = newDistance;
                                _this.movePosition(theSlider, _this.curDistance[index]);
                                _this.options.transitionEnd.call(_this, _this.getIndexArr(), _this.getCurValue());
                            }
                        }
                    } else {
                        _this.updateCurDistance(theSlider, index);
                        _this.curDistance[index] = _this.fixPosition(_this.curDistance[index]);
                        _this.movePosition(theSlider, _this.curDistance[index]);
                        if (_this.curDistance[index] + _this.offsetSum > 2 * _this.liHeight) {
                            _this.curDistance[index] = 2 * _this.liHeight;
                            setTimeout(function () {
                                _this.movePosition(theSlider, _this.curDistance[index]);
                            }, 100);
                        } else if (_this.curDistance[index] + _this.offsetSum < _this.oversizeBorder) {
                            _this.curDistance[index] = _this.oversizeBorder;
                            setTimeout(function () {
                                _this.movePosition(theSlider, _this.curDistance[index]);
                            }, 100);
                        }
                        _this.options.transitionEnd(_this.getIndexArr(), _this.getCurValue());
                    }
                    _this.clickStatus = false;
                    if (_this.cascade) {
                        _this.checkRange(index, _this.getIndexArr());
                    }
                    _this.options.type == 'inline' ? _this.setValue() : null;
                    _this.setTitle();
                    _this.setActive();
                    break;
                case "mousemove":
                    axPreventDefault(event);
                    if (_this.clickStatus) {
                        _this.moveY = event.clientY;
                        _this.offset = _this.moveY - _this.oldMoveY;
                        if (_this.liHeight)
                            _this.updateCurDistance(theSlider, index);
                        _this.curDistance[index] = _this.curDistance[index] + _this.offset;
                        _this.movePosition(theSlider, _this.curDistance[index]);
                        _this.oldMoveY = _this.moveY;
                    }
                    break;
            }
            if (event.direction == 'wheelUp') {
                _this.curDistance[index] = _this.curDistance[index] - _this.liHeight;
                _this.movePosition(theSlider, _this.curDistance[index]);
                if (_this.curDistance[index] + _this.offsetSum < _this.oversizeBorder) {
                    _this.curDistance[index] = _this.oversizeBorder;
                    setTimeout(function () {
                        _this.movePosition(theSlider, _this.curDistance[index]);
                    }, 100);
                }
                _this.clickStatus = false;
                if (_this.cascade) {
                    _this.checkRange(index, _this.getIndexArr());
                }
                _this.options.type == 'inline' ? _this.setValue() : null;
                _this.setTitle();
                _this.setActive();
                _this.options.transitionEnd.call(_this, _this.getIndexArr(), _this.getCurValue());
            } else if (event.direction == 'wheelDown') {
                _this.curDistance[index] = _this.curDistance[index] + _this.liHeight;
                _this.movePosition(theSlider, _this.curDistance[index]);
                if (_this.curDistance[index] + _this.offsetSum > 2 * _this.liHeight) {
                    _this.curDistance[index] = 2 * _this.liHeight;
                    setTimeout(function () {
                        _this.movePosition(theSlider, _this.curDistance[index]);
                    }, 100);
                }
                _this.clickStatus = false;
                if (_this.cascade) {
                    _this.checkRange(index, _this.getIndexArr());
                }
                _this.options.type == 'inline' ? _this.setValue() : null;
                _this.setTitle();
                _this.setActive();
                _this.options.transitionEnd.call(_this, _this.getIndexArr(), _this.getCurValue());
            }
        }
    }
    window.axScrollSelect = axScrollSelect;
    document.querySelectorAll('[axScrollSelect]').forEach(element => {
        new axScrollSelect(element);
    });
})();
/*!
* 插件：下拉选择（单选和多选）；改造自Choices v10.1.0 https://github.com/Choices-js/Choices；使用方法：new axSelect('#id',{参数})
*/
(function (factory) {
  let global = window || global || self;
    typeof define === 'function' && define.amd ? define(factory) :
    global.axSelect = factory();
    document.querySelectorAll('[axSelect]').forEach(element => {
        new axSelect(element);
    });
})((function () { 'use strict';
    const EVENTS = {
        showDropdown: 'showDropdown',
        hideDropdown: 'hideDropdown',
        change: 'change',
        choice: 'choice',
        search: 'search',
        addItem: 'addItem',
        removeItem: 'removeItem',
        highlightItem: 'highlightItem',
        highlightChoice: 'highlightChoice',
        unhighlightItem: 'unhighlightItem',
    };
    const ACTION_TYPES = {
        ADD_CHOICE: 'ADD_CHOICE',
        FILTER_CHOICES: 'FILTER_CHOICES',
        ACTIVATE_CHOICES: 'ACTIVATE_CHOICES',
        CLEAR_CHOICES: 'CLEAR_CHOICES',
        ADD_GROUP: 'ADD_GROUP',
        ADD_ITEM: 'ADD_ITEM',
        REMOVE_ITEM: 'REMOVE_ITEM',
        HIGHLIGHT_ITEM: 'HIGHLIGHT_ITEM',
        CLEAR_ALL: 'CLEAR_ALL',
        RESET_TO: 'RESET_TO',
        SET_IS_LOADING: 'SET_IS_LOADING',
    };
    const KEY_CODES = {
        BACK_KEY: 46,
        DELETE_KEY: 8,
        ENTER_KEY: 13,
        A_KEY: 65,
        ESC_KEY: 27,
        UP_KEY: 38,
        DOWN_KEY: 40,
        PAGE_UP_KEY: 33,
        PAGE_DOWN_KEY: 34,
    };
    const TEXT_TYPE = 'text';
    const SELECT_ONE_TYPE = 'select-one';
    const SELECT_MULTIPLE_TYPE = 'select-multiple';
    const SCROLLING_SPEED = 4;
    const addChoice = ({ value, label, id, groupId, disabled, elementId, customProperties, placeholder, keyCode, }) => ({
        type: ACTION_TYPES.ADD_CHOICE,
        value,
        label,
        id,
        groupId,
        disabled,
        elementId,
        customProperties,
        placeholder,
        keyCode,
    });
    const filterChoices = (results) => ({
        type: ACTION_TYPES.FILTER_CHOICES,
        results,
    });
    const activateChoices = (active = true) => ({
        type: ACTION_TYPES.ACTIVATE_CHOICES,
        active,
    });
    const clearChoices = () => ({
        type: ACTION_TYPES.CLEAR_CHOICES,
    });
    const addGroup = ({ value, id, active, disabled, }) => ({
        type: ACTION_TYPES.ADD_GROUP,
        value,
        id,
        active,
        disabled,
    });
    const addItem = ({ value, label, id, choiceId, groupId, customProperties, placeholder, keyCode, }) => ({
        type: ACTION_TYPES.ADD_ITEM,
        value,
        label,
        id,
        choiceId,
        groupId,
        customProperties,
        placeholder,
        keyCode,
    });
    const removeItem = (id, choiceId) => ({
        type: ACTION_TYPES.REMOVE_ITEM,
        id,
        choiceId,
    });
    const highlightItem = (id, highlighted) => ({
        type: ACTION_TYPES.HIGHLIGHT_ITEM,
        id,
        highlighted,
    });
    const clearAll = () => ({
        type: ACTION_TYPES.CLEAR_ALL,
    });
    const resetTo = (state) => ({
        type: ACTION_TYPES.RESET_TO,
        state,
    });
    const setIsLoading = (isLoading) => ({
        type: ACTION_TYPES.SET_IS_LOADING,
        isLoading,
    });
    class Dropdown {
        constructor({ element, type, classNames, }) {
            this.element = element;
            this.classNames = classNames;
            this.type = type;
            this.isActive = false;
        }
        /**
         * Bottom position of dropdown in viewport coordinates
         */
        get distanceFromTopWindow() {
            return this.element.getBoundingClientRect().bottom;
        }
        getChild(selector) {
            return this.element.querySelector(selector);
        }
        /**
         * Show dropdown to user by adding active state class
         */
        show() {
            this.element.classList.add(this.classNames.activeState);
            this.element.setAttribute('aria-expanded', 'true');
            this.isActive = true;
            return this;
        }
        /**
         * Hide dropdown from user
         */
        hide() {
            this.element.classList.remove(this.classNames.activeState);
            this.element.setAttribute('aria-expanded', 'false');
            this.isActive = false;
            return this;
        }
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    const getRandomNumber = (min, max) => Math.floor(Math.random() * (max - min) + min);
    const generateChars = (length) => Array.from({ length }, () => getRandomNumber(0, 36).toString(36)).join('');
    const generateId = (element, prefix) => {
        let id = element.id ||
            (element.name && `${element.name}-${generateChars(2)}`) ||
            generateChars(4);
        id = id.replace(/(:|\.|\[|\]|,)/g, '');
        id = `${prefix}-${id}`;
        return id;
    };
    /*
    const getType = (obj) => Object.prototype.toString.call(obj).slice(8, -1);
    const isType = (type, obj) => obj !== undefined && obj !== null && getType(obj) === type;
    const wrap = (element, wrapper = document.createElement('div')) => {
        if (element.parentNode) {
            if (element.nextSibling) {
                element.parentNode.insertBefore(wrapper, element.nextSibling);
            }
            else {
                element.parentNode.appendChild(wrapper);
            }
        }
        return wrapper.appendChild(element);
    }; */
    const getAdjacentEl = (startEl, selector, direction = 1) => {
        const prop = `${direction > 0 ? 'next' : 'previous'}ElementSibling`;
        let sibling = startEl[prop];
        while (sibling) {
            if (sibling.matches(selector)) {
                return sibling;
            }
            sibling = sibling[prop];
        }
        return sibling;
    };
    const isScrolledIntoView = (element, parent, direction = 1) => {
        if (!element) {
            return false;
        }
        let isVisible;
        if (direction > 0) {
            isVisible =
                parent.scrollTop + parent.offsetHeight >=
                    element.offsetTop + element.offsetHeight;
        }
        else {
            isVisible = element.offsetTop >= parent.scrollTop;
        }
        return isVisible;
    };
/*     const sanitise = (value) => {
        if (typeof value !== 'string') {
            return value;
        }
        return value
            .replace(/&/g, '&amp;')
            .replace(/>/g, '&gt;')
            .replace(/</g, '&lt;')
            .replace(/"/g, '&quot;');
    }; */
    const strToEl = (() => {
        const tmpEl = document.createElement('div');
        return (str) => {
            const cleanedInput = str.trim();
            tmpEl.innerHTML = cleanedInput;
            const firldChild = tmpEl.children[0];
            while (tmpEl.firstChild) {
                tmpEl.removeChild(tmpEl.firstChild);
            }
            return firldChild;
        };
    })();
    const sortByAlpha = ({ value, label = value }, { value: value2, label: label2 = value2 }) => label.localeCompare(label2, [], {
        sensitivity: 'base',
        ignorePunctuation: true,
        numeric: true,
    });
    const sortByScore = (a, b) => {
        const { score: scoreA = 0 } = a;
        const { score: scoreB = 0 } = b;
        return scoreA - scoreB;
    };
    const dispatchEvent = (element, type, customArgs = null) => {
        const event = new CustomEvent(type, {
            detail: customArgs,
            bubbles: true,
            cancelable: true,
        });
        return element.dispatchEvent(event);
    };
    const existsInArray = (array, value, key = 'value') => array.some((item) => {
        if (typeof value === 'string') {
            return item[key] === value.trim();
        }
        return item[key] === value;
    });
    const cloneObject = (obj) => JSON.parse(JSON.stringify(obj));
    /**
     * Returns an array of keys present on the first but missing on the second object
     */
    const diff = (a, b) => {
        const aKeys = Object.keys(a).sort();
        const bKeys = Object.keys(b).sort();
        return aKeys.filter((i) => bKeys.indexOf(i) < 0);
    };
    class Container {
        constructor({ element, type, classNames, position, }) {
            this.element = element;
            this.classNames = classNames;
            this.type = type;
            this.position = position;
            this.isOpen = false;
            this.isFlipped = false;
            this.isFocussed = false;
            this.isDisabled = false;
            this.isLoading = false;
            this._onFocus = this._onFocus.bind(this);
            this._onBlur = this._onBlur.bind(this);
        }
        addEventListeners() {
            this.element.addEventListener('focus', this._onFocus);
            this.element.addEventListener('blur', this._onBlur);
        }
        removeEventListeners() {
            this.element.removeEventListener('focus', this._onFocus);
            this.element.removeEventListener('blur', this._onBlur);
        }
        /**
         * Determine whether container should be flipped based on passed
         * dropdown position
         */
        shouldFlip(dropdownPos) {
            if (typeof dropdownPos !== 'number') {
                return false;
            }
            let shouldFlip = false;
            if (this.position === 'auto') {
                shouldFlip = !window.matchMedia(`(min-height: ${dropdownPos + 1}px)`)
                    .matches;
            }
            else if (this.position === 'top') {
                shouldFlip = true;
            }
            return shouldFlip;
        }
        setActiveDescendant(activeDescendantID) {
            this.element.setAttribute('aria-activedescendant', activeDescendantID);
        }
        removeActiveDescendant() {
            this.element.removeAttribute('aria-activedescendant');
        }
        open(dropdownPos) {
            this.element.classList.add(this.classNames.openState);
            this.element.setAttribute('aria-expanded', 'true');
            this.isOpen = true;
            if (this.shouldFlip(dropdownPos)) {
                this.element.classList.add(this.classNames.flippedState);
                this.isFlipped = true;
            }
        }
        close() {
            this.element.classList.remove(this.classNames.openState);
            this.element.setAttribute('aria-expanded', 'false');
            this.removeActiveDescendant();
            this.isOpen = false;
            if (this.isFlipped) {
                this.element.classList.remove(this.classNames.flippedState);
                this.isFlipped = false;
            }
        }
        focus() {
            if (!this.isFocussed) {
                this.element.focus();
            }
        }
        addFocusState() {
            this.element.classList.add(this.classNames.focusState);
        }
        removeFocusState() {
            this.element.classList.remove(this.classNames.focusState);
        }
        enable() {
            this.element.classList.remove(this.classNames.disabledState);
            this.element.removeAttribute('aria-disabled');
            if (this.type === SELECT_ONE_TYPE) {
                this.element.setAttribute('tabindex', '0');
            }
            this.isDisabled = false;
        }
        disable() {
            this.element.classList.add(this.classNames.disabledState);
            this.element.setAttribute('aria-disabled', 'true');
            if (this.type === SELECT_ONE_TYPE) {
                this.element.setAttribute('tabindex', '-1');
            }
            this.isDisabled = true;
        }
        wrap(element) {
            axAddWrap(element, this.element) 
        }
        unwrap(element) {
            if (this.element.parentNode) {
                this.element.parentNode.insertBefore(element, this.element);
                this.element.parentNode.removeChild(this.element);
            }
        }
        addLoadingState() {
            this.element.classList.add(this.classNames.loadingState);
            this.element.setAttribute('aria-busy', 'true');
            this.isLoading = true;
        }
        removeLoadingState() {
            this.element.classList.remove(this.classNames.loadingState);
            this.element.removeAttribute('aria-busy');
            this.isLoading = false;
        }
        _onFocus() {
            this.isFocussed = true;
        }
        _onBlur() {
            this.isFocussed = false;
        }
    }
    class Input {
        constructor({ element, type, classNames, preventPaste, }) {
            this.element = element;
            this.type = type;
            this.classNames = classNames;
            this.preventPaste = preventPaste;
            this.isFocussed = this.element.isEqualNode(document.activeElement);
            this.isDisabled = element.disabled;
            this._onPaste = this._onPaste.bind(this);
            this._onInput = this._onInput.bind(this);
            this._onFocus = this._onFocus.bind(this);
            this._onBlur = this._onBlur.bind(this);
        }
        set placeholder(placeholder) {
            this.element.placeholder = placeholder;
        }
        get value() {
            return axCleanString(this.element.value);
        }
        set value(value) {
            this.element.value = value;
        }
        get rawValue() {
            return this.element.value;
        }
        addEventListeners() {
            this.element.addEventListener('paste', this._onPaste);
            this.element.addEventListener('input', this._onInput, {
                passive: true,
            });
            this.element.addEventListener('focus', this._onFocus, {
                passive: true,
            });
            this.element.addEventListener('blur', this._onBlur, {
                passive: true,
            });
        }
        removeEventListeners() {
            this.element.removeEventListener('input', this._onInput);
            this.element.removeEventListener('paste', this._onPaste);
            this.element.removeEventListener('focus', this._onFocus);
            this.element.removeEventListener('blur', this._onBlur);
        }
        enable() {
            this.element.removeAttribute('disabled');
            this.isDisabled = false;
        }
        disable() {
            this.element.setAttribute('disabled', '');
            this.isDisabled = true;
        }
        focus() {
            if (!this.isFocussed) {
                this.element.focus();
            }
        }
        blur() {
            if (this.isFocussed) {
                this.element.blur();
            }
        }
        clear(setWidth = true) {
            if (this.element.value) {
                this.element.value = '';
            }
            if (setWidth) {
                this.setWidth();
            }
            return this;
        }
        /**
         * Set the correct input width based on placeholder
         * value or input value
         */
        setWidth() {
            const { style, value, placeholder } = this.element;
            style.minWidth = placeholder.length + 1 + "em"; 
            style.width = value.length + 1 + "em"; 
        }
        setActiveDescendant(activeDescendantID) {
            this.element.setAttribute('aria-activedescendant', activeDescendantID);
        }
        removeActiveDescendant() {
            this.element.removeAttribute('aria-activedescendant');
        }
        _onInput() {
            if (this.type !== SELECT_ONE_TYPE) {
                this.setWidth();
            }
        }
        _onPaste(event) {
            if (this.preventPaste) {
                axPreventDefault(event);
            }
        }
        _onFocus() {
            this.isFocussed = true;
        }
        _onBlur() {
            this.isFocussed = false;
        }
    }
    class List {
        constructor({ element }) {
            this.element = element;
            this.scrollPos = this.element.scrollTop;
            this.height = this.element.offsetHeight;
        }
        clear() {
            this.element.innerHTML = '';
        }
        append(node) {
            this.element.appendChild(node);
        }
        getChild(selector) {
            return this.element.querySelector(selector);
        }
        hasChildren() {
            return this.element.hasChildNodes();
        }
        scrollToTop() {
            this.element.scrollTop = 0;
        }
        scrollToChildElement(element, direction) {
            if (!element) {
                return;
            }
            const listHeight = this.element.offsetHeight;
            const listScrollPosition = this.element.scrollTop + listHeight;
            const elementHeight = element.offsetHeight;
            const elementPos = element.offsetTop + elementHeight;
            const destination = direction > 0
                ? this.element.scrollTop + elementPos - listScrollPosition
                : element.offsetTop;
            requestAnimationFrame(() => {
                this._animateScroll(destination, direction);
            });
        }
        _scrollDown(scrollPos, strength, destination) {
            const easing = (destination - scrollPos) / strength;
            const distance = easing > 1 ? easing : 1;
            this.element.scrollTop = scrollPos + distance;
        }
        _scrollUp(scrollPos, strength, destination) {
            const easing = (scrollPos - destination) / strength;
            const distance = easing > 1 ? easing : 1;
            this.element.scrollTop = scrollPos - distance;
        }
        _animateScroll(destination, direction) {
            const strength = SCROLLING_SPEED;
            const choiceListScrollTop = this.element.scrollTop;
            let continueAnimation = false;
            if (direction > 0) {
                this._scrollDown(choiceListScrollTop, strength, destination);
                if (choiceListScrollTop < destination) {
                    continueAnimation = true;
                }
            }
            else {
                this._scrollUp(choiceListScrollTop, strength, destination);
                if (choiceListScrollTop > destination) {
                    continueAnimation = true;
                }
            }
            if (continueAnimation) {
                requestAnimationFrame(() => {
                    this._animateScroll(destination, direction);
                });
            }
        }
    }
    class WrappedElement {
        constructor({ element, classNames }) {
            this.element = element;
            this.classNames = classNames;
            if (!(element instanceof HTMLInputElement) &&
                !(element instanceof HTMLSelectElement)) {
                throw new TypeError('Invalid element passed');
            }
            this.isDisabled = false;
        }
        get isActive() {
            return this.element.dataset.choice === 'active';
        }
        get dir() {
            return this.element.dir;
        }
        get value() {
            return this.element.value;
        }
        set value(value) {
            this.element.value = value;
        }
        conceal() {
            this.element.classList.add(this.classNames.input);
            this.element.hidden = true;
            this.element.tabIndex = -1;
            const origStyle = this.element.getAttribute('style');
            if (origStyle) {
                this.element.setAttribute('data-choice-orig-style', origStyle);
            }
            this.element.setAttribute('data-choice', 'active');
        }
        reveal() {
            this.element.classList.remove(this.classNames.input);
            this.element.hidden = false;
            this.element.removeAttribute('tabindex');
            const origStyle = this.element.getAttribute('data-choice-orig-style');
            if (origStyle) {
                this.element.removeAttribute('data-choice-orig-style');
                this.element.setAttribute('style', origStyle);
            }
            else {
                this.element.removeAttribute('style');
            }
            this.element.removeAttribute('data-choice');
            this.element.value = this.element.value; 
        }
        enable() {
            this.element.removeAttribute('disabled');
            this.element.disabled = false;
            this.isDisabled = false;
        }
        disable() {
            this.element.setAttribute('disabled', '');
            this.element.disabled = true;
            this.isDisabled = true;
        }
        triggerEvent(eventType, data) {
            dispatchEvent(this.element, eventType, data);
        }
    }
    class WrappedInput extends WrappedElement {
        constructor({ element, classNames, delimiter, }) {
            super({ element, classNames });
            this.delimiter = delimiter;
        }
        get value() {
            return this.element.value;
        }
        set value(value) {
            this.element.setAttribute('value', value);
            this.element.value = value;
        }
    }
    class WrappedSelect extends WrappedElement {
        constructor({ element, classNames, template, }) {
            super({ element, classNames });
            this.template = template;
        }
        get placeholderOption() {
            return (this.element.querySelector('option[value=""]') ||
                this.element.querySelector('option[placeholder]'));
        }
        get optionGroups() {
            return Array.from(this.element.getElementsByTagName('OPTGROUP'));
        }
        get options() {
            return Array.from(this.element.options);
        }
        set options(options) {
            const fragment = document.createDocumentFragment();
            const addOptionToFragment = (data) => {
                const option = this.template(data);
                fragment.appendChild(option);
            };
            options.forEach((optionData) => addOptionToFragment(optionData));
            this.appendDocFragment(fragment);
        }
        appendDocFragment(fragment) {
            this.element.innerHTML = '';
            this.element.appendChild(fragment);
        }
    }
    const DEFAULT_CLASSNAMES = {
                    containerOuter: 'ax-select',
                    containerInner: 'ax-select-inner',
                    input: 'ax-select-input',
                    inputCloned: 'ax-input',
                    list: 'ax-select-list',
                    listItems: 'ax-label-multiple',
                    listSingle: 'ax-label-single',
                    listDropdown: 'ax-select-dropdown',
                    dropdownList: 'ax-item-list',
                    item: 'ax-item',
                    itemSelectable: 'ax-item-selectable',
                    itemDisabled: 'ax-item-disabled',
                    itemChoice: 'ax-item-done',
                    placeholder: 'ax-select-placeholder',
                    group: 'ax-item-group',
                    groupHeading: 'ax-group-name',
                    button: 'ax-close',
                    activeState: 'ax-active',
                    focusState: 'ax-focuse',
                    openState: 'ax-open',
                    disabledState: 'ax-disabled',
                    highlightedState: 'ax-highlight',
                    selectedState: 'ax-selected',
                    flippedState: 'ax-flipped',
                    loadingState: 'ax-buffer',
                    noResults: 'ax-no-results',
                    noChoices: 'ax-no-select'
                };
    const DEFAULT_CONFIG = {
        disabled:false,
        size:'',
        width:'',
        items: [],
        choices: [],
        silent: false,
        renderChoiceLimit: -1,
        className:'',
        maxItemCount: -1,
        addItems: true,
        addItemFilter: null,
        removeItems: true,
        removeItemButton: false,
        editItems: false,
        allowHTML: true,
        duplicateItemsAllowed: true,
        delimiter: ',',
        paste: true,
        searchEnabled: false,
        searchChoices: true,
        searchFloor: 1,
        searchResultLimit: 4,
        searchFields: ['label', 'value'],
        position: 'auto',
        resetScrollPosition: true,
        shouldSort: true,
        shouldSortItems: false,
        sorter: sortByAlpha,
        placeholder: true,
        placeholderValue: '请输入关键字...',
        searchPlaceholderValue: '请输入关键字...',
        prependValue: null,
        appendValue: null,
        renderSelectedChoices: 'auto',
        loadingText: '加载中...',
        noResultsText: '没有检索结果',
        noChoicesText: '没有符合条件的选项',
        itemSelectText: '点击选择',
        uniqueItemText: '只能添加唯一值',
        customAddItemText: '只可添加条件匹配的选项',
        addItemText: (value) => `按回车键添加 <b>"${axCleanString(value)}"</b> 选项`,
        maxItemText: (maxItemCount) => `只能添加 ${maxItemCount} 项`,
        valueComparer: (value1, value2) => value1 === value2,
        fuseOptions: {
            includeScore: true,
        },
        labelId: '',
        callbackOnInit: null,
        callbackOnCreateTemplates: null,
        classNames: DEFAULT_CLASSNAMES,
    };
    const defaultState$4 = [];
    function items(state = defaultState$4, action = {}) {
        switch (action.type) {
            case 'ADD_ITEM': {
                const addItemAction = action;
                const newState = [
                    ...state,
                    {
                        id: addItemAction.id,
                        choiceId: addItemAction.choiceId,
                        groupId: addItemAction.groupId,
                        value: addItemAction.value,
                        label: addItemAction.label,
                        active: true,
                        highlighted: false,
                        customProperties: addItemAction.customProperties,
                        placeholder: addItemAction.placeholder || false,
                        keyCode: null,
                    },
                ];
                return newState.map((obj) => {
                    const item = obj;
                    item.highlighted = false;
                    return item;
                });
            }
            case 'REMOVE_ITEM': {
                return state.map((obj) => {
                    const item = obj;
                    if (item.id === action.id) {
                        item.active = false;
                    }
                    return item;
                });
            }
            case 'HIGHLIGHT_ITEM': {
                const highlightItemAction = action;
                return state.map((obj) => {
                    const item = obj;
                    if (item.id === highlightItemAction.id) {
                        item.highlighted = highlightItemAction.highlighted;
                    }
                    return item;
                });
            }
            default: {
                return state;
            }
        }
    }
    const defaultState$3 = [];
    function groups(state = defaultState$3, action = {}) {
        switch (action.type) {
            case 'ADD_GROUP': {
                const addGroupAction = action;
                return [
                    ...state,
                    {
                        id: addGroupAction.id,
                        value: addGroupAction.value,
                        active: addGroupAction.active,
                        disabled: addGroupAction.disabled,
                    },
                ];
            }
            case 'CLEAR_CHOICES': {
                return [];
            }
            default: {
                return state;
            }
        }
    }
    const defaultState$2 = [];
    function choices(state = defaultState$2, action = {}) {
        switch (action.type) {
            case 'ADD_CHOICE': {
                const addChoiceAction = action;
                const choice = {
                    id: addChoiceAction.id,
                    elementId: addChoiceAction.elementId,
                    groupId: addChoiceAction.groupId,
                    value: addChoiceAction.value,
                    label: addChoiceAction.label || addChoiceAction.value,
                    disabled: addChoiceAction.disabled || false,
                    selected: false,
                    active: true,
                    score: 9999,
                    customProperties: addChoiceAction.customProperties,
                    placeholder: addChoiceAction.placeholder || false,
                };
                /*
                  A disabled choice appears in the choice dropdown but cannot be selected
                  A selected choice has been added to the passed input's value (added as an item)
                  An active choice appears within the choice dropdown
                */
                return [...state, choice];
            }
            case 'ADD_ITEM': {
                const addItemAction = action;
                if (addItemAction.choiceId > -1) {
                    return state.map((obj) => {
                        const choice = obj;
                        if (choice.id === parseInt(`${addItemAction.choiceId}`, 10)) {
                            choice.selected = true;
                        }
                        return choice;
                    });
                }
                return state;
            }
            case 'REMOVE_ITEM': {
                const removeItemAction = action;
                if (removeItemAction.choiceId && removeItemAction.choiceId > -1) {
                    return state.map((obj) => {
                        const choice = obj;
                        if (choice.id === parseInt(`${removeItemAction.choiceId}`, 10)) {
                            choice.selected = false;
                        }
                        return choice;
                    });
                }
                return state;
            }
            case 'FILTER_CHOICES': {
                const filterChoicesAction = action;
                return state.map((obj) => {
                    const choice = obj;
                    choice.active = filterChoicesAction.results.some(({ item, score }) => {
                        if (item.id === choice.id) {
                            choice.score = score;
                            return true;
                        }
                        return false;
                    });
                    return choice;
                });
            }
            case 'ACTIVATE_CHOICES': {
                const activateChoicesAction = action;
                return state.map((obj) => {
                    const choice = obj;
                    choice.active = activateChoicesAction.active;
                    return choice;
                });
            }
            case 'CLEAR_CHOICES': {
                return defaultState$2;
            }
            default: {
                return state;
            }
        }
    }
    const defaultState$1 = false;
    const general = (state = defaultState$1, action = {}) => {
        switch (action.type) {
            case 'SET_IS_LOADING': {
                return action.isLoading;
            }
            default: {
                return state;
            }
        }
    };
    const defaultState = {
        groups: [],
        items: [],
        choices: [],
        loading: false,
    };
    const appReducer = Redux.combineReducers({
        items,
        groups,
        choices,
        loading: general,
    });
    const rootReducer = (passedState, action) => {
        let state = passedState;
        if (action.type === 'CLEAR_ALL') {
            state = defaultState;
        }
        else if (action.type === 'RESET_TO') {
            return cloneObject(action.state);
        }
        return appReducer(state, action);
    };
    /* eslint-disable @typescript-eslint/no-explicit-any */
    class Store {
        constructor() {
            this._store = Redux.createStore(rootReducer, window.__REDUX_DEVTOOLS_EXTENSION__ &&
                window.__REDUX_DEVTOOLS_EXTENSION__());
        }
        /**
         * Subscribe store to function call (wrapped Redux method)
         */
        subscribe(onChange) {
            this._store.subscribe(onChange);
        }
        /**
         * Dispatch event to store (wrapped Redux method)
         */
        dispatch(action) {
            this._store.dispatch(action);
        }
        /**
         * Get store object (wrapping Redux method)
         */
        get state() {
            return this._store.getState();
        }
        /**
         * Get items from store
         */
        get items() {
            return this.state.items;
        }
        /**
         * Get active items from store
         */
        get activeItems() {
            return this.items.filter((item) => item.active === true);
        }
        /**
         * Get highlighted items from store
         */
        get highlightedActiveItems() {
            return this.items.filter((item) => item.active && item.highlighted);
        }
        /**
         * Get choices from store
         */
        get choices() {
            return this.state.choices;
        }
        /**
         * Get active choices from store
         */
        get activeChoices() {
            return this.choices.filter((choice) => choice.active === true);
        }
        /**
         * Get selectable choices from store
         */
        get selectableChoices() {
            return this.choices.filter((choice) => choice.disabled !== true);
        }
        /**
         * Get choices that can be searched (excluding placeholders)
         */
        get searchableChoices() {
            return this.selectableChoices.filter((choice) => choice.placeholder !== true);
        }
        /**
         * Get placeholder choice from store
         */
        get placeholderChoice() {
            return [...this.choices]
                .reverse()
                .find((choice) => choice.placeholder === true);
        }
        /**
         * Get groups from store
         */
        get groups() {
            return this.state.groups;
        }
        /**
         * Get active groups from store
         */
        get activeGroups() {
            const { groups, choices } = this;
            return groups.filter((group) => {
                const isActive = group.active === true && group.disabled === false;
                const hasActiveOptions = choices.some((choice) => choice.active === true && choice.disabled === false);
                return isActive && hasActiveOptions;
            }, []);
        }
        /**
         * Get loading state from store
         */
        isLoading() {
            return this.state.loading;
        }
        /**
         * Get single choice by it's ID
         */
        getChoiceById(id) {
            return this.activeChoices.find((choice) => choice.id === parseInt(id, 10));
        }
        /**
         * Get group by group id
         */
        getGroupById(id) {
            return this.groups.find((group) => group.id === id);
        }
    }
    /**
     * Helpers to create HTML elements used by Choices
     * Can be overridden by providing `callbackOnCreateTemplates` option
     */
    const templates = {
        containerOuter({ classNames: { containerOuter } }, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType, labelId) {
            const div = Object.assign(document.createElement('div'), {
                className: containerOuter,
            });
            div.dataset.type = passedElementType;
            if (dir) {
                div.dir = dir;
            }
            if (isSelectOneElement) {
                div.tabIndex = 0;
            }
            if (isSelectElement) {
                div.setAttribute('role', searchEnabled ? 'combobox' : 'listbox');
                if (searchEnabled) {
                    div.setAttribute('aria-autocomplete', 'list');
                }
            }
            div.setAttribute('aria-haspopup', 'true');
            div.setAttribute('aria-expanded', 'false');
            this.config.className?div.classList.add(this.config.className):null;
            this.config.size?div.setAttribute('data-size',this.config.size):null;
            if (labelId) {
                div.setAttribute('aria-labeledby', labelId);
            }
            return div;
        },
        containerInner({ classNames: { containerInner }, }) {
            return Object.assign(document.createElement('div'), {
                className: containerInner,
            });
        },
        itemList({ classNames: { list, listSingle, listItems } }, isSelectOneElement) {
            return Object.assign(document.createElement('span'), { 
                className: `${isSelectOneElement ? listSingle : listItems}`,
            });
        },
        placeholder({ allowHTML, classNames: { placeholder } }, value) {
            return Object.assign(document.createElement('div'), {
                className: placeholder,
                [allowHTML ? 'innerHTML' : 'innerText']: value,
            });
        },
        item({ allowHTML, classNames: { item, button, highlightedState, itemSelectable, placeholder, }, }, { id, value, label, customProperties, active, disabled, highlighted, placeholder: isPlaceholder, }, removeItemButton) {
            const div = Object.assign(document.createElement('span'), {
                className: item,
                [allowHTML ? 'innerHTML' : 'innerText']: label,
            });
            Object.assign(div.dataset, {
                item: '',
                id,
                value,
                customProperties,
            });
            if (active) {
                div.setAttribute('aria-selected', 'true');
            }
            if (disabled) {
                div.setAttribute('aria-disabled', 'true');
            }
            if (isPlaceholder) {
                div.classList.add(placeholder);
            }
            div.classList.add(highlighted ? highlightedState : itemSelectable);
            if (removeItemButton) {
                if (disabled) {
                    div.classList.remove(itemSelectable);
                }
                div.dataset.deletable = '';
                /** @todo This MUST be localizable, not hardcoded! */
                const REMOVE_ITEM_TEXT = '';
                const removeButton = Object.assign(document.createElement('i'), {
                    type: 'button',
                    className: button,
                    [allowHTML ? 'innerHTML' : 'innerText']: REMOVE_ITEM_TEXT,
                });
                removeButton.setAttribute('aria-label', `${REMOVE_ITEM_TEXT}: '${value}'`);
                removeButton.dataset.button = '';
                div.appendChild(removeButton);
            }
            return div;
        },
        choiceList({ classNames: { dropdownList } }, isSelectOneElement) {
            const div = Object.assign(document.createElement('div'), {
                className: dropdownList,
            });
            if (!isSelectOneElement) {
                div.setAttribute('aria-multiselectable', 'true');
            }
            div.setAttribute('role', 'listbox');
            return div;
        },
        choiceGroup({ allowHTML, classNames: { group, groupHeading, itemDisabled }, }, { id, value, disabled }) {
            const div = Object.assign(document.createElement('div'), {
                className: `${group} ${disabled ? itemDisabled : ''}`,
            });
            div.setAttribute('role', 'group');
            Object.assign(div.dataset, {
                group: '',
                id,
                value,
            });
            if (disabled) {
                div.setAttribute('aria-disabled', 'true');
            }
            div.appendChild(Object.assign(document.createElement('div'), {
                className: groupHeading,
                [allowHTML ? 'innerHTML' : 'innerText']: value,
            }));
            return div;
        },
        choice({ allowHTML, classNames: { item, itemChoice, itemSelectable, selectedState, itemDisabled, placeholder, }, }, { id, value, label, groupId, elementId, disabled: isDisabled, selected: isSelected, placeholder: isPlaceholder, }, selectText) {
            const div = Object.assign(document.createElement('div'), {
                id: elementId,
                [allowHTML ? 'innerHTML' : 'innerText']: label,
                className: `${item} ${itemChoice}`,
            });
            if (isSelected) {
                div.classList.add(selectedState);
            }
            if (isPlaceholder) {
                div.classList.add(placeholder);
            }
            div.setAttribute('role', groupId && groupId > 0 ? 'treeitem' : 'option');
            Object.assign(div.dataset, {
                choice: '',
                id,
                value,
                selectText,
            });
            if (isDisabled) {
                div.classList.add(itemDisabled);
                div.dataset.choiceDisabled = '';
                div.setAttribute('aria-disabled', 'true');
            }
            else {
                div.classList.add(itemSelectable);
                div.dataset.choiceSelectable = '';
            }
            return div;
        },
        input({ classNames: { input, inputCloned } }, placeholderValue) {
            const inp = Object.assign(document.createElement('input'), {
                type: 'search',
                name: 'search_terms',
                className: `${input} ${inputCloned}`,
                autocomplete: 'off',
                autocapitalize: 'off',
                spellcheck: false,
            });
            inp.setAttribute('role', 'textbox');
            inp.setAttribute('aria-autocomplete', 'list');
            inp.setAttribute('aria-label', placeholderValue);
            return inp;
        },
        dropdown({ classNames: { list, listDropdown }, }) {
            const div = document.createElement('div');
            div.classList.add(listDropdown);
            div.setAttribute('aria-expanded', 'false');
            return div;
        },
        notice({ allowHTML, classNames: { item, itemChoice, noResults, noChoices }, }, innerText, type = '') {
            const classes = [item, itemChoice];
            if (type === 'no-choices') {
                classes.push(noChoices);
            }
            else if (type === 'no-results') {
                classes.push(noResults);
            }
            return Object.assign(document.createElement('div'), {
                [allowHTML ? 'innerHTML' : 'innerText']: innerText,
                className: classes.join(' '),
            });
        },
        option({ label, value, customProperties, active, disabled, }) {
            const opt = new Option(label, value, false, active);
            if (customProperties) {
                opt.dataset.customProperties = `${customProperties}`;
            }
            opt.disabled = !!disabled;
            return opt;
        },
    };
    /** @see {@link http://browserhacks.com/#hack-acea075d0ac6954f275a70023906050c} */
    const IS_IE11 = '-ms-scroll-limit' in document.documentElement.style &&
        '-ms-ime-align' in document.documentElement.style;
    const USER_DEFAULTS = {};
    /**
     * Choices
     * @author Josh Johnson<josh@joshuajohnson.co.uk>
     */
    class Choices {
        constructor(element = '[data-choice]', userConfig = {}) {
            if (userConfig.allowHTML === undefined) {
            }
            this.config = axClone(axMerge(axMerge(DEFAULT_CONFIG, Choices.defaults.options,{attrAppend:true,clone:true}),userConfig,{attrAppend:true,clone:true}));
            this.origElem = element;
            this.config = axMerge(this.config, axAttrToJson(element, 'axSelect'));
            const invalidConfigOptions = diff(this.config, DEFAULT_CONFIG);
            if (invalidConfigOptions.length) {
                console.warn('Unknown config option(s) passed', invalidConfigOptions.join(', '));
            }
            const passedElement = typeof element === 'string' ? document.querySelector(element) : element;
            if (!(passedElement instanceof HTMLInputElement ||
                passedElement instanceof HTMLSelectElement)) {
                throw TypeError('Expected one of the following types text|select-one|select-multiple');
            }
            this._isTextElement = passedElement.type === TEXT_TYPE;
            this._isSelectOneElement = passedElement.type === SELECT_ONE_TYPE;
            this._isSelectMultipleElement = passedElement.type === SELECT_MULTIPLE_TYPE;
            this._isSelectElement =
                this._isSelectOneElement || this._isSelectMultipleElement;
            this.config.searchEnabled =
                this._isSelectMultipleElement || this.config.searchEnabled;
            if (!['auto', 'always'].includes(`${this.config.renderSelectedChoices}`)) {
                this.config.renderSelectedChoices = 'auto';
            }
            if (userConfig.addItemFilter &&
                typeof userConfig.addItemFilter !== 'function') {
                const re = userConfig.addItemFilter instanceof RegExp
                    ? userConfig.addItemFilter
                    : new RegExp(userConfig.addItemFilter);
                this.config.addItemFilter = re.test.bind(re);
            }
            if (this._isTextElement) {
                this.passedElement = new WrappedInput({
                    element: passedElement,
                    classNames: this.config.classNames,
                    delimiter: this.config.delimiter,
                });
            }
            else {
                this.passedElement = new WrappedSelect({
                    element: passedElement,
                    classNames: this.config.classNames,
                    template: (data) => this._templates.option(data),
                });
            }
            this.initialised = false;
            this._store = new Store();
            this._initialState = defaultState;
            this._currentState = defaultState;
            this._prevState = defaultState;
            this._currentValue = '';
            this._canSearch = !!this.config.searchEnabled;
            this._isScrollingOnIe = false;
            this._highlightPosition = 0;
            this._wasTap = true;
            this._placeholderValue = this._generatePlaceholderValue();
            this._baseId = axCreateId('choices-', '', this.passedElement.element); 
            /**
             * setting direction in cases where it's explicitly set on passedElement
             * or when calculated direction is different from the document
             */
            this._direction = this.passedElement.dir;
            if (!this._direction) {
                const { direction: elementDirection } = window.getComputedStyle(this.passedElement.element);
                const { direction: documentDirection } = window.getComputedStyle(document.documentElement);
                if (elementDirection !== documentDirection) {
                    this._direction = elementDirection;
                }
            }
            this._idNames = {
                itemChoice: 'item-choice',
            };
            if (this._isSelectElement) {
                this._presetGroups = this.passedElement.optionGroups;
                this._presetOptions = this.passedElement.options;
            }
            this._presetChoices = this.config.choices;
            this._presetItems = this.config.items;
            if (this.passedElement.value && this._isTextElement) {
                const splitValues = this.passedElement.value.split(this.config.delimiter);
                this._presetItems = this._presetItems.concat(splitValues);
            }
            if (this.passedElement.options) {
                this.passedElement.options.forEach((option) => {
                    this._presetChoices.push({
                        value: option.value,
                        label: option.innerHTML,
                        selected: !!option.selected,
                        disabled: option.disabled || option.parentNode.disabled,
                        placeholder: option.value === '' || option.hasAttribute('placeholder'),
                        customProperties: option.dataset['custom-properties'],
                    });
                });
            }
            this._render = this._render.bind(this);
            this._onFocus = this._onFocus.bind(this);
            this._onBlur = this._onBlur.bind(this);
            this._onKeyUp = this._onKeyUp.bind(this);
            this._onKeyDown = this._onKeyDown.bind(this);
            this._onClick = this._onClick.bind(this);
            this._onTouchMove = this._onTouchMove.bind(this);
            this._onTouchEnd = this._onTouchEnd.bind(this);
            this._onMouseDown = this._onMouseDown.bind(this);
            this._onMouseOver = this._onMouseOver.bind(this);
            this._onFormReset = this._onFormReset.bind(this);
            this._onSelectKey = this._onSelectKey.bind(this);
            this._onEnterKey = this._onEnterKey.bind(this);
            this._onEscapeKey = this._onEscapeKey.bind(this);
            this._onDirectionKey = this._onDirectionKey.bind(this);
            this._onDeleteKey = this._onDeleteKey.bind(this);
            if (this.passedElement.isActive) {
                if (!this.config.silent) {
                    console.warn('Trying to initialise Choices on element already initialised', { element });
                }
                this.initialised = true;
                return;
            }
            element && element.hasOwnProperty('axSelect') && !!element.getAttribute('axSelect') ? this.referName = element.getAttribute('axSelect') : this.referName = '';
            this.init();
            this.config.disabled?this.disable():null;
        }
        static get defaults() {
            return Object.preventExtensions({
                get options() {
                    return USER_DEFAULTS;
                },
                get templates() {
                    return templates;
                },
            });
        }
        init(callback) {
            if (this.initialised) {
                return;
            }
            this._createTemplates();
            this._createElements();
            this._createStructure();
            this._store.subscribe(this._render);
            this._render();
            this._addEventListeners();
            const shouldDisable = !this.config.addItems ||
                this.passedElement.element.hasAttribute('disabled');
            if (shouldDisable) {
                this.disable();
            }
            this.initialised = true;
            const { callbackOnInit } = this.config;
            if (callbackOnInit && typeof callbackOnInit === 'function') {
                callbackOnInit.call(this);
            }
            callback && callback.call(this);
            if (this.referName) {
                if (axIsEmpty(axSelects)) {
                    axSelects.push({ name: this.referName, instance: this });
                } else {
                    for (let i = 0; i < axSelects.length; i++) {
                        if (axSelects[i].name == this.referName) {
                            axSelects[i].instance = this;
                            break;
                        } else {
                            axSelects.push({ name: this.referName, instance: this });
                        }
                    }
                }
            }
        }
        destroy(callback) {
            if (!this.initialised) {
                return;
            }
            this._removeEventListeners();
            this.passedElement.reveal();
            this.containerOuter.unwrap(this.passedElement.element);
            this.clearStore();
            if (this._isSelectElement) {
                this.passedElement.options = this._presetOptions;
            }
            this._templates = templates;
            this.initialised = false;
            callback && callback.call(this);
        }
        enable(callback) {
            if (this.passedElement.isDisabled) {
                this.passedElement.enable();
            }
            if (this.containerOuter.isDisabled) {
                this._addEventListeners();
                this.input.enable();
                this.containerOuter.enable();
            }
            callback && callback.call(this);
            return this;
        }
        disable(callback) {
            if (!this.passedElement.isDisabled) {
                this.passedElement.disable();
            }
            if (!this.containerOuter.isDisabled) {
                this._removeEventListeners();
                this.input.disable();
                this.containerOuter.disable();
            }
            callback && callback.call(this);
            return this;
        }
        highlightItem(item, runEvent = true,callback) {
            if (!item || !item.id) {
                return this;
            }
            const { id, groupId = -1, value = '', label = '' } = item;
            const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
            this._store.dispatch(highlightItem(id, true));
            if (runEvent) {
                this.passedElement.triggerEvent(EVENTS.highlightItem, {
                    id,
                    value,
                    label,
                    groupValue: group && group.value ? group.value : null,
                });
            }
            callback && callback.call(this);
            return this;
        }
        unhighlightItem(item,callback) {
            if (!item || !item.id) {
                return this;
            }
            const { id, groupId = -1, value = '', label = '' } = item;
            const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
            this._store.dispatch(highlightItem(id, false));
            this.passedElement.triggerEvent(EVENTS.highlightItem, {
                id,
                value,
                label,
                groupValue: group && group.value ? group.value : null,
            });
            callback && callback.call(this);
            return this;
        }
        highlightAll(callback) {
            this._store.items.forEach((item) => this.highlightItem(item));
            callback && callback.call(this);
            return this;
        }
        unhighlightAll(callback) {
            this._store.items.forEach((item) => this.unhighlightItem(item));
            callback && callback.call(this);
            return this;
        }
        removeActiveItemsByValue(value,callback) {
            this._store.activeItems
                .filter((item) => item.value === value)
                .forEach((item) => this._removeItem(item));
                callback && callback.call(this);
            return this;
        }
        removeActiveItems(excludedId,callback) {
            this._store.activeItems
                .filter(({ id }) => id !== excludedId)
                .forEach((item) => this._removeItem(item));
                callback && callback.call(this);
            return this;
        }
        removeHighlightedItems(runEvent = false,callback) {
            this._store.highlightedActiveItems.forEach((item) => {
                this._removeItem(item);
                if (runEvent) {
                    this._triggerChange(item.value);
                }
            });
            callback && callback.call(this);
            return this;
        }
        showDropdown(preventInputFocus,callback) {
            if (this.dropdown.isActive) {
                return this;
            }
            requestAnimationFrame(() => {
                this.dropdown.show();
                this.containerOuter.open(this.dropdown.distanceFromTopWindow);
                if (!preventInputFocus && this._canSearch) {
                    this.input.focus();
                }
                this.passedElement.triggerEvent(EVENTS.showDropdown, {});
            });
            callback && callback.call(this);
            return this;
        }
        hideDropdown(preventInputBlur,callback) {
            if (!this.dropdown.isActive) {
                callback && callback.call(this);
                return this;
            }
            requestAnimationFrame(() => {
                this.dropdown.hide();
                this.containerOuter.close();
                if (!preventInputBlur && this._canSearch) {
                    this.input.removeActiveDescendant();
                    this.input.blur();
                }
                this.passedElement.triggerEvent(EVENTS.hideDropdown, {});
            });
            callback && callback.call(this);
            return this;
        }
        getValue(valueOnly = false,callback) {
            const values = this._store.activeItems.reduce((selectedItems, item) => {
                const itemValue = valueOnly ? item.value : item;
                selectedItems.push(itemValue);
                return selectedItems;
            }, []);
            callback && callback.call(this);
            return this._isSelectOneElement ? values[0] : values;
        }
        setValue(items,callback) {
            if (!this.initialised) {
                return this;
            }
            items.forEach((value) => this._setChoiceOrItem(value));
            callback && callback.call(this);
            return this;
        }
        setChoiceByValue(value,callback) {
            if (!this.initialised || this._isTextElement) {
                return this;
            }
            const choiceValue = Array.isArray(value) ? value : [value];
            choiceValue.forEach((val) => this._findAndSelectChoiceByValue(val));
            callback && callback.call(this);
            return this;
        }
        /**
         * Set choices of select input via an array of objects (or function that returns array of object or promise of it),
         * a value field name and a label field name.
         * This behaves the same as passing items via the choices option but can be called after initialising Choices.
         * This can also be used to add groups of choices (see example 2); Optionally pass a true `replaceChoices` value to remove any existing choices.
         * Optionally pass a `customProperties` object to add additional data to your choices (useful when searching/filtering etc).
         *
         * **Input types affected:** select-one, select-multiple
         *
         * @example
         * ```js
         * const example = new Choices(element);
         *
         * example.setChoices([
         *   {value: 'One', label: 'Label One', disabled: true},
         *   {value: 'Two', label: 'Label Two', selected: true},
         *   {value: 'Three', label: 'Label Three'},
         * ], 'value', 'label', false);
         * ```
         *
         * @example
         * ```js
         * const example = new Choices(element);
         *
         * example.setChoices(async () => {
         *   try {
         *      const items = await fetch('/items');
         *      return items.json()
         *   } catch(err) {
         *      console.error(err)
         *   }
         * });
         * ```
         *
         * @example
         * ```js
         * const example = new Choices(element);
         *
         * example.setChoices([{
         *   label: 'Group one',
         *   id: 1,
         *   disabled: false,
         *   choices: [
         *     {value: 'Child One', label: 'Child One', selected: true},
         *     {value: 'Child Two', label: 'Child Two',  disabled: true},
         *     {value: 'Child Three', label: 'Child Three'},
         *   ]
         * },
         * {
         *   label: 'Group two',
         *   id: 2,
         *   disabled: false,
         *   choices: [
         *     {value: 'Child Four', label: 'Child Four', disabled: true},
         *     {value: 'Child Five', label: 'Child Five'},
         *     {value: 'Child Six', label: 'Child Six', customProperties: {
         *       description: 'Custom description about child six',
         *       random: 'Another random custom property'
         *     }},
         *   ]
         * }], 'value', 'label', false);
         * ```
         */
        setChoices(choicesArrayOrFetcher = [], value = 'value', label = 'label', replaceChoices = false,callback) {
            if (!this.initialised) {
                throw new ReferenceError(`setChoices was called on a non-initialized instance of Choices`);
            }
            if (!this._isSelectElement) {
                throw new TypeError(`setChoices can't be used with INPUT based Choices`);
            }
            if (typeof value !== 'string' || !value) {
                throw new TypeError(`value parameter must be a name of 'value' field in passed objects`);
            }
            if (replaceChoices) {
                this.clearChoices();
            }
            if (typeof choicesArrayOrFetcher === 'function') {
                const fetcher = choicesArrayOrFetcher(this);
                if (typeof Promise === 'function' && fetcher instanceof Promise) {
                    return new Promise((resolve) => requestAnimationFrame(resolve))
                        .then(() => this._handleLoadingState(true))
                        .then(() => fetcher)
                        .then((data) => this.setChoices(data, value, label, replaceChoices))
                        .catch((err) => {
                        if (!this.config.silent) {
                            console.error(err);
                        }
                    })
                        .then(() => this._handleLoadingState(false))
                        .then(() => this);
                }
                if (!Array.isArray(fetcher)) {
                    throw new TypeError(`.setChoices first argument function must return either array of choices or Promise, got: ${typeof fetcher}`);
                }
                return this.setChoices(fetcher, value, label, false);
            }
            if (!Array.isArray(choicesArrayOrFetcher)) {
                throw new TypeError(`.setChoices must be called either with array of choices with a function resulting into Promise of array of choices`);
            }
            this.containerOuter.removeLoadingState();
            this._startLoading();
            choicesArrayOrFetcher.forEach((groupOrChoice) => {
                if (groupOrChoice.choices) {
                    this._addGroup({
                        id: groupOrChoice.id ? parseInt(`${groupOrChoice.id}`, 10) : null,
                        group: groupOrChoice,
                        valueKey: value,
                        labelKey: label,
                    });
                }
                else {
                    const choice = groupOrChoice;
                    this._addChoice({
                        value: choice[value],
                        label: choice[label],
                        isSelected: !!choice.selected,
                        isDisabled: !!choice.disabled,
                        placeholder: !!choice.placeholder,
                        customProperties: choice.customProperties,
                    });
                }
            });
            this._stopLoading();
            callback && callback.call(this);
            return this;
        }
        clearChoices(callback) {
            this._store.dispatch(clearChoices());
            callback && callback.call(this);
            return this;
        }
        clearStore(callback) {
            this._store.dispatch(clearAll());
            callback && callback.call(this);
            return this;
        }
        clearInput(callback) {
            const shouldSetInputWidth = !this._isSelectOneElement;
            this.input.clear(shouldSetInputWidth);
            if (!this._isTextElement && this._canSearch) {
                this._isSearching = false;
                this._store.dispatch(activateChoices(true));
            }
            callback && callback.call(this);
            return this;
        }
        _render(callback) {
            if (this._store.isLoading()) {
                return;
            }
            this._currentState = this._store.state;
            const stateChanged = this._currentState.choices !== this._prevState.choices ||
                this._currentState.groups !== this._prevState.groups ||
                this._currentState.items !== this._prevState.items;
            const shouldRenderChoices = this._isSelectElement;
            const shouldRenderItems = this._currentState.items !== this._prevState.items;
            if (!stateChanged) {
                return;
            }
            if (shouldRenderChoices) {
                this._renderChoices();
            }
            if (shouldRenderItems) {
                this._renderItems();
            }
            this._prevState = this._currentState;
            callback && callback.call(this);
        }
        _renderChoices() {
            const { activeGroups, activeChoices } = this._store;
            let choiceListFragment = document.createDocumentFragment();
            this.choiceList.clear();
            if (this.config.resetScrollPosition) {
                requestAnimationFrame(() => this.choiceList.scrollToTop());
            }
            if (activeGroups.length >= 1 && !this._isSearching) {
                const activePlaceholders = activeChoices.filter((activeChoice) => activeChoice.placeholder === true && activeChoice.groupId === -1);
                if (activePlaceholders.length >= 1) {
                    choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);
                }
                choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);
            }
            else if (activeChoices.length >= 1) {
                choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);
            }
            if (choiceListFragment.childNodes &&
                choiceListFragment.childNodes.length > 0) {
                const { activeItems } = this._store;
                const canAddItem = this._canAddItem(activeItems, this.input.value);
                if (canAddItem.response) {
                    this.choiceList.append(choiceListFragment);
                    this._highlightChoice();
                }
                else {
                    const notice = this._getTemplate('notice', canAddItem.notice);
                    this.choiceList.append(notice);
                }
            }
            else {
                let dropdownItem;
                let notice;
                if (this._isSearching) {
                    notice =
                        typeof this.config.noResultsText === 'function'
                            ? this.config.noResultsText()
                            : this.config.noResultsText;
                    dropdownItem = this._getTemplate('notice', notice, 'no-results');
                }
                else {
                    notice =
                        typeof this.config.noChoicesText === 'function'
                            ? this.config.noChoicesText()
                            : this.config.noChoicesText;
                    dropdownItem = this._getTemplate('notice', notice, 'no-choices');
                }
                this.choiceList.append(dropdownItem);
            }
        }
        _renderItems() {
            const activeItems = this._store.activeItems || [];
            this.itemList.clear();
            const itemListFragment = this._createItemsFragment(activeItems);
            if (itemListFragment.childNodes) {
                this.itemList.append(itemListFragment);
            }
        }
        _createGroupsFragment(groups, choices, fragment = document.createDocumentFragment()) {
            const getGroupChoices = (group) => choices.filter((choice) => {
                if (this._isSelectOneElement) {
                    return choice.groupId === group.id;
                }
                return (choice.groupId === group.id &&
                    (this.config.renderSelectedChoices === 'always' || !choice.selected));
            });
            if (this.config.shouldSort) {
                groups.sort(this.config.sorter);
            }
            groups.forEach((group) => {
                const groupChoices = getGroupChoices(group);
                if (groupChoices.length >= 1) {
                    const dropdownGroup = this._getTemplate('choiceGroup', group);
                    fragment.appendChild(dropdownGroup);
                    this._createChoicesFragment(groupChoices, fragment, true);
                }
            });
            return fragment;
        }
        _createChoicesFragment(choices, fragment = document.createDocumentFragment(), withinGroup = false) {
            const { renderSelectedChoices, searchResultLimit, renderChoiceLimit } = this.config;
            const filter = this._isSearching ? sortByScore : this.config.sorter;
            const appendChoice = (choice) => {
                const shouldRender = renderSelectedChoices === 'auto'
                    ? this._isSelectOneElement || !choice.selected
                    : true;
                if (shouldRender) {
                    const dropdownItem = this._getTemplate('choice', choice, this.config.itemSelectText);
                    fragment.appendChild(dropdownItem);
                }
            };
            let rendererableChoices = choices;
            if (renderSelectedChoices === 'auto' && !this._isSelectOneElement) {
                rendererableChoices = choices.filter((choice) => !choice.selected);
            }
            const { placeholderChoices, normalChoices } = rendererableChoices.reduce((acc, choice) => {
                if (choice.placeholder) {
                    acc.placeholderChoices.push(choice);
                }
                else {
                    acc.normalChoices.push(choice);
                }
                return acc;
            }, {
                placeholderChoices: [],
                normalChoices: [],
            });
            if (this.config.shouldSort || this._isSearching) {
                normalChoices.sort(filter);
            }
            let choiceLimit = rendererableChoices.length;
            const sortedChoices = this._isSelectOneElement
                ? [...placeholderChoices, ...normalChoices]
                : normalChoices;
            if (this._isSearching) {
                choiceLimit = searchResultLimit;
            }
            else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {
                choiceLimit = renderChoiceLimit;
            }
            for (let i = 0; i < choiceLimit; i += 1) {
                if (sortedChoices[i]) {
                    appendChoice(sortedChoices[i]);
                }
            }
            return fragment;
        }
        _createItemsFragment(items, fragment = document.createDocumentFragment()) {
            const { shouldSortItems, sorter, removeItemButton } = this.config;
            if (shouldSortItems && !this._isSelectOneElement) {
                items.sort(sorter);
            }
            if (this._isTextElement) {
                this.passedElement.value = items
                    .map(({ value }) => value)
                    .join(this.config.delimiter);
            }
            else {
                this.passedElement.options = items;
            }
            const addItemToFragment = (item) => {
                const listItem = this._getTemplate('item', item, removeItemButton);
                fragment.appendChild(listItem);
            };
            items.forEach(addItemToFragment);
            return fragment;
        }
        _triggerChange(value) {
            if (value === undefined || value === null) {
                return;
            }
            this.passedElement.triggerEvent(EVENTS.change, {
                value,
            });
        }
        _selectPlaceholderChoice(placeholderChoice) {
            this._addItem({
                value: placeholderChoice.value,
                label: placeholderChoice.label,
                choiceId: placeholderChoice.id,
                groupId: placeholderChoice.groupId,
                placeholder: placeholderChoice.placeholder,
            });
            this._triggerChange(placeholderChoice.value);
        }
        _handleButtonAction(activeItems, element) {
            if (!activeItems ||
                !element ||
                !this.config.removeItems ||
                !this.config.removeItemButton) {
                return;
            }
            const itemId = element.parentNode && element.parentNode.dataset.id;
            const itemToRemove = itemId && activeItems.find((item) => item.id === parseInt(itemId, 10));
            if (!itemToRemove) {
                return;
            }
            this._removeItem(itemToRemove);
            this._triggerChange(itemToRemove.value);
            if (this._isSelectOneElement && this._store.placeholderChoice) {
                this._selectPlaceholderChoice(this._store.placeholderChoice);
            }
        }
        _handleItemAction(activeItems, element, hasShiftKey = false) {
            if (!activeItems ||
                !element ||
                !this.config.removeItems ||
                this._isSelectOneElement) {
                return;
            }
            const passedId = element.dataset.id;
            activeItems.forEach((item) => {
                if (item.id === parseInt(`${passedId}`, 10) && !item.highlighted) {
                    this.highlightItem(item);
                }
                else if (!hasShiftKey && item.highlighted) {
                    this.unhighlightItem(item);
                }
            });
            this.input.focus();
        }
        _handleChoiceAction(activeItems, element) {
            if (!activeItems || !element) {
                return;
            }
            const { id } = element.dataset;
            const choice = id && this._store.getChoiceById(id);
            if (!choice) {
                return;
            }
            const passedKeyCode = activeItems[0] && activeItems[0].keyCode
                ? activeItems[0].keyCode
                : undefined;
            const hasActiveDropdown = this.dropdown.isActive;
            choice.keyCode = passedKeyCode;
            this.passedElement.triggerEvent(EVENTS.choice, {
                choice,
            });
            if (!choice.selected && !choice.disabled) {
                const canAddItem = this._canAddItem(activeItems, choice.value);
                if (canAddItem.response) {
                    this._addItem({
                        value: choice.value,
                        label: choice.label,
                        choiceId: choice.id,
                        groupId: choice.groupId,
                        customProperties: choice.customProperties,
                        placeholder: choice.placeholder,
                        keyCode: choice.keyCode,
                    });
                    this._triggerChange(choice.value);
                }
            }
            this.clearInput();
            if (hasActiveDropdown && this._isSelectOneElement) {
                this.hideDropdown(true);
                this.containerOuter.focus();
            }
        }
        _handleBackspace(activeItems) {
            if (!this.config.removeItems || !activeItems) {
                return;
            }
            const lastItem = activeItems[activeItems.length - 1];
            const hasHighlightedItems = activeItems.some((item) => item.highlighted);
            if (this.config.editItems && !hasHighlightedItems && lastItem) {
                this.input.value = lastItem.value;
                this.input.setWidth();
                this._removeItem(lastItem);
                this._triggerChange(lastItem.value);
            }
            else {
                if (!hasHighlightedItems) {
                    this.highlightItem(lastItem, false);
                }
                this.removeHighlightedItems(true);
            }
        }
        _startLoading() {
            this._store.dispatch(setIsLoading(true));
        }
        _stopLoading() {
            this._store.dispatch(setIsLoading(false));
        }
        _handleLoadingState(setLoading = true) {
            let placeholderItem = this.itemList.getChild(`.${this.config.classNames.placeholder}`);
            if (setLoading) {
                this.disable();
                this.containerOuter.addLoadingState();
                if (this._isSelectOneElement) {
                    if (!placeholderItem) {
                        placeholderItem = this._getTemplate('placeholder', this.config.loadingText);
                        if (placeholderItem) {
                            this.itemList.append(placeholderItem);
                        }
                    }
                    else {
                        placeholderItem.innerHTML = this.config.loadingText;
                    }
                }
                else {
                    this.input.placeholder = this.config.loadingText;
                }
            }
            else {
                this.enable();
                this.containerOuter.removeLoadingState();
                if (this._isSelectOneElement) {
                    if (placeholderItem) {
                        placeholderItem.innerHTML = this._placeholderValue || '';
                    }
                }
                else {
                    this.input.placeholder = this._placeholderValue || '';
                }
            }
        }
        _handleSearch(value) {
            if (!this.input.isFocussed) {
                return;
            }
            const { choices } = this._store;
            const { searchFloor, searchChoices } = this.config;
            const hasUnactiveChoices = choices.some((option) => !option.active);
            if (value !== null &&
                typeof value !== 'undefined' &&
                value.length >= searchFloor) {
                const resultCount = searchChoices ? this._searchChoices(value) : 0;
                this.passedElement.triggerEvent(EVENTS.search, {
                    value,
                    resultCount,
                });
            }
            else if (hasUnactiveChoices) {
                this._isSearching = false;
                this._store.dispatch(activateChoices(true));
            }
        }
        _canAddItem(activeItems, value) {
            let canAddItem = true;
            let notice = typeof this.config.addItemText === 'function'
                ? this.config.addItemText(value)
                : this.config.addItemText;
            if (!this._isSelectOneElement) {
                const isDuplicateValue = existsInArray(activeItems, value);
                if (this.config.maxItemCount > 0 &&
                    this.config.maxItemCount <= activeItems.length) {
                    canAddItem = false;
                    notice =
                        typeof this.config.maxItemText === 'function'
                            ? this.config.maxItemText(this.config.maxItemCount)
                            : this.config.maxItemText;
                }
                if (!this.config.duplicateItemsAllowed &&
                    isDuplicateValue &&
                    canAddItem) {
                    canAddItem = false;
                    notice =
                        typeof this.config.uniqueItemText === 'function'
                            ? this.config.uniqueItemText(value)
                            : this.config.uniqueItemText;
                }
                if (this._isTextElement &&
                    this.config.addItems &&
                    canAddItem &&
                    typeof this.config.addItemFilter === 'function' &&
                    !this.config.addItemFilter(value)) {
                    canAddItem = false;
                    notice =
                        typeof this.config.customAddItemText === 'function'
                            ? this.config.customAddItemText(value)
                            : this.config.customAddItemText;
                }
            }
            return {
                response: canAddItem,
                notice,
            };
        }
        _searchChoices(value) {
            const newValue = typeof value === 'string' ? value.trim() : value;
            const currentValue = typeof this._currentValue === 'string'
                ? this._currentValue.trim()
                : this._currentValue;
            if (newValue.length < 1 && newValue === `${currentValue} `) {
                return 0;
            }
            const haystack = this._store.searchableChoices;
            const needle = newValue;
            const options = Object.assign(this.config.fuseOptions, {
                keys: [...this.config.searchFields],
                includeMatches: true,
            });
            const fuse = new Fuse(haystack, options);
            const results = fuse.search(needle); 
            this._currentValue = newValue;
            this._highlightPosition = 0;
            this._isSearching = true;
            this._store.dispatch(filterChoices(results));
            return results.length;
        }
        _addEventListeners() {
            const { documentElement } = document;
            documentElement.addEventListener('touchend', this._onTouchEnd, true);
            this.containerOuter.element.addEventListener('keydown', this._onKeyDown, true);
            this.containerOuter.element.addEventListener('mousedown', this._onMouseDown, true);
            documentElement.addEventListener('click', this._onClick, { passive: true });
            documentElement.addEventListener('touchmove', this._onTouchMove, {
                passive: true,
            });
            this.dropdown.element.addEventListener('mouseover', this._onMouseOver, {
                passive: true,
            });
            if (this._isSelectOneElement) {
                this.containerOuter.element.addEventListener('focus', this._onFocus, {
                    passive: true,
                });
                this.containerOuter.element.addEventListener('blur', this._onBlur, {
                    passive: true,
                });
            }
            this.input.element.addEventListener('keyup', this._onKeyUp, {
                passive: true,
            });
            this.input.element.addEventListener('focus', this._onFocus, {
                passive: true,
            });
            this.input.element.addEventListener('blur', this._onBlur, {
                passive: true,
            });
            if (this.input.element.form) {
                this.input.element.form.addEventListener('reset', this._onFormReset, {
                    passive: true,
                });
            }
            this.input.addEventListeners();
        }
        _removeEventListeners() {
            const { documentElement } = document;
            documentElement.removeEventListener('touchend', this._onTouchEnd, true);
            this.containerOuter.element.removeEventListener('keydown', this._onKeyDown, true);
            this.containerOuter.element.removeEventListener('mousedown', this._onMouseDown, true);
            documentElement.removeEventListener('click', this._onClick);
            documentElement.removeEventListener('touchmove', this._onTouchMove);
            this.dropdown.element.removeEventListener('mouseover', this._onMouseOver);
            if (this._isSelectOneElement) {
                this.containerOuter.element.removeEventListener('focus', this._onFocus);
                this.containerOuter.element.removeEventListener('blur', this._onBlur);
            }
            this.input.element.removeEventListener('keyup', this._onKeyUp);
            this.input.element.removeEventListener('focus', this._onFocus);
            this.input.element.removeEventListener('blur', this._onBlur);
            if (this.input.element.form) {
                this.input.element.form.removeEventListener('reset', this._onFormReset);
            }
            this.input.removeEventListeners();
        }
        _onKeyDown(event) {
            const { keyCode } = event;
            const { activeItems } = this._store;
            const hasFocusedInput = this.input.isFocussed;
            const hasActiveDropdown = this.dropdown.isActive;
            const hasItems = this.itemList.hasChildren();
            const keyString = String.fromCharCode(keyCode);
            const wasAlphaNumericChar = /[a-zA-Z0-9-_ ]/.test(keyString);
            const { BACK_KEY, DELETE_KEY, ENTER_KEY, A_KEY, ESC_KEY, UP_KEY, DOWN_KEY, PAGE_UP_KEY, PAGE_DOWN_KEY, } = KEY_CODES;
            if (!this._isTextElement && !hasActiveDropdown && wasAlphaNumericChar) {
                this.showDropdown();
                if (!this.input.isFocussed) {
                    /*
                      We update the input value with the pressed key as
                      the input was not focussed at the time of key press
                      therefore does not have the value of the key.
                    */
                    this.input.value += keyString.toLowerCase();
                }
            }
            switch (keyCode) {
                case A_KEY:
                    return this._onSelectKey(event, hasItems);
                case ENTER_KEY:
                    return this._onEnterKey(event, activeItems, hasActiveDropdown);
                case ESC_KEY:
                    return this._onEscapeKey(hasActiveDropdown);
                case UP_KEY:
                case PAGE_UP_KEY:
                case DOWN_KEY:
                case PAGE_DOWN_KEY:
                    return this._onDirectionKey(event, hasActiveDropdown);
                case DELETE_KEY:
                case BACK_KEY:
                    return this._onDeleteKey(event, activeItems, hasFocusedInput);
            }
        }
        _onKeyUp({ target, keyCode, }) {
            const { value } = this.input;
            const { activeItems } = this._store;
            const canAddItem = this._canAddItem(activeItems, value);
            const { BACK_KEY: backKey, DELETE_KEY: deleteKey } = KEY_CODES;
            if (this._isTextElement) {
                const canShowDropdownNotice = canAddItem.notice && value;
                if (canShowDropdownNotice) {
                    const dropdownItem = this._getTemplate('notice', canAddItem.notice);
                    this.dropdown.element.innerHTML = dropdownItem.outerHTML;
                    this.showDropdown(true);
                }
                else {
                    this.hideDropdown(true);
                }
            }
            else {
                const wasRemovalKeyCode = keyCode === backKey || keyCode === deleteKey;
                const userHasRemovedValue = wasRemovalKeyCode && target && !target.value;
                const canReactivateChoices = !this._isTextElement && this._isSearching;
                const canSearch = this._canSearch && canAddItem.response;
                if (userHasRemovedValue && canReactivateChoices) {
                    this._isSearching = false;
                    this._store.dispatch(activateChoices(true));
                }
                else if (canSearch) {
                    this._handleSearch(this.input.rawValue);
                }
            }
            this._canSearch = this.config.searchEnabled;
        }
        _onSelectKey(event, hasItems) {
            const { ctrlKey, metaKey } = event;
            const hasCtrlDownKeyPressed = ctrlKey || metaKey;
            if (hasCtrlDownKeyPressed && hasItems) {
                this._canSearch = false;
                const shouldHightlightAll = this.config.removeItems &&
                    !this.input.value &&
                    this.input.element === document.activeElement;
                if (shouldHightlightAll) {
                    this.highlightAll();
                }
            }
        }
        _onEnterKey(event, activeItems, hasActiveDropdown) {
            const { target } = event;
            const { ENTER_KEY: enterKey } = KEY_CODES;
            const targetWasButton = target && target.hasAttribute('data-button');
            if (this._isTextElement && target && target.value) {
                const { value } = this.input;
                const canAddItem = this._canAddItem(activeItems, value);
                if (canAddItem.response) {
                    this.hideDropdown(true);
                    this._addItem({ value });
                    this._triggerChange(value);
                    this.clearInput();
                }
            }
            if (targetWasButton) {
                this._handleButtonAction(activeItems, target);
                axPreventDefault(event);
            }
            if (hasActiveDropdown) {
                const highlightedChoice = this.dropdown.getChild(`.${this.config.classNames.highlightedState}`);
                if (highlightedChoice) {
                    if (activeItems[0]) {
                        activeItems[0].keyCode = enterKey; 
                    }
                    this._handleChoiceAction(activeItems, highlightedChoice);
                }
                axPreventDefault(event);
            }
            else if (this._isSelectOneElement) {
                this.showDropdown();
                axPreventDefault(event);
            }
        }
        _onEscapeKey(hasActiveDropdown) {
            if (hasActiveDropdown) {
                this.hideDropdown(true);
                this.containerOuter.focus();
            }
        }
        _onDirectionKey(event, hasActiveDropdown) {
            const { keyCode, metaKey } = event;
            const { DOWN_KEY: downKey, PAGE_UP_KEY: pageUpKey, PAGE_DOWN_KEY: pageDownKey, } = KEY_CODES;
            if (hasActiveDropdown || this._isSelectOneElement) {
                this.showDropdown();
                this._canSearch = false;
                const directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;
                const skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;
                const selectableChoiceIdentifier = '[data-choice-selectable]';
                let nextEl;
                if (skipKey) {
                    if (directionInt > 0) {
                        nextEl = this.dropdown.element.querySelector(`${selectableChoiceIdentifier}:last-of-type`);
                    }
                    else {
                        nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                    }
                }
                else {
                    const currentEl = this.dropdown.element.querySelector(`.${this.config.classNames.highlightedState}`);
                    if (currentEl) {
                        nextEl = getAdjacentEl(currentEl, selectableChoiceIdentifier, directionInt);
                    }
                    else {
                        nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                    }
                }
                if (nextEl) {
                    if (!isScrolledIntoView(nextEl, this.choiceList.element, directionInt)) {
                        this.choiceList.scrollToChildElement(nextEl, directionInt);
                    }
                    this._highlightChoice(nextEl);
                }
                axPreventDefault(event);
            }
        }
        _onDeleteKey(event, activeItems, hasFocusedInput) {
            const { target } = event;
            if (!this._isSelectOneElement &&
                !target.value &&
                hasFocusedInput) {
                this._handleBackspace(activeItems);
                axPreventDefault(event);
            }
        }
        _onTouchMove() {
            if (this._wasTap) {
                this._wasTap = false;
            }
        }
        _onTouchEnd(event) {
            const { target } = event || event.touches[0];
            const touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);
            if (touchWasWithinContainer) {
                const containerWasExactTarget = target === this.containerOuter.element ||
                    target === this.containerInner.element;
                if (containerWasExactTarget) {
                    if (this._isTextElement) {
                        this.input.focus();
                    }
                    else if (this._isSelectMultipleElement) {
                        this.showDropdown();
                    }
                }
                event.stopPropagation();
            }
            this._wasTap = true;
        }
        /**
         * Handles mousedown event in capture mode for containetOuter.element
         */
        _onMouseDown(event) {
            const { target } = event;
            if (!(target instanceof HTMLElement)) {
                return;
            }
            if (IS_IE11 && this.choiceList.element.contains(target)) {
                const firstChoice = this.choiceList.element
                    .firstElementChild;
                const isOnScrollbar = this._direction === 'ltr'
                    ? event.offsetX >= firstChoice.offsetWidth
                    : event.offsetX < firstChoice.offsetLeft;
                this._isScrollingOnIe = isOnScrollbar;
            }
            if (target === this.input.element) {
                return;
            }
            const item = target.closest('[data-button],[data-item],[data-choice]');
            if (item instanceof HTMLElement) {
                const hasShiftKey = event.shiftKey;
                const { activeItems } = this._store;
                const { dataset } = item;
                if ('button' in dataset) {
                    this._handleButtonAction(activeItems, item);
                }
                else if ('item' in dataset) {
                    this._handleItemAction(activeItems, item, hasShiftKey);
                }
                else if ('choice' in dataset) {
                    this._handleChoiceAction(activeItems, item);
                }
            }
            axPreventDefault(event);
        }
        /**
         * Handles mouseover event over this.dropdown
         * @param {MouseEvent} event
         */
        _onMouseOver({ target }) {
            if (target instanceof HTMLElement && 'choice' in target.dataset) {
                this._highlightChoice(target);
            }
        }
        _onClick({ target }) {
            const clickWasWithinContainer = this.containerOuter.element.contains(target);
            if (clickWasWithinContainer) {
                if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {
                    if (this._isTextElement) {
                        if (document.activeElement !== this.input.element) {
                            this.input.focus();
                        }
                    }
                    else {
                        this.showDropdown();
                        this.containerOuter.focus();
                    }
                }
                else if (this._isSelectOneElement &&
                    target !== this.input.element &&
                    !this.dropdown.element.contains(target)) {
                    this.hideDropdown();
                }
            }
            else {
                const hasHighlightedItems = this._store.highlightedActiveItems.length > 0;
                if (hasHighlightedItems) {
                    this.unhighlightAll();
                }
                this.containerOuter.removeFocusState();
                this.hideDropdown(true);
            }
        }
        _onFocus({ target }) {
            const focusWasWithinContainer = target && this.containerOuter.element.contains(target);
            if (!focusWasWithinContainer) {
                return;
            }
            const focusActions = {
                [TEXT_TYPE]: () => {
                    if (target === this.input.element) {
                        this.containerOuter.addFocusState();
                    }
                },
                [SELECT_ONE_TYPE]: () => {
                    this.containerOuter.addFocusState();
                    if (target === this.input.element) {
                        this.showDropdown(true);
                    }
                },
                [SELECT_MULTIPLE_TYPE]: () => {
                    if (target === this.input.element) {
                        this.showDropdown(true);
                        this.containerOuter.addFocusState();
                    }
                },
            };
            focusActions[this.passedElement.element.type]();
        }
        _onBlur({ target }) {
            const blurWasWithinContainer = target && this.containerOuter.element.contains(target);
            if (blurWasWithinContainer && !this._isScrollingOnIe) {
                const { activeItems } = this._store;
                const hasHighlightedItems = activeItems.some((item) => item.highlighted);
                const blurActions = {
                    [TEXT_TYPE]: () => {
                        if (target === this.input.element) {
                            this.containerOuter.removeFocusState();
                            if (hasHighlightedItems) {
                                this.unhighlightAll();
                            }
                            this.hideDropdown(true);
                        }
                    },
                    [SELECT_ONE_TYPE]: () => {
                        this.containerOuter.removeFocusState();
                        if (target === this.input.element ||
                            (target === this.containerOuter.element && !this._canSearch)) {
                            this.hideDropdown(true);
                        }
                    },
                    [SELECT_MULTIPLE_TYPE]: () => {
                        if (target === this.input.element) {
                            this.containerOuter.removeFocusState();
                            this.hideDropdown(true);
                            if (hasHighlightedItems) {
                                this.unhighlightAll();
                            }
                        }
                    },
                };
                blurActions[this.passedElement.element.type]();
            }
            else {
                this._isScrollingOnIe = false;
                this.input.element.focus();
            }
        }
        _onFormReset() {
            this._store.dispatch(resetTo(this._initialState));
        }
        _highlightChoice(el = null) {
            const choices = Array.from(this.dropdown.element.querySelectorAll('[data-choice-selectable]'));
            if (!choices.length) {
                return;
            }
            let passedEl = el;
            const highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(`.${this.config.classNames.highlightedState}`));
            highlightedChoices.forEach((choice) => {
                choice.classList.remove(this.config.classNames.highlightedState);
                choice.setAttribute('aria-selected', 'false');
            });
            if (passedEl) {
                this._highlightPosition = choices.indexOf(passedEl);
            }
            else {
                if (choices.length > this._highlightPosition) {
                    passedEl = choices[this._highlightPosition];
                }
                else {
                    passedEl = choices[choices.length - 1];
                }
                if (!passedEl) {
                    passedEl = choices[0];
                }
            }
            passedEl.classList.add(this.config.classNames.highlightedState);
            passedEl.setAttribute('aria-selected', 'true');
            this.passedElement.triggerEvent(EVENTS.highlightChoice, { el: passedEl });
            if (this.dropdown.isActive) {
                this.input.setActiveDescendant(passedEl.id);
                this.containerOuter.setActiveDescendant(passedEl.id);
            }
        }
        _addItem({ value, label = null, choiceId = -1, groupId = -1, customProperties = {}, placeholder = false, keyCode = -1, }) {
            let passedValue = typeof value === 'string' ? value.trim() : value;
            const { items } = this._store;
            const passedLabel = label || passedValue;
            const passedOptionId = choiceId || -1;
            const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
            const id = items ? items.length + 1 : 1;
            if (this.config.prependValue) {
                passedValue = this.config.prependValue + passedValue.toString();
            }
            if (this.config.appendValue) {
                passedValue += this.config.appendValue.toString();
            }
            this._store.dispatch(addItem({
                value: passedValue,
                label: passedLabel,
                id,
                choiceId: passedOptionId,
                groupId,
                customProperties,
                placeholder,
                keyCode,
            }));
            if (this._isSelectOneElement) {
                this.removeActiveItems(id);
            }
            this.passedElement.triggerEvent(EVENTS.addItem, {
                id,
                value: passedValue,
                label: passedLabel,
                customProperties,
                groupValue: group && group.value ? group.value : null,
                keyCode,
            });
        }
        _removeItem(item) {
            const { id, value, label, customProperties, choiceId, groupId } = item;
            const group = groupId && groupId >= 0 ? this._store.getGroupById(groupId) : null;
            if (!id || !choiceId) {
                return;
            }
            this._store.dispatch(removeItem(id, choiceId));
            this.passedElement.triggerEvent(EVENTS.removeItem, {
                id,
                value,
                label,
                customProperties,
                groupValue: group && group.value ? group.value : null,
            });
        }
        _addChoice({ value, label = null, isSelected = false, isDisabled = false, groupId = -1, customProperties = {}, placeholder = false, keyCode = -1, }) {
            if (typeof value === 'undefined' || value === null) {
                return;
            }
            const { choices } = this._store;
            const choiceLabel = label || value;
            const choiceId = choices ? choices.length + 1 : 1;
            const choiceElementId = `${this._baseId}-${this._idNames.itemChoice}-${choiceId}`;
            this._store.dispatch(addChoice({
                id: choiceId,
                groupId,
                elementId: choiceElementId,
                value,
                label: choiceLabel,
                disabled: isDisabled,
                customProperties,
                placeholder,
                keyCode,
            }));
            if (isSelected) {
                this._addItem({
                    value,
                    label: choiceLabel,
                    choiceId,
                    customProperties,
                    placeholder,
                    keyCode,
                });
            }
        }
        _addGroup({ group, id, valueKey = 'value', labelKey = 'label' }) {
            const groupChoices = axTypeIs('Object', group)
                ? group.choices
                : Array.from(group.getElementsByTagName('OPTION'));
            const groupId = id || Math.floor(new Date().valueOf() * Math.random());
            const isDisabled = group.disabled ? group.disabled : false;
            if (groupChoices) {
                this._store.dispatch(addGroup({
                    value: group.label,
                    id: groupId,
                    active: true,
                    disabled: isDisabled,
                }));
                const addGroupChoices = (choice) => {
                    const isOptDisabled = choice.disabled || (choice.parentNode && choice.parentNode.disabled);
                    this._addChoice({
                        value: choice[valueKey],
                        label: axTypeIs('Object', choice) ? choice[labelKey] : choice.innerHTML,
                        isSelected: choice.selected,
                        isDisabled: isOptDisabled,
                        groupId,
                        customProperties: choice.customProperties,
                        placeholder: choice.placeholder,
                    });
                };
                groupChoices.forEach(addGroupChoices);
            }
            else {
                this._store.dispatch(addGroup({
                    value: group.label,
                    id: group.id,
                    active: false,
                    disabled: group.disabled,
                }));
            }
        }
        _getTemplate(template, ...args) {
            return this._templates[template].call(this, this.config, ...args);
        }
        _createTemplates() {
            const { callbackOnCreateTemplates } = this.config;
            let userTemplates = {};
            if (callbackOnCreateTemplates &&
                typeof callbackOnCreateTemplates === 'function') {
                userTemplates = callbackOnCreateTemplates.call(this, strToEl);
            }
            this._templates = axMerge(templates, userTemplates,{arrAppend:true,attrAppend:true,clone:true});
        }
        _createElements() {
            this.containerOuter = new Container({
                element: this._getTemplate('containerOuter', this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type, this.config.labelId),
                classNames: this.config.classNames,
                type: this.passedElement.element.type,
                position: this.config.position,
            });
            this.containerInner = new Container({
                element: this._getTemplate('containerInner'),
                classNames: this.config.classNames,
                type: this.passedElement.element.type,
                position: this.config.position,
            });
            this.input = new Input({
                element: this._getTemplate('input', this._placeholderValue),
                classNames: this.config.classNames,
                type: this.passedElement.element.type,
                preventPaste: !this.config.paste,
            });
            this.choiceList = new List({
                element: this._getTemplate('choiceList', this._isSelectOneElement),
            });
            this.itemList = new List({
                element: this._getTemplate('itemList', this._isSelectOneElement),
            });
            this.dropdown = new Dropdown({
                element: this._getTemplate('dropdown'),
                classNames: this.config.classNames,
                type: this.passedElement.element.type,
            });
        }
        _createStructure() {
            this.passedElement.conceal();
            this.containerInner.wrap(this.passedElement.element);
            this.containerOuter.wrap(this.containerInner.element);
            if (this._isSelectOneElement) {
                this.input.placeholder = this.config.searchPlaceholderValue || '';
            }
            else if (this._placeholderValue) {
                this.input.placeholder = this._placeholderValue;
                this.input.setWidth();
            }
            this.containerOuter.element.appendChild(this.containerInner.element);
            this.containerOuter.element.appendChild(this.dropdown.element);
            this.containerInner.element.appendChild(this.itemList.element);
            if (!this._isTextElement) {
                this.dropdown.element.appendChild(this.choiceList.element);
            }
            if (!this._isSelectOneElement) {
                this.containerInner.element.appendChild(this.input.element);
            }
            else if (this.config.searchEnabled) {
                this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
            }
            if (this._isSelectElement) {
                this._highlightPosition = 0;
                this._isSearching = false;
                this._startLoading();
                if (this._presetGroups.length) {
                    this._addPredefinedGroups(this._presetGroups);
                }
                else {
                    this._addPredefinedChoices(this._presetChoices);
                }
                this._stopLoading();
            }
                            if(this.config.width){
                                this.containerOuter.element.style.width = this.config.width;
                            }else{
                                if(this.origElem.style && this.origElem.style.width){
                                    this.containerOuter.element.style.width = this.origElem.style.width;
                                }
                            }
            if (this._isTextElement) {
                this._addPredefinedItems(this._presetItems);
            }
            if (!this._isSelectOneElement) {
                this.containerInner.element.appendChild(this.input.element);
            } else
                if (this.config.searchEnabled) {
                    this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
                }
        }
        _addPredefinedGroups(groups) {
            const placeholderChoice = this.passedElement
                .placeholderOption;
            if (placeholderChoice &&
                placeholderChoice.parentNode &&
                placeholderChoice.parentNode.tagName === 'SELECT') {
                this._addChoice({
                    value: placeholderChoice.value,
                    label: placeholderChoice.innerHTML,
                    isSelected: placeholderChoice.selected,
                    isDisabled: placeholderChoice.disabled,
                    placeholder: true,
                });
            }
            groups.forEach((group) => this._addGroup({
                group,
                id: group.id || null,
            }));
        }
        _addPredefinedChoices(choices) {
            if (this.config.shouldSort) {
                choices.sort(this.config.sorter);
            }
            const hasSelectedChoice = choices.some((choice) => choice.selected);
            const firstEnabledChoiceIndex = choices.findIndex((choice) => choice.disabled === undefined || !choice.disabled);
            choices.forEach((choice, index) => {
                const { value = '', label, customProperties, placeholder } = choice;
                if (this._isSelectElement) {
                    if (choice.choices) {
                        this._addGroup({
                            group: choice,
                            id: choice.id || null,
                        });
                    }
                    else {
                        /**
                         * If there is a selected choice already or the choice is not the first in
                         * the array, add each choice normally.
                         *
                         * Otherwise we pre-select the first enabled choice in the array ("select-one" only)
                         */
                        const shouldPreselect = this._isSelectOneElement &&
                            !hasSelectedChoice &&
                            index === firstEnabledChoiceIndex;
                        const isSelected = shouldPreselect ? true : choice.selected;
                        const isDisabled = choice.disabled;
                        this._addChoice({
                            value,
                            label,
                            isSelected: !!isSelected,
                            isDisabled: !!isDisabled,
                            placeholder: !!placeholder,
                            customProperties,
                        });
                    }
                }
                else {
                    this._addChoice({
                        value,
                        label,
                        isSelected: !!choice.selected,
                        isDisabled: !!choice.disabled,
                        placeholder: !!choice.placeholder,
                        customProperties,
                    });
                }
            });
        }
        _addPredefinedItems(items) {
            items.forEach((item) => {
                if (typeof item === 'object' && item.value) {
                    this._addItem({
                        value: item.value,
                        label: item.label,
                        choiceId: item.id,
                        customProperties: item.customProperties,
                        placeholder: item.placeholder,
                    });
                }
                if (typeof item === 'string') {
                    this._addItem({
                        value: item,
                    });
                }
            });
        }
        _setChoiceOrItem(item) {
            const itemType = axType(item).toLowerCase(); 
            const handleType = {
                object: () => {
                    if (!item.value) {
                        return;
                    }
                    if (!this._isTextElement) {
                        this._addChoice({
                            value: item.value,
                            label: item.label,
                            isSelected: true,
                            isDisabled: false,
                            customProperties: item.customProperties,
                            placeholder: item.placeholder,
                        });
                    }
                    else {
                        this._addItem({
                            value: item.value,
                            label: item.label,
                            choiceId: item.id,
                            customProperties: item.customProperties,
                            placeholder: item.placeholder,
                        });
                    }
                },
                string: () => {
                    if (!this._isTextElement) {
                        this._addChoice({
                            value: item,
                            label: item,
                            isSelected: true,
                            isDisabled: false,
                        });
                    }
                    else {
                        this._addItem({
                            value: item,
                        });
                    }
                },
            };
            handleType[itemType]();
        }
        _findAndSelectChoiceByValue(value) {
            const { choices } = this._store;
            const foundChoice = choices.find((choice) => this.config.valueComparer(choice.value, value));
            if (foundChoice && !foundChoice.selected) {
                this._addItem({
                    value: foundChoice.value,
                    label: foundChoice.label,
                    choiceId: foundChoice.id,
                    groupId: foundChoice.groupId,
                    customProperties: foundChoice.customProperties,
                    placeholder: foundChoice.placeholder,
                    keyCode: foundChoice.keyCode,
                });
            }
        }
        _generatePlaceholderValue() {
            if (this._isSelectElement &&
                this.passedElement.placeholderOption) {
                const { placeholderOption } = this.passedElement;
                return placeholderOption ? placeholderOption.text : null;
            }
            const { placeholder, placeholderValue } = this.config;
            const { element: { dataset }, } = this.passedElement;
            if (placeholder) {
                if (placeholderValue) {
                    return placeholderValue;
                }
                if (dataset.placeholder) {
                    return dataset.placeholder;
                }
            }
            return null;
        }
    }
    return Choices;
}));
/*!
 * 插件：查看更多；使用方法：new axDropdown('#id',{参数})
 */
class axDropdown {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            type: 'list',
            content: '',
            node: 'a',
            nowrap: true,
            breakShow: true,
            arrowShow: true,
            grid: {
                enable: false,
                columns: 0,
                fenceShow: false,
            },
            onInit: '',
            onBeforeSet: '',
            onAfterSet: '',
            onConfirm: '',
            onUpdate: '',
            onUpdateContent: '',
            plugin: {
                value: '',
            },
            popup: {
                in: 'slideDown',
                out: 'slideUp',
                size: 'sm',
                placement: 'bottom-start',
                close: false,
            },
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.init();
        return this;
    }
    init() {
        let _this = this;
        this.plugin = null;
        this.popup = null;
        this.value = '';
        this.valueArr = [];
        this.list = [];
        if (this.options.plugin.value) {
            this.initValue = this.options.plugin.value;
        } else {
            this.initValue = '';
        }
        if (this.targetDom.nodeName == 'INPUT' || this.targetDom.nodeName == 'TEXTAREA') {
            this.targetDom.setAttribute('readonly', '');
            if (this.targetDom.value) {
                this.options.plugin.value = this.targetDom.value;
                this.initValue = this.targetDom.value;
            } else {
                if (this.initValue) {
                    this.targetDom.value = this.initValue;
                }
            }
        }
        if (this.options.type === 'checkbox' || this.options.type === 'radio') {
            if (!axIsEmpty(this.options.content)) {
                this.options.plugin.children = this.options.content;
            }
            this.options.plugin.type = this.options.type;
            if (this.options.grid.enable) {
                this.options.plugin.display = 'grid';
                this.options.grid.columns ? this.options.plugin.columns = this.options.grid.columns : null;
                if (this.options.grid.fenceShow) {
                    this.options.plugin.parentClass = 'ax-fence';
                    this.options.plugin.childClass = 'ax-padding-left'
                    this.options.popup.padding = false;
                }
            } else {
                this.options.plugin.display = 'block';
            }
            this.plugin = new axCheckbox('', this.options.plugin);
            this.popup = new axPopup(this.targetDom, Object.assign(this.options.popup, {
                content: this.plugin.parent,
                cancel: '',
                diy: {
                    text: '重置',
                    callback: function () {
                        _this.plugin.reset();
                    }
                },
                confirm: {
                    type: 'prevent',
                    callback: function () {
                        _this.value = _this.plugin.getValues('string');
                        _this.valueArr = _this.plugin.getValues('array');
                        if (_this.options.onBeforeSet) {
                            _this.options.onBeforeSet.call(_this, _this.value);
                        } else {
                            _this.setToHide(_this.value);
                        }
                        _this.options.onConfirm && _this.options.onConfirm.call(_this, _this.value);
                        'confirm' in _this.handlers ? _this.emit('confirm', _this.value) : null;
                    }
                }
            }));
            this.popup.on('show', () => {
                if ((this.targetDom.nodeName === 'INPUT' || this.targetDom.nodeName === 'TEXTAREA') && this.targetDom.value) {
                    if (this.targetDom.value != this.plugin.getValues('string')) {
                        this.updateValues(this.targetDom.value);
                    }
                }
            });
        } else if (this.options.type === 'list') {
            this.popup = new axPopup(this.targetDom, Object.assign(this.options.popup, { footerShow: false, padding: false }));
            let listDom = null;
            if (axType(this.options.content) === 'String') {
                if (axStrType(this.options.content)) {
                    listDom = axIdToDom(this.options.content);
                    this.popup.content.innerHTML = axIdToDom(this.options.content).innerHTML;
                } else {
                    this.popup.content.innerHTML = this.options.content;
                }
            } else if (axType(this.options.content).includes('HTML')) {
                this.popup.content.innerHTML = this.options.content.innerHTML;
            } else if (axType(this.options.content) === 'Array') {
                listDom = axAddElem('div', { class: 'ax-list-wrapper' });
                this.renderList(this.options.content, listDom);
                this.popup.content.innerHTML = '';
                this.popup.content.appendChild(listDom);
            }
        } else if (this.options.type === 'button') {
            this.popup = new axPopup(this.targetDom, Object.assign(this.options.popup, { footerShow: false, padding: false }));
            let listDom = axAddElem('div', { class: 'ax-list-wrapper' });
            this.renderList(this.options.content, listDom);
            this.list.forEach(k => {
                if (!k.props.disabled) {
                    k.dom.onclick = function (e) {
                        axPreventDefault(e);
                        _this.value = k.props.value;
                        _this.valueArr = [k.props.value];
                        this.classList.add('ax-confirm');
                        _this.list.filter(i => i.dom != this).forEach(x => {
                            x.dom.classList.remove('ax-confirm');
                        });
                        if (_this.options.onBeforeSet) {
                            _this.options.onBeforeSet.call(_this, k.props.value)
                        } else {
                            _this.setToHide(k.props.value);
                        }
                    }
                }
            });
            this.popup.content.innerHTML = '';
            this.popup.content.appendChild(listDom);
            this.initValue ? this.updateValues(this.initValue) : null;
            this.popup.on('show', () => {
                if ((this.targetDom.nodeName === 'INPUT' || this.targetDom.nodeName === 'TEXTAREA') && this.targetDom.value) {
                    this.updateValues(this.targetDom.value);
                }
            });
        } else if (this.options.type === 'text' || this.options.type === 'textarea') {
            this.options.plugin.type = this.options.type;
            this.options.content ? this.options.plugin.value = this.options.content : null;
            this.plugin = new axInput('', this.options.plugin);
            this.popup = new axPopup(this.targetDom, Object.assign(this.options.popup, {
                content: this.plugin.parent,
                cancel: '',
                diy: {
                    text: '重置',
                    callback: function () {
                        _this.plugin.set(_this.initValue);
                    }
                },
                confirm: {
                    type: 'prevent',
                    callback: function () {
                        _this.value = _this.plugin.getValues('string');
                        _this.valueArr = _this.plugin.getValues('array');
                        if (_this.options.onBeforeSet) {
                            _this.options.onBeforeSet.call(_this, _this.value);
                        } else {
                            _this.setToHide(_this.value);
                        }
                        _this.options.onConfirm && _this.options.onConfirm.call(_this, _this.value);
                        'confirm' in _this.handlers ? _this.emit('confirm', _this.value) : null;
                    }
                }
            }));
            this.popup.on('show', () => {
                if ((this.targetDom.nodeName === 'INPUT' || this.targetDom.nodeName === 'TEXTAREA') && this.targetDom.value) {
                    if (this.targetDom.value != this.plugin.getValues()) {
                        this.updateValues(this.targetDom.value);
                    }
                }
                setTimeout(() => {
                    let value = this.plugin.field.value;
                    this.plugin.field.value = '';
                    this.plugin.field.focus();
                    this.plugin.field.value = value;
                }, 100);
            });
            if (this.options.type === 'text') {
                this.plugin.field.onkeyup = function (e) {
                    if (e.code === 'Enter') {
                        _this.popup.options.confirm.callback();
                    }
                }
            }
        } else if (this.options.type === 'number') {
            this.options.plugin.width = '100%';
            this.plugin = new axAmount('', this.options.plugin);
            this.popup = new axPopup(this.targetDom, Object.assign(this.options.popup, {
                content: this.plugin.parent,
                cancel: '',
                diy: {
                    text: '重置',
                    callback: function () {
                        _this.plugin.reset();
                    }
                },
                confirm: {
                    type: 'prevent',
                    callback: function () {
                        _this.value = _this.plugin.value;
                        _this.valueArr.push(_this.plugin.value);
                        if (_this.options.onBeforeSet) {
                            _this.options.onBeforeSet.call(_this, _this.value);
                        } else {
                            _this.setToHide(_this.value);
                        }
                        _this.options.onConfirm && _this.options.onConfirm.call(_this, _this.value);
                        'confirm' in _this.handlers ? _this.emit('confirm', _this.value) : null;
                    }
                }
            }));
            this.popup.on('show', () => {
                if ((this.targetDom.nodeName === 'INPUT' || this.targetDom.nodeName === 'TEXTAREA') && this.targetDom.value) {
                    if (this.targetDom.value != this.plugin.value) {
                        this.updateValues(this.targetDom.value);
                    }
                }
            });
            setTimeout(() => {
                let value = this.plugin.field.value;
                this.plugin.field.value = '';
                this.plugin.field.focus();
                this.plugin.field.value = value;
            }, 100);
            this.plugin.field.onkeyup = function (e) {
                if (e.code === 'Enter') {
                    _this.popup.options.confirm.callback();
                }
            }
        } else if (this.options.type === 'switch') {
        } else if (this.options.type === 'html') {
            this.popup = new axPopup(this.targetDom, Object.assign(this.options.popup, {
                footerShow: false,
                content: this.options.content,
            }));
        }
        this.setAttribute();
        this.options.onInit && this.options.onInit.call(this);
    }
    setAttribute() {
        if (this.options.arrowShow) {
            if (this.targetDom && !this.targetDom.querySelector('.ax-at-right')) {
                let arrow = axAddElem('i', { class: 'ax-dropdown-arrow' });
                this.targetDom.appendChild(arrow);
            }
        }
        this.popup.targetDom.classList.add('ax-dropdown');
    }
    setToHide(value, callback) {
        value = value || this.value;
        if (this.targetDom.nodeName === 'INPUT') {
            this.targetDom.value = value;
        }
        this.options.onAfterSet && this.options.onAfterSet.call(this, value);
        'set' in this.handlers ? this.emit('set', value) : null;
        callback && callback.call(this, value);
        this.popup.hide();
    }
    updateToShow(value) {
        this.popup.show();
        setTimeout(() => {
            this.updateValues(value);
        }, 100);
    }
    updateValues(value) {
        if (['checkbox', 'radio', 'text', 'textarea', 'number'].includes(this.options.type)) {
            this.plugin.set(value);
        } else if (this.options.type === 'button') {
            let str = ''
            if (Array.isArray(value)) {
                str = value[0];
            } else {
                str = value;
            }
            this.list.forEach(k => {
                if (k.props.value === str) {
                    k.dom.classList.add('ax-confirm');
                } else {
                    k.dom.classList.remove('ax-confirm');
                }
            });
        }
    }
    getValues(type = 'string',) {
        if (type === 'string') {
            return this.value;
        } else if (type === 'array') {
            return this.valueArr;
        }
    }
    renderList(arr, parent) {
        if (this.options.grid.enable) {
            let classNames = 'ax-grid';
            this.options.grid.columns ? classNames += ` ax-grid-${this.options.grid.columns}` : null;
            this.options.grid.fenceShow ? classNames += ' ax-fence' : null;
            axClass.add(parent, classNames);
        }
        arr.forEach((k, i) => {
            let item = axAddElem(this.options.node, { class: `ax-info-block${k.disabled ? ' ax-disabled' : ''}`, ...k.props }, `<div class="ax-row"><div class="ax-col"></div></div>`),
                col = item.querySelector('.ax-col'),
                title = null;
            if (this.options.node === 'a') {
                if (this.options.type === 'list') {
                    item.target = k.target ? k.target : '_blank';
                    item.href = k.url ? k.url : '###';
                } else {
                    item.href = '###';
                }
            }
            if (this.options.nowrap) {
                if (this.options.node != 'a' && k.url) {
                    title = axAddElem('a', { class: 'ax-ell' }, k.label)
                    if (this.options.type === 'list') {
                        title.target = k.target ? k.target : '_blank';
                        title.href = k.url ? k.url : '###';
                    } else {
                        title.href = '###';
                    }
                } else {
                    title = axAddElem('span', { class: 'ax-ell' }, k.label);
                }
                col.appendChild(title);
            } else {
                col.textContent = k.label;
            }
            if (!axIsEmpty(k.prefix)) {
                if (k.prefix.type === 'icon') {
                    col.insertAdjacentElement('beforebegin', axAddElem('i', { class: 'ax-icon ax-iconfont ' + k.prefix.data }));
                } else if (k.prefix.type === 'head') {
                    col.insertAdjacentElement('beforebegin', axAddElem('i', { class: 'ax-head', style: 'background-image:url(' + k.prefix.data + '),var(--load-gif);' }));
                }
                else if (k.prefix.type === 'image') {
                    col.insertAdjacentElement('beforebegin', axAddElem('i', { class: 'ax-image' }, '<img src="' + k.prefix.data + '"/>'));
                }
            }
            if (k.suffix) {
                col.insertAdjacentElement('afterend', axAddElem('span', { class: 'ax-arrow' }, k.suffix));
            }
            parent.appendChild(item);
            if (!this.options.grid.enable && this.options.breakShow && i + 1 != this.options.content.length) {
                parent.insertAdjacentHTML('beforeend', '<div class="ax-break-line"></div>');
            }
            this.list.push({ props: k, dom: item })
            if (!k.disabled) {
                k.callback && k.callback(item, k);
            }
        });
    }
    update(setting, callback) {
        this.popup.targetDom.remove();
        this.popup.destroy();
        this.options.content = axExtend(this.options.content,setting);
        this.init();
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update') : null;
        callback && callback.call(this);
        return this;
    }
    updateContent(data, callback) {
        this.popup.targetDom.remove();
        this.popup.destroy();
        this.options.content = data;
        this.init();
        this.options.onUpdateContent && this.options.onUpdateContent.call(this);
        'updateContent' in this.handlers ? this.emit('updateContent') : null;
        callback && callback.call(this);
        return this;
    }
    show(callback) {
        this.popup.show();
        callback && callback.call(this);
        return this;
    }
    hide(callback) {
        this.popup.hide();
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axDropdown]').forEach(element => {
        new axDropdown(element);
    });
})();
/*!
* 插件：表单数量步进增减；使用方法：new axAmount('#id',{参数})
*/
const axAmounts = [];
class axAmount {
    constructor(elem, options) {
        this.targetDom = elem ? axIdToDom(elem) : '';
        this.options = axExtend({
            width: '',
            placeholder: '输入数量',
            value: '',
            min: '',
            max: '',
            step: 1,
            precision: 0,
            rule: '',
            disabled: false,
            increase: true,
            decrease: true,
            cookie: '',
            onInit: '',
            onMined: '',
            onMaxed: '',
            onUpdated: '',
            onChanged: '',
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.value = '';
        this.activeIn = true;
        this.activeDe = true;
        this.init();
    }
    init() {
        if (this.options.min !== '' && this.options.mam !== '' && this.options.min > this.options.mam) {
            console.error('The minimum value is greater than the maximum value!');
            return false;
        }
        this.createSkeleton();
        this.ruleToSet();
        this.initValue();
        this.getCookie();
        this.rawValue = this.value;
        this.setAttribute();
        let eventKey = (e) => {
            if (e.code === 'ArrowUp' || e.code === 'ArrowRight') {
                e.preventDefault();
                eventIncrease();
            } else if (e.code === 'ArrowLeft' || e.code === 'ArrowDown') {
                e.preventDefault();
                eventDecrease();
            }
        }
        let eventIncrease = () => {
            if (!this.activeDe) {
                this.options.decrease = true;
                this.decrease.removeAttribute('disabled');
            }
            let val = Number(this.field.value),
                old = Number(this.field.value);
            if (this.options.max === '') {
                val = val + this.options.step;
            } else if (this.options.max !== '' && val < this.options.max) {
                val = val + this.options.step;
            }
            if (this.options.max !== '' && ((val + this.options.step) > this.options.max)) {
                this.options.increae = false;
                this.increase.setAttribute('disabled', 'true');
                this.activeIn = false;
                this.options.onMaxed && this.options.onMaxed.call(this);
                'maxed' in this.handlers ? this.emit('maxed', '') : null;
            }
            this.field.value = val.toFixed(this.options.precision);
            this.value = this.field.value;
            this.setCookie();
            if (this.field.value > old) {
                this.options.onChanged && this.options.onChanged.call(this, old, this.field.value);
                'changed' in this.handlers ? this.emit('changed', old, this.field.value) : null;
            }
        }
        let eventDecrease = () => {
            if (!this.activeIn) {
                this.options.increae = true;
                this.increase.removeAttribute('disabled');
            }
            let val = Number(this.field.value),
                old = Number(this.field.value);
            if (this.options.min === '') {
                val = val - this.options.step;
            } else if (this.options.min !== '' && val > this.options.min) {
                val = val - this.options.step;
            }
            if (this.options.min !== '' && ((val - this.options.step) < this.options.min)) {
                this.options.decreae = false;
                this.decrease.setAttribute('disabled', 'true');
                this.activeDe = false;
                this.options.onMined && this.options.onMined.call(this);
                'mined' in this.handlers ? this.emit('mined', '') : null;
            }
            this.field.value = val.toFixed(this.options.precision);
            this.value = this.field.value;
            this.setCookie();
            if (this.field.value < old) {
                this.options.onChanged && this.options.onChanged.call(this, old, this.field.value);
                'changed' in this.handlers ? this.emit('changed', old, this.field.value) : null;
            }
        }
        if (this.options.disabled || this.field.hasAttribute('disabled')) {
            this.increase.removeEventListener('click', eventIncrease, false);
            this.decrease.removeEventListener('click', eventDecrease, false);
            this.field.setAttribute('disabled', '');
        } else {
            if (!this.options.increase || this.increase.hasAttribute('disabled')) {
                this.increase.removeEventListener('click', eventIncrease, false);
                this.increase.setAttribute('disabled', '');
            } else {
                this.increase.addEventListener('click', eventIncrease, false);
                this.field.addEventListener('keydown', eventKey, false);
            }
            if (!this.options.decrease || this.decrease.hasAttribute('disabled')) {
                this.decrease.removeEventListener('click', eventDecrease, false);
                this.decrease.setAttribute('disabled', '');
            } else {
                this.decrease.addEventListener('click', eventDecrease, false);
                this.field.addEventListener('keydown', eventKey, false);
            }
            this.field.onblur = () => {
                this.value =  this.correctValue(Number(this.field.value));
                this.field.value = this.value;
                this.setCookie();
            }
            this.field.addEventListener('keyup',(e)=>{
                if (e.code === 'Enter') {
                    this.field.blur();
                }
            },false)
        }
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    ruleToSet() {
        switch (this.options.rule) {
            case 'currency':
                this.options.min = 0.00; this.options.max = ''; this.options.step = 0.01; this.options.precision = 2;
                break;
            case 'quantity':
                this.options.min = 1; this.options.max = 999; this.options.step = 1; this.options.precision = 0;
                break;
            case 'percent':
                this.options.min = 0; this.options.max = 100; this.options.step = 1; this.options.precision = 0;
                break;
            case 'month':
                this.options.min = 1; this.options.max = 12; this.options.step = 1; this.options.precision = 0;
                break;
            case 'day':
                this.options.min = 1; this.options.max = 31; this.options.step = 1; this.options.precision = 0;
                break;
            case 'hour':
                this.options.min = 0; this.options.max = 24; this.options.step = 1; this.options.precision = 0;
                break;
            case 'minute':
                this.options.min = 0; this.options.max = 59; this.options.step = 1; this.options.precision = 0;
                break;
            case 'second':
                this.options.min = 0; this.options.max = 59; this.options.step = 1; this.options.precision = 0;
                break;
            default:
                null;
        }
    }
    initValue() {
        if (this.options.value !== '') {
            if (this.options.min !== '' && this.options.value < this.options.min) {
                this.value = this.options.min;
            } else if (this.options.max !== '' && this.options.value > this.options.max) {
                this.value = this.options.max;
            } else {
                this.value = this.options.value;
            }
            this.field.value = this.value;
        } else {
            if (this.field.value) {
                if (this.options.min !== '' && this.options.min > Number(this.field.value)) {
                    this.field.value = this.options.min;
                }
                if (this.options.max !== '' && this.options.max < Number(this.field.value)) {
                    this.field.value = this.options.max;
                }
                this.value = this.field.value;
            }
        }
    }
    getCookie() {
        let cookieValue = axCookie.get(this.options.cookie);
        if (this.options.cookie && cookieValue) {
            this.value = cookieValue;
            this.field.value = cookieValue;
        }
    }
    setCookie() {
        if (this.options.cookie) {
            axCookie.set(this.options.cookie, Number(this.field.value));
        }
    }
    setAttribute() {
        if (this.options.disabled) {
            this.field.setAttribute('disabled', 'true');
            this.increase.setAttribute('diabled', 'true');
            this.decrease.setAttribute('diabled', 'true');
        }
        if (!this.options.increase) {
            this.increase.setAttribute('diabled', 'true');
        }
        if (!this.options.decrease) {
            this.decrease.setAttribute('diabled', 'true');
        }
        !this.field.getAttribute('placeholder') ? this.field.setAttribute('placeholder', this.options.placeholder) : null;
        this.options.width ? this.parent.style.width = this.options.width : null;
    }
    createSkeleton() {
        if (!this.targetDom || this.targetDom.nodeName === 'INPUT') {
            this.parent = axAddElem('div', { class: 'ax-amount' });
            this.field = this.targetDom ? this.targetDom : axAddElem('input', { type: 'text' });
            this.decrease = axAddElem('a', { href: '###', decrease: '' }, '<i class="ax-iconfont ax-icon-minus"></i>');
            this.increase = axAddElem('a', { href: '###', increase: '' }, '<i class="ax-iconfont ax-icon-plus"></i>');
            this.field.insertAdjacentElement('beforeBegin', this.parent);
            this.parent.appendChild(this.field);
            this.parent.appendChild(this.decrease);
            this.parent.appendChild(this.increase);
        } else {
            this.parent = this.targetDom;
            this.field = this.parent.querySelector('input');
            this.increase = this.parent.querySelector('[increase]');
            this.decrease = this.parent.querySelector('[decrease]');
        }
    }
    correctValue(value){
        if (this.options.min !== '' && value < this.options.min) {
            value = this.options.min;
        } else if (this.options.max !== '' && value > this.options.max) {
            value = this.options.max;
        }
        return value;
    }
    set(value, callback) {
        value =  this.correctValue(value);
        this.field.value = value;
        this.value = value;
        if (this.options.cookie) {
            this.value = axCookie.set(this.options.cookie, value);
        }
        callback && callback.call(this, value);
        return this;
    }
    reset(callback) {
        this.set(this.rawValue);
        callback && callback.call(this, this.rawValue);
        if (this.options.cookie) {
            this.value = axCookie.set(this.options.cookie, this.rawValue);
        }
        return this;
    }
    update(setting, callback) {
        this.options = axExtend(this.options, setting);
        this.options.onUpdated && this.options.onUpdated.call(this);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
document.querySelectorAll('[axAmount]').forEach(element => {
    new axAmount(element);
});
/*!
* 插件：页面社交分享；使用方法：new axShare('#id',{参数})
*/
class axShare {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.options = axExtend({
            source: '',
            title: '',
            des: '',
            url: window.location.href,
            image: '',
            key: '',
            origin: window.location.origin,
            qrTitle: '<p>在微信里点击“发现”，再点击“扫一扫，”<br />便可将本文分享至朋友圈。</p>',
            qrSize: 180,
            newPage: true,
            dialogText: '确定分享本页面？',
            onShare: '',
        }, options, this.targetDom,'axShare');
        let _this = this;
        this.handlers = {};
        if (!this.options.source) {
            this.options.source = document.querySelector('meta[name="site"]') || document.title;
        }
        if (!this.options.title) {
            this.options.title = document.querySelector('meta[name="title"]') || document.title;
        }
        if (!this.options.des) {
            this.options.des = document.querySelector('meta[name="description"]') || '';
        }
        if (!this.options.image) {
            this.options.image = (document.images[0] || 0).src || '';
        }
        this.init();
    }
    init() {
        this.shareUrl = {
            qzone: 'http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + this.options.url + '&title=' + this.options.title + '&desc=' + this.options.des + '&summary=' + this.options.summary + '&site=' + this.options.source + '&pics=' + this.options.image,
            youdao: 'http://note.youdao.com/memory/?title=' + this.options.title + '&pic=' + this.options.image + '&summary=' + this.options.des + '&url=' + this.options.url,
            qq: 'http://connect.qq.com/widget/shareqq/index.html?url=' + this.options.url + '&title=' + this.options.title + '&source=' + this.options.source + '&desc=' + this.options.des + '&pics=' + this.options.image + '&summary=' + this.options.summary,
            weibo: 'https://service.weibo.com/share/share.php?url=' + this.options.url + '&title=' + this.options.title + '&pic=' + this.options.image + '&appkey=' + this.options.key,
            daoban: 'http://shuo.douban.com/!service/share?href=' + this.options.url + '&name=' + this.options.title + '&text=' + this.options.des + '&image=' + this.options.image + '&starid=0&aid=0&style=11',
            linkedin: 'http://www.linkedin.com/shareArticle?mini=true&ro=true&title=' + this.options.title + '&url=' + this.options.url + '&summary=' + this.options.summary + '&source=' + this.options.source + '&armin=armin',
            facebook: 'https://www.facebook.com/sharer/sharer.php?u=' + this.options.url,
            twitter: 'https://twitter.com/intent/tweet?text=' + this.options.title + '&url=' + this.options.url + '&via=' + this.options.origin,
            google: 'https://plus.google.com/share?url=' + this.options.url,
            pinterest: 'https://www.pinterest.com/pin/create/button/?url=' + this.options.url + '&description=' + this.options.des + '&media=' + this.options.image,
            tumblr: 'https://www.tumblr.com/widgets/share/tool?shareSource=legacy&canonicalUrl=&url=' + this.options.url + '&title=' + this.options.title,
        }
        for (let k in this.shareUrl) {
            this.changeHref(k);
        }
        if (this.targetDom.querySelector('[share="wechat"]')) {
            if(typeof QRCode == 'undefined'){
                console.error('Please import the QRCode plugin first!');
                return false;
            }else{
                this.createQrcode()
            }
        }
    }
    changeHref(name) {
        let _this = this,
            a = this.targetDom.querySelector('[share=' + name + ']');
        if (a) {
            if (a.hasAttribute('confirm')) {
                a.addEventListener('click', function(e){
                    axPreventDefault(e);
                    new axDialog({
                        content: _this.options.dialogText,
                        footerType: 'right',
                        confirm: {
                            callback: function() {
                                if (_this.options.newPage) {
                                    window.open(_this.shareUrl[name]);
                                    this.hide();
                                } else {
                                    window.location.href = _this.shareUrl[name];
                                }
                                _this.options.onShare && _this.options.onShare.call(_this, name);
                            }
                        }
                    }).show();
                }, false);
            } else {
                if (this.options.newPage) {
                    a.setAttribute('target', '_blank');
                } else {
                    a.removeAttribute('target')
                }
                a.setAttribute('href', this.shareUrl[name]);
                a.addEventListener('click', (e) => {
                    _this.options.onShare && _this.options.onShare.call(_this, name);
                }, false);
            }
        }
    }
    createQrcode() {
        let wechat = this.targetDom.querySelector('[share="wechat"]')
        if (wechat.length === 0) {
            return false;
        }
        let qr = axAddElem('div', { class: 'ax-qrcode' });
        let qrBody = axAddElem('div', { class: 'ax-qrcode-body' });
        let qrTitle = axAddElem('div', { class: 'ax-qrcode-title' }, this.options.qrTitle);
        new QRCode(qrBody, { text: this.options.url, width: this.options.qrSize, height: this.options.qrSize });
        qr.appendChild(qrBody);
        qr.appendChild(qrTitle);
        new axPopup(wechat, {
            content: qr,
            padding: true,
            placement: 'bottom',
            close: false,
            footerShow: false,
        });
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axShare]').forEach(element => {
        new axShare(element);
    });
})();
/*!
* 插件：自动完成插件；使用方法：new axComplete('#id',{参数})
*/
class axComplete {
    constructor(elem, options) {
        this.options = axExtend({
            list: '',
            keys: ['name'],
            threshold: 0.6,
            isCaseSensitive: false,
            hasMatches: true,
            minLength: 1,
            findAll: false,
            template: '',
            className: '',
            break: true,
            tips: 'inside',
            highlight: true,
            rel: '',
            fill: 'name',
            idStart: 1,
        }, options, elem,'axComplete');
        /* data:[{id:1,name:'张三',value:'张三',age:''},
          {id:2,name:'李四',value:'李四',age:''},
          {id:3,name:'王五',value:'王五',age:''},] 
          keys:['name','age']
          */
        this.input = axIdToDom(elem);
        this.handlers = {};
        this.rel = this.options.rel ? axIdToDom(this.options.rel) : '';
        this.outerDom = axAddElem('div', this.options.className ? { class: this.options.className } : { class: 'ax-complete' });
        this.popup = this.createPopup();
        this.popup.content.appendChild(this.outerDom);
        this.innerDom = axAddElem('div', { class: 'ax-complete-list' });
        this.outerDom.appendChild(this.innerDom);
        this.tipsDom = axAddElem('div', { class: 'ax-complete-tips' });
        if (!this.options.tips) {
            this.tipsDom.remove();
        } else if (this.options.tips == 'inline') {
            this.input.insertAdjacentElement('afterend', this.tipsDom);
        } else if (this.options.tips.substr(0, 1) == '#') {
            axIdToDom(this.options.tips).appendChild(this.tipsDom);
        } else {
            this.outerDom.insertAdjacentElement('afterbegin', this.tipsDom);
        }
        this.data = [];
        this.init();
    }
    init() {
        let _this = this;
        this.getData();
        if (axIsEmpty(this.data)) {
            console.error('There is no valid data!')
            return false;
        }
        this.fuseOpt = { includeScore: true };
        this.fuseOpt.threshold = this.options.threshold;
        this.fuseOpt.includeMatches = this.options.hasMatches;
        this.fuseOpt.minMatchCharLength = this.options.minLength;
        this.fuseOpt.findAllMatches = this.options.findAll;
        if (axIsEmpty(this.options.keys)) {
            this.fuseOpt.keys = ['name'];
        } else {
            this.fuseOpt.keys = this.options.keys;
        }
        this.initList();
        this.fuse = new Fuse(this.data, this.fuseOpt);
        this.input.addEventListener('input', function () {
            _this.results = _this.fuse.search(this.value.trim());
            _this.innerDom.innerHTML = _this.renderDom();
            if (_this.options.tips) {
                _this.tipsDom.innerHTML = `共有${_this.results.length}个结果符合要求`
            }
            if (_this.options.highlight) {
                _this.results.forEach((i, index) => {
                    let matchItem = _this.innerDom.querySelectorAll('[role="item"]')[index],
                        matchName = matchItem.querySelector('[role="name"]').innerHTML;
                    i.matches[0].indices.forEach(element => {
                        let separate = matchName.substring(element[0], element[1] + 1),
                            matchArray = matchName.split(separate),
                            newString = matchArray.join('<i class="ax-mark">' + separate + '</i>');
                        matchItem.querySelector('[role="name"]').innerHTML = newString;
                    });
                    matchItem.onclick = function () {
                        if (_this.options.fill && Object.keys(i.item).indexOf(_this.options.fill) > -1) {
                            _this.input.value = i.item[_this.options.fill];
                            'selected' in _this.handlers ? _this.emit('selected', i.item) : null;
                        } else {
                            _this.input.value = i.item.name;
                            'selected' in _this.handlers ? _this.emit('selected', i.item) : null;
                        }
                        _this.popup.hide();
                    }
                });
            }
            if (!this.value) {
                _this.tipsDom.innerHTML = '';
                axDebounce(_this.initList());
            }
        }, false);
    }
    getData() {
        if (typeof this.options.list == 'string') {
            if (this.options.list.substr(0, 1) == '#') {
                this.data = axListToArr(this.options.list, this.options.idStart);
            } else {
                let splitArr = this.options.list.split(','),
                    newArr = [];
                splitArr.forEach((item, index) => {
                    let obj = {};
                    obj.id = this.options.idStart + index;
                    obj.name = item;
                    obj.value = item;
                    newArr.push(obj);
                });
                this.data = newArr;
            }
        } else if (this.options.list instanceof Array) {
            if (typeof this.options.list[0] == 'object') {
                this.options.list.forEach((item, index) => {
                    !item.id ? item.id = this.options.idStart + index : null;
                    !item.value ? item.value = item.name : null;
                });
                this.data = this.options.list;
            } else if (typeof this.options.list[0] == 'string') {
                let newArr = [];
                this.options.list.forEach((item, index) => {
                    let obj = {};
                    obj.id = this.options.idStart + index;
                    obj.name = item;
                    obj.value = item;
                    newArr.push(obj);
                });
                this.data = newArr;
            }
        }
        return this.data;
    }
    createPopup() {
        return new axPopup(this.input, {
            content: this.outerDom,
            trigger: 'input',
            padding: false,
            placement: 'bottom-start',
            close: false,
            footerShow: false,
        });
    }
    renderDom() {
        let template = '';
        if (!axIsEmpty(this.results)) {
            this.results.forEach((elem, index) => {
                template += axTplEngine(this.createTemplate(), elem);
                if (this.options.break && index + 1 < this.results.length) {
                    template += `<div class="ax-break-line"></div>`;
                }
            });
            this.innerDom.innerHTML = template;
        } else {
            this.innerDom.innerHTML = '';
        }
        return this.innerDom.innerHTML;
    }
    initList() {
        let _this = this;
        this.innerDom.innerHTML = this.initDom();
        if (this.options.rel) {
            this.rel.onclick = function () {
                if (!_this.popup.targetDom.classList.contains('ax-show')) {
                    let value = _this.input.value;
                    _this.input.value = '';
                    _this.input.focus();
                    _this.input.value = value;
                    _this.popup.show();
                } else {
                    _this.input.blur();
                    _this.popup.hide();
                }
            }
        }
        this.innerDom.querySelectorAll('[role="item"]').forEach((item, index) => {
            item.onclick = function () {
                if (_this.options.fill && Object.keys(_this.data[index]).indexOf(_this.options.fill) > -1) {
                    _this.input.value = _this.data[index][_this.options.fill];
                } else {
                    _this.input.value = _this.data[index].name;
                }
                _this.popup.hide();
            }
        });
    }
    initDom() {
        let initData = [];
        this.data.forEach(i => {
            let newItem = {};
            newItem.item = i;
            initData.push(newItem);
        });
        let template = '';
        if (!axIsEmpty(this.data)) {
            initData.forEach((elem, index) => {
                template += axTplEngine(this.createTemplate(), elem);
                if (this.options.break && index + 1 < initData.length) {
                    template += `<div class="ax-break-line"></div>`;
                }
            });
            this.innerDom.innerHTML = template;
        } else {
            this.innerDom.innerHTML = '';
        }
        return this.innerDom.innerHTML;
    }
    createTemplate() {
        if (this.options.template) {
            return this.options.template;
        } else {
            return `<a href="###" class="ax-info-block ax-hover" role="item">
                <div class="ax-row">
                  <div class="ax-col"><span class="ax-ell" role="name"><# this.item.name #></span></div>
                </div>
              </a>
      `;
        }
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
document.querySelectorAll('[axComplete]').forEach(element => {
    new axComplete(element);
});
/*!
 * jeDate v6.5.0 from https://github.com/singod/jeDate | AXUI做了深度修改
 */
const axDate = (() => {
    var jet = {}, regymdzz = "YYYY|MM|DD|hh|mm|ss|zz";
    var $Q = function (selector, content) {
        content = content || document;
        return selector.nodeType ? selector : content.querySelector(selector);
    };
    var jeDate = function (elem, options) {
        var opts = typeof (options) === "function" ? options() : options;
        return new jeDatePick(elem, opts);
    };
    jeDate.extend = jet.extend = function () {
        var options, name, src, copy, deep = false, target = arguments[0], i = 1, length = arguments.length;
        if (typeof (target) === "boolean") deep = target, target = arguments[1] || {}, i = 2;
        if (typeof (target) !== "object" && typeof (target) !== "function") target = {};
        if (length === i) target = this, --i;
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name], copy = options[name];
                    if (target === copy) continue;
                    if (copy !== undefined) target[name] = copy;
                }
            }
        }
        return target;
    };
    jeDate.nowDate = function (val, format) {
        format = format || 'YYYY-MM-DD hh:mm:ss';
        if (!isNaN(val)) val = { DD: val };
        return jet.parse(jet.getDateTime(val), format);
    };
    jeDate.convert = function (obj) {
        obj.format = obj.format || 'YYYY-MM-DD hh:mm:ss';
        obj.addval = obj.addval || [];
        var mats = jet.reMatch(obj.format), objVal = {};
        jet.each(jet.reMatch(obj.val), function (i, cval) {
            objVal[mats[i]] = parseInt(cval);
        });
        var result = new DateTime(obj.addval, objVal), redate = {
            YYYY: result.GetYear(), MM: result.GetMonth(), DD: result.GetDate(),
            hh: result.GetHours(), mm: result.GetMinutes(), ss: result.GetSeconds()
        };
        return redate;
    };
    jeDate.valText = function (elem, value) {
        return jet.valText(elem, value);
    }
    jeDate.timeStampDate = function (date, format) {
        format = format || 'YYYY-MM-DD hh:mm:ss';
        var dateTest = (/^(-)?\d{1,10}$/.test(date) || /^(-)?\d{1,13}$/.test(date));
        if (/^[1-9]*[1-9][0-9]*$/.test(date) && dateTest) {
            var vdate = parseInt(date);
            if (/^(-)?\d{1,10}$/.test(vdate)) {
                vdate = vdate * 1000;
            } else if (/^(-)?\d{1,13}$/.test(vdate)) {
                vdate = vdate * 1000;
            } else if (/^(-)?\d{1,14}$/.test(vdate)) {
                vdate = vdate * 100;
            } else {
                alert("时间戳格式不正确");
                return;
            }
            var setdate = new Date(vdate);
            return jet.parse({
                YYYY: setdate.getFullYear(), MM: jet.digit(setdate.getMonth() + 1), DD: jet.digit(setdate.getDate()),
                hh: jet.digit(setdate.getHours()), mm: jet.digit(setdate.getMinutes()), ss: jet.digit(setdate.getSeconds())
            }, format);
        } else {
            var arrs = jet.reMatch(date),
                newdate = new Date(arrs[0], arrs[1] - 1, arrs[2], arrs[3] || 0, arrs[4] || 0, arrs[5] || 0),
                timeStr = Math.round(newdate.getTime() / 1000);
            return timeStr;
        }
    };
    jeDate.getLunar = function (obj) {
        var lunars = jeLunar(obj.YYYY, parseInt(obj.MM) - 1, obj.DD);
        return {
            nM: lunars.lnongMonth,              
            nD: lunars.lnongDate,               
            cY: parseInt(lunars.solarYear),     
            cM: parseInt(lunars.solarMonth),    
            cD: parseInt(lunars.solarDate),     
            cW: lunars.inWeekDays,              
            nW: lunars.solarWeekDay             
        };
    };
    jeDate.parse = jet.parse = function (ymdhms, format) {
        return format.replace(new RegExp(regymdzz, "g"), function (str, index) {
            return str == "zz" ? "00" : jet.digit(ymdhms[str]);
        });
    }
    function DateTime(arr, valObj) {
        var that = this, newdate = new Date(), narr = ["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds"];
        var vb = jet.extend({ YYYY: null, MM: null, DD: null, hh: newdate.getHours(), mm: newdate.getMinutes(), ss: newdate.getSeconds() }, valObj);
        var ND = valObj == undefined ? newdate : new Date(vb.YYYY, vb.MM, vb.DD, vb.hh, vb.mm, vb.ss);
        if ((arr || []).length > 0) jet.each(arr, function (i, par) {
            ND["set" + narr[i]](narr[i] == "Month" ? parseInt(par) - 1 : parseInt(par));
        });
        that.reDate = function () {
            return new DateTime();
        };
        that.GetValue = function () {
            return ND;
        };
        that.GetYear = function () {
            return ND.getFullYear();
        };
        that.GetMonth = function () {
            return ND.getMonth() + 1;
        };
        that.GetDate = function () {
            return ND.getDate();
        };
        that.GetHours = function () {
            return ND.getHours();
        };
        that.GetMinutes = function () {
            return ND.getMinutes();
        };
        that.GetSeconds = function () {
            return ND.getSeconds();
        };
    };
    jet.extend(jet, {
        isType: function (obj, type) {
            var firstUper = function (str) {
                str = str.toLowerCase();
                return str.replace(/\b(\w)|\s(\w)/g, function (m) {
                    return m.toUpperCase();
                });
            }
            return Object.prototype.toString.call(obj) == "[object " + firstUper(type) + "]";
        },
        each: function (obj, callback, args) {
            var name, i = 0, length = obj.length, iselem = (length === undefined || obj === "function");
            if (iselem) {
                for (name in obj) { if (callback.call(obj[name], name, obj[name]) === false) { break } }
            } else {
                for (; i < length;) { if (callback.call(obj[i], i, obj[i++]) === false) { break } }
            }
            return obj;
        },
        on: function (elm, type, fn) {
            if (elm.addEventListener) {
                elm.addEventListener(type, fn, false);
                return true;
            } else if (elm.attachEvent) {
                return elm.attachEvent("on" + type, fn);
            } else {
                elm["on" + type] = fn;
            }
        },
        isObj: function (obj) {
            for (var i in obj) { return true; }
            return false;
        },
        trim: function (str) { return str.replace(/(^\s*)|(\s*$)/g, ""); },
        reMatch: function (str) {
            var smarr = [], maStr = "", parti = /(^\w{4}|\w{2}\B)/g;
            if (jet.isNum(str)) {
                maStr = str.replace(parti, "$1-");
            } else {
                maStr = /^[A-Za-z]+$/.test(str) ? str.replace(parti, "$1-") : str;
            }
            jet.each(maStr.match(/\w+|d+/g), function (i, val) {
                smarr.push(jet.isNum(val) ? parseInt(val) : val);
            });
            return smarr;
        },
        equals: function (arrA, arrB) {
            if (!arrB) return false;
            if (arrA.length != arrB.length) return false;
            for (var i = 0, l = arrA.length; i < l; i++) {
                if (arrA[i] instanceof Array && arrB[i] instanceof Array) {
                    if (!arrA[i].equals(arrB[i])) return false;
                } else if (arrA[i] != arrB[i]) {
                    return false;
                }
            }
            return true;
        },
        docScroll: function (type) {
            type = type ? "scrollLeft" : "scrollTop";
            return document.body[type] | document.documentElement[type];
        },
        docArea: function (type) {
            return document.documentElement[type ? "clientWidth" : "clientHeight"];
        },
        digit: function (num) {
            return num < 10 ? "0" + (num | 0) : num;
        },
        isNum: function (value) {
            return /^[+-]?\d*\.?\d*$/.test(value) ? true : false;
        },
        getDaysNum: function (y, m) {
            var num = 31, isLeap = (y % 100 !== 0 && y % 4 === 0) || (y % 400 === 0);
            switch (parseInt(m)) {
                case 2: num = isLeap ? 29 : 28; break;
                case 4: case 6: case 9: case 11: num = 30; break;
            }
            return num;
        },
        getYM: function (y, m, n) {
            var nd = new Date(y, m - 1);
            nd.setMonth(m - 1 + n);
            return {
                y: nd.getFullYear(),
                m: nd.getMonth() + 1
            };
        },
        prevMonth: function (y, m, n) {
            return jet.getYM(y, m, 0 - (n || 1));
        },
        nextMonth: function (y, m, n) {
            return jet.getYM(y, m, n || 1);
        },
        setCss: function (elem, obj) {
            for (var x in obj) elem.style[x] = obj[x];
        },
        html: function (elem, html) {
            return typeof html === "undefined" ? elem && elem.nodeType === 1 ? elem.innerHTML : undefined : typeof html !== "undefined" && html == true ? elem && elem.nodeType === 1 ? elem.outerHTML : undefined : elem.innerHTML = html;
        },
        text: function (elem, value) {
            var innText = document.all ? "innerText" : "textContent";
            return typeof value === "undefined" ? elem && elem.nodeType === 1 ? elem[innText] : undefined : elem[innText] = value;
        },
        val: function (elem, value) {
            if (typeof value === "undefined") {
                return elem && elem.nodeType === 1 && typeof elem.value !== "undefined" ? elem.value : undefined;
            }
            value = value == null ? "" : value + "";
            elem.value = value;
        },
        attr: function (elem, value) {
            return elem.getAttribute(value);
        },
        hasClass: function (obj, cls) {
            return obj.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
        },
        stopPropagation: function (ev) {
            (ev && ev.stopPropagation) ? ev.stopPropagation() : window.event.cancelBubble = true;
        },
        template: function (str, data) {
            var strCell = !/[^\w\-\.:]/.test(str) ? document.getElementById(str).innerHTML : str;
            var keys = function (obj) {
                var arr = [];
                for (arr[arr.length] in obj);
                return arr;
            }, dataVar = function (obj) {
                var vars = '';
                for (var key in obj) {
                    vars += 'var ' + key + '= $D["' + key + '"];';
                }
                return vars;
            }, compile = function (source, data) {
                var code = "var $out='" + source.replace(/[\r\n]/g, '').replace(/^(.+?)\{\%|\%\}(.+?)\{\%|\%\}(.+?)$/g, function (val) {
                    return val.replace(/(['"])/g, '\\\$1');
                }).replace(/\{\%\s*=\s*(.+?)\%\}/g, "';$out+=$1;$out+='").replace(/\{\%(.+?)\%\}/g, "';$1;$out+='") + "';return new String($out);";
                var vars = dataVar(data), Render = new Function('$D', vars + code);
                return new Render(data) + '';
            };
            return compile(strCell, data);
        },
        isValDiv: function (elem) {
            return /textarea|input/.test(elem.tagName.toLocaleLowerCase());
        },
        valText: function (elem, value) {
            var cell = $Q(elem), type = jet.isValDiv(cell) ? "val" : "text";
            if (value != undefined) {
                jet[type](cell, value);
            } else {
                return jet[type](cell);
            }
        },
        isBool: function (obj) { return (obj == undefined || obj == true ? true : false); },
        getDateTime: function (obj) {
            var result = new DateTime(), objVal = jet.extend({ YYYY: null, MM: null, DD: null, hh: 0, mm: 0, ss: 0 }, obj),
                matArr = { YYYY: "FullYear", MM: "Month", DD: "Date", hh: "Hours", mm: "Minutes", ss: "Seconds" };
            jet.each(["ss", "mm", "hh", "DD", "MM", "YYYY"], function (i, mat) {
                if (!jet.isNum(parseInt(objVal[mat]))) return null;
                var reVal = result.GetValue();
                if (parseInt(objVal[mat]) || parseInt(objVal[mat]) == 0) {
                    reVal["set" + matArr[mat]](result["Get" + matArr[mat]]() + (mat == "MM" ? -1 : 0) + parseInt(objVal[mat]));
                }
            });
            var redate = {
                YYYY: result.GetYear(), MM: result.GetMonth(), DD: result.GetDate(),
                hh: result.GetHours(), mm: result.GetMinutes(), ss: result.GetSeconds()
            };
            return redate;
        }
    });
    function jeDatePick(elem, options) {
        /* var config = {
            language: {
                name: "cn",
                month: ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"],
                weeks: ["日", "一", "二", "三", "四", "五", "六"],
                times: ["小时", "分钟", "秒数"],
                timetxt: ["时间选择", "开始时间", "结束时间"],
                backtxt: "返回日期",
                clear: "清空",
                today: "现在",
                yes: "确定"
            },
            format: "YYYY-MM-DD hh:mm:ss",               
            minDate: "1900-01-01 00:00:00",              
            maxDate: "2099-12-31 23:59:59",              
            isShow: true,                                
            multiPane: true,                             
            onClose: true,                               
            range: false,                                
            trigger: "click",                            
            position: [],                                
            valiDate: [],                                
            isinitVal: false,                            
            initDate: {},                                
            isTime: true,                                
            isClear: true,                               
            isToday: true,                               
            isYes: true,                                 
            festival: false,                             
            fixed: true,                                 
            zIndex: 2099,                                
            method: {},                                 
            theme: {},                                   
            shortcut: [],                                
            donefun: null,                                
            before: null,                                
            succeed: null                                
        }; */
        var config = axExtend({
            language: {
                name: "cn",
                month: ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"],
                weeks: ["日", "一", "二", "三", "四", "五", "六"],
                times: ["小时", "分钟", "秒数"],
                timetxt: ["时间选择", "开始时间", "结束时间"],
                backtxt: "返回日期",
                clear: "清空",
                close: "关闭",
                today: "现在",
                yes: "确定"
            },
            format: "YYYY-MM-DD hh:mm:ss",               
            minDate: "1900-01-01 00:00:00",              
            maxDate: "2099-12-31 23:59:59",              
            mode: 'popup',                                
            isShow: true,                                
            multiPane: true,                             
            onClose: true,                               
            range: false,                                
            trigger: "click",                            
            position: [],                                
            valiDate: [],                                
            isinitVal: false,                            
            initDate: {},                                
            rel: '',
            isTime: true,                                
            isClear: false,                               
            clearFun: function () { },                       
            isClose: true,                               
            closeFun: function () { },                       
            isToday: true,                               
            isYes: true,                                 
            festival: false,                             
            fixed: true,                                 
            zIndex: 2099,                                
            nowClose: false,                               
            method: {},                                 
            theme: {},                                   
            shortcut: [],                                
            donefun: null,                                
            before: null,                                
            succeed: null                                
        }, options, elem,'axDate');
        this.$opts = jet.extend(config, options || {});
        this.valCell = $Q(elem);
        this.format = this.$opts.format;
        this.valCell != null ? this.init() : alert(elem + "  ID\u6216\u7C7B\u540D\u4E0D\u5B58\u5728!");
        jet.extend(this, this.$opts.method);
        delete this.$opts.method;
    }
    var searandom = function () {
        var str = "", arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
        for (var i = 0; i < 8; i++) str += arr[Math.round(Math.random() * (arr.length - 1))];
        return str;
    };
    var ymdzArr = jet.reMatch(regymdzz), elx = "#ax-date";
    jet.extend(jeDatePick.prototype, {
        init: function () {
            var that = this, opts = that.$opts,
                trigges = opts.trigger, ndate = opts.initDate || [], inVal, range = opts.range,
                isShow = jet.isBool(opts.isShow),
                isinitVal = (opts.isinitVal == undefined || opts.isinitVal == false) ? false : true;
            that.shortIndex = ''
            that.shortMenu = axAddElem('div', { class: 'ax-date-menu' });
            that.setDatas();
            opts.before && opts.before(that.valCell);
            if (isinitVal && trigges && isShow) {
                if (ndate[1]) {
                    var addval = jet.getDateTime(ndate[0]);
                    inVal = [{
                        YYYY: addval.YYYY, MM: jet.digit(addval.MM), DD: jet.digit(addval.DD),
                        hh: jet.digit(addval.hh), mm: jet.digit(addval.mm), ss: jet.digit(addval.ss)
                    }];
                } else {
                    inVal = that.getValue(jet.isObj(ndate[0]) ? ndate[0] : {});
                }
                if (!range) that.setValue([inVal[0]], opts.format, true);
            }
            var getCurrValue = function () {
                var mats = jet.reMatch(that.format), isEmpty = that.getValue() != "", curVal = [],
                    parmat = that.dlen == 7 ? "hh:mm:ss" : "YYYY-MM" + (that.dlen <= 2 ? "" : "-DD");
                var result = that.valCell.value;
                if (!result) {
                    that.selectValue = [jet.parse(jet.getDateTime({}), parmat)];
                } else {
                    result = result.substr(0, 11);
                    var nowTime = [jet.parse(jet.getDateTime({}), parmat)];
                    nowTime = nowTime[0];
                    var time1 = new Date(result).setHours('0');
                    var time2 = new Date(nowTime).setHours('0');
                    var nDays = (parseInt((time1 - time2) / 1000 / 3600 / 24));
                    var redate = {
                        DD: nDays
                    };
                    that.selectValue = [jet.parse(jet.getDateTime(redate), parmat)];
                }
                if (isEmpty && isShow) {
                    var getVal = that.getValue().split(range);
                    jet.each(new Array(range ? 2 : 1), function (a) {
                        curVal[a] = {};
                        jet.each(jet.reMatch(getVal[a]), function (i, val) {
                            curVal[a][mats[i]] = parseInt(val);
                        });
                    });
                    if (range) that.selectValue = getVal;
                } else {
                    var parr = that.getValue({})[0], nmVal = jet.nextMonth(parr.YYYY, parr.MM || jet.getDateTime({}).MM),
                        narr = (that.dlen > 2 && that.dlen <= 6) ? { YYYY: nmVal.y, MM: nmVal.m } : {};
                    curVal = [parr];
                }
                that.selectDate = curVal;
                return curVal;
            }, ymarr = [];
            that.minDate = ""; that.maxDate = "";
            if (!isShow || !trigges) ymarr = getCurrValue();
            if (!isShow || !trigges) {
                that.minDate = jet.isType(opts.minDate, "function") ? opts.minDate(that) : opts.minDate;
                that.maxDate = jet.isType(opts.maxDate, "function") ? opts.maxDate(that) : opts.maxDate;
                that.storeData(ymarr[0], ymarr[1]);
                that.renderDate();
                opts.succeed && opts.succeed(that.dateCell);
            } else {
                if (trigges) {
                    if (document.querySelectorAll(elx).length > 0) return;
                    var gvarr = getCurrValue();
                    that.minDate = jet.isType(opts.minDate, "function") ? opts.minDate(that) : opts.minDate;
                    that.maxDate = jet.isType(opts.maxDate, "function") ? opts.maxDate(that) : opts.maxDate;
                    that.storeData(gvarr[0], gvarr[1]);
                    that.renderDate();
                    if (opts.mode == 'inline') {
                        that.valCell.insertAdjacentElement('afterend', that.dateCell);
                        that.valCell.setAttribute('readonly', '');
                    } else if (opts.mode == 'dialog') {
                        that.dialog = new axDialog({
                            size: '',
                            padding: false,
                            footerShow: false,
                            content: that.dateCell,
                        });
                        that.valCell.addEventListener('click', function () {
                            that.dialog.show();
                        }, false);
                    } else {
                        that.popup = new axPopup(that.valCell, {
                            size: '',
                            padding: false,
                            rel: opts.rel,
                            placement: 'bottom-start',
                            close: false,
                            footerShow: false,
                            content: that.dateCell,
                        });
                    }
                    /* jet.on(that.valCell, trigges, function () {
                    }); */
                }
            }
        },
        setDatas: function () {
            var that = this, opts = that.$opts, range = opts.range, shortArr = [], isShow = jet.isBool(opts.isShow), multi = opts.multiPane;
            that.$data = jet.extend({ year: false, month: false, day: true, time: false, timebtn: false }, {
                shortcut: [], lang: opts.language, yaerlist: [], monthlist: [[], []], ymlist: [[], []], daylist: [[], []],
                clear: opts.isClear, close: opts.isClose, today: range ? false : opts.isToday, yes: opts.isYes, pane: multi ? 1 : 2
            });
            if (opts.shortcut.length > 0) {
                jet.each(opts.shortcut, function (i, short) {
                    var tarr = [], shval = jet.isType(short.val, "function") ? short.val() : short.val;
                    if (jet.isType(shval, "object")) {
                        for (var s in shval) tarr.push(s + ':' + shval[s]);
                        shortArr.push(jet.extend({}, { name: short.name, val: "{" + tarr.join('#') + "}" }));
                    }
                });
                that.$data.shortcut = shortArr;
            }
            that.dlen = (function () {
                var mats = jet.reMatch(that.format), marr = [];
                jet.each(ymdzArr, function (i, val) {
                    jet.each(mats, function (m, mval) {
                        if (val == mval) marr.push(mval);
                    });
                });
                var matlen = marr.length, lens = (marr[0] == "hh") && matlen <= 3 ? 7 : matlen;
                return lens;
            })();
            that.$data.dlen = that.dlen;
            that.timeInspect = false;
            if (that.dlen == 1) {
                jet.extend(that.$data, { year: true, day: false });
            } else if (that.dlen == 2) {
                jet.extend(that.$data, { month: true, day: false });
            } else if (that.dlen > 3 && that.dlen <= 6) {
                that.$data.timebtn = true;
            } else if (that.dlen == 7) {
                jet.extend(that.$data, { day: false, time: true });
            }
            if (!isShow) {
                that.$data.clear = false;
                that.$data.yes = false;
            }
        },
        renderDate: function () {
            var that = this, opts = that.$opts, isShow = jet.isBool(opts.isShow),
                elxID = elx + searandom(); 
            if (that.dateCell == undefined) {
                that.dateCell = document.createElement("div");
                that.dateCell.id = elxID.replace(/\#/g, "");
                that.dateCell.className = elx.replace(/\#/g, "") + " " + (opts.festival ? " ax-with-calendar" : "");
                that.wrapper = axAddElem('div', { class: 'ax-date-wrapper' });
                that.dateCell.appendChild(that.wrapper);
            }
            jet.html(that.wrapper, jet.template(that.dateTemplate(), that.$data));
            if (jet.isObj(opts.theme)) {
                var styleDiv = document.createElement("style"), stCell = ".ax-date" + searandom(), t = opts.theme,
                    BG = "background-color:" + t.bgcolor, WC = "color:" + (t.color == undefined ? "#FFFFFF" : t.color),
                    OTH = (t.pnColor == undefined ? "" : "color:" + t.pnColor + ";");
                that.dateCell.className = that.dateCell.className + " " + stCell.replace(/^./g, ""); styleDiv.setAttribute("type", "text/css");
                styleDiv.innerHTML = stCell + " .ax-date-menu p:hover{" + BG + ";" + WC + ";}" + stCell + " .ax-date-header em{" + WC + ";}" +
                    stCell + " .ax-date-body .ytable td.ax-selected span," + stCell + " .ax-date-body .ax-mtable td.ax-selected span," +
                    stCell + " .ax-date-body .ytable td.ax-selected span:hover," + stCell + " .ax-date-body .ax-mtable td.ax-selected span:hover{" + BG + ";border:1px " + t.bgcolor + " solid;" + WC + ";}" + stCell + " .ax-date-body .ax-dtable td.ax-selected," + stCell + " .ax-date-body .ax-dtable td.ax-selected:hover," +
                    stCell + " .ax-date-body .ax-dtable td.ax-selected .lunar," + stCell + " .ax-date-header," + stCell + " .ax-date-time .ax-date-header," +
                    stCell + " .ax-date-time .ax-time-list ul li.ax-selected," + stCell + " .ax-date-time .ax-time-list ul li.ax-selected:hover," +
                    stCell + " .ax-date-time .ax-time-list ul li.ax-disabled.ax-selected," + stCell + " .ax-date-footbtn .timecon," + stCell + " .ax-date-footbtn .btnscon span{" + BG + ";" + WC + ";}" +
                    stCell + " .ax-date-body .ax-dtable td.ax-other," + stCell + " .ax-date-body .ax-dtable td.ax-other .ax-unit," + stCell + " .ax-date-body .ax-dtable td.ax-other .lunar{" + OTH + "}" + stCell + " .ax-date-body .ax-dtable td.contain," + stCell + " .ax-date-body .ax-dtable td.contain:hover{background-" + OTH + "}";
                that.dateCell.appendChild(styleDiv);
            }
            that.compileBindNode(that.dateCell);
            if (document.querySelectorAll(elxID).length > 0) document.body.removeChild($Q(elxID));
            !isShow ? that.valCell.appendChild(that.dateCell) : null;
            that.methodEventBind();
            if (that.dlen == 7 || (that.dlen > 3 && that.dlen <= 6)) that.locateScroll();
            if (opts.festival && opts.language.name == "cn") {
                that.showFestival();
            }
            if (isShow) {
                that.dateOrien(that.dateCell, that.valCell);
                that.blankArea();
            }
            if (opts.shortcut.length > 0) {
                that.shortMenu.innerHTML = '';
                for (var s = 0; s < opts.shortcut.length; s++) {
                    that.shortMenu.innerHTML += '<a href="###">' + opts.shortcut[s].name + '</a>';
                }
                that.wrapper.insertAdjacentElement('afterbegin', that.shortMenu);
                that.shortMenu.querySelectorAll('a').forEach((item, index) => {
                    item.onclick = function () {
                        that.shortIndex = index;
                        that.shortClick(JSON.stringify(opts.shortcut[index].val));
                    }
                });
                that.shortIndex !== '' ? that.shortMenu.querySelectorAll('a')[that.shortIndex].classList.add('ax-selected') : null;
            }
        },
        setValue: function (fnStr, matStr, bool) {
            var that = this, valCell = that.valCell, strVal;
            matStr = matStr || that.format;
            if ((typeof fnStr == 'string') && fnStr != '') {
                var sprange = fnStr.split(that.$opts.range), inArr = [];
                jet.each(sprange, function (i, sval) {
                    var reVal = jet.reMatch(sval), inObj = {};
                    jet.each(jet.reMatch(matStr), function (r, val) {
                        inObj[val] = reVal[r];
                    });
                    inArr.push(inObj);
                });
                strVal = inArr;
            } else {
                strVal = fnStr;
            }
            var vals = that.parseValue(strVal, matStr);
            if (bool != false) jet.valText(valCell, vals);
            return vals;
        },
        getValue: function (valobj) {
            var that = this, valCell = that.valCell,
                opts = that.$opts, reObj, result = new DateTime().reDate(),
                dateY = result.GetYear(), dateM = result.GetMonth(), dateD = result.GetDate(),
                timeh = result.GetHours(), timem = result.GetMinutes(), times = result.GetSeconds();
            if (valobj == undefined && jet.isBool(opts.isShow)) {
                reObj = jet.valText(valCell);
            } else {
                var isValShow = jet.isBool(opts.isShow) ? (jet.valText(valCell) == "") : !jet.isBool(opts.isShow),
                    objarr = jet.extend({ YYYY: null, MM: null, DD: null }, valobj || {}),
                    ranMat = [], newArr = new Array(2), unObj = function (obj) {
                        return [(objarr[obj] == undefined || objarr[obj] == null), objarr[obj]];
                    }, defObj = [{ YYYY: dateY, MM: dateM, DD: dateD, hh: timeh, mm: timem, ss: times, zz: '' },
                    { YYYY: dateY, MM: dateM, DD: dateD, hh: timeh, mm: timem, ss: times, zz: '' }];
                if (isValShow) {
                    jet.each(newArr, function (i) {
                        var inObj = {};
                        jet.each(ymdzArr, function (r, val) {
                            inObj[val] = parseInt(unObj(val)[0] ? defObj[i][val] : unObj(val)[1]);
                        });
                        ranMat.push(jet.extend(defObj[i], inObj));
                    });
                } else {
                    var isunRange = opts.range != false, initVal = that.getValue(),
                        spVal = initVal.split(opts.range), reMat = jet.reMatch(that.format);
                    jet.each(newArr, function (i) {
                        var inObj = {}, reVal = isunRange ? jet.reMatch(spVal[i]) : jet.reMatch(initVal);
                        jet.each(reMat, function (r, val) {
                            inObj[val] = reVal[r];
                        });
                        var exVal = jet.extend(inObj, valobj || {});
                        ranMat.push(jet.extend(defObj[i], exVal));
                    });
                }
                reObj = ranMat;
            }
            return reObj;
        },
        storeData: function (curr, next) {
            next = next || {};
            var that = this, opts = that.$opts, multi = opts.multiPane, valCell = that.valCell,
                days = new Date().getDate(), isnext = jet.isObj(next),
                RES = { yearlist: [], monthlist: [[], []], daylist: [], daytit: [], timelist: [] }, seltime,
                cday = curr.DD == null ? days : curr.DD, nday = next.DD == null ? days : next.DD,
                timeA = { hh: curr.hh, mm: curr.mm, ss: curr.ss }, timeB = { hh: next.hh || 0, mm: next.mm || 0, ss: next.ss || 0 };
            RES.yearlist.push(that.eachYear(parseInt(curr.YYYY), 1));
            if (multi == false) {
                var yearNext = isnext ? next.YYYY : curr.YYYY;
                RES.yearlist.push(that.eachYear(parseInt(yearNext), 2));
            }
            RES.monthlist[0] = that.eachMonth(curr.YYYY, 0);
            if (multi == false) {
                RES.monthlist[1] = that.eachMonth(curr.YYYY + 1, 1);
            }
            RES.daylist.push(that.eachDays(curr.YYYY, curr.MM, cday, 0));
            RES.daytit.push({ YYYY: curr.YYYY, MM: curr.MM });
            if (multi == false) {
                var dayNext = jet.nextMonth(curr.YYYY, curr.MM);
                RES.daylist.push(that.eachDays(dayNext.y, dayNext.m, nday, 1));
                RES.daytit.push({ YYYY: dayNext.y, MM: dayNext.m });
            }
            that.selectTime = [timeA, timeB];
            RES.timelist.push(that.eachTime(timeA, 1));
            if (multi == false) {
                seltime = that.dlen == 7 && opts.range && !isnext ? timeA : timeB;
                if (that.dlen == 7 && opts.range && jet.valText(valCell) == "") {
                    that.selectTime[1] = jet.extend(timeB, timeA);
                }
                RES.timelist.push(that.eachTime(seltime, 2));
            }
            jet.extend(that.$data, RES);
        },
        dateTemplate: function () {
            var that = this, opts = that.$opts, multi = opts.multiPane, YMDStr = "", hmsStr = "", lang = opts.language,
                ytxt = lang.name == "cn" ? "年" : "", mtxt = lang.name == "cn" ? "月" : "";
            var aowArr = (function () {
                var butArr = [], ismu = multi ? "11" : "23";
                if (that.dlen == 1) {
                    butArr = ['{%=yearlist[i][0].y-' + ismu + '%}', '{%=yearlist[i][yearlist[i].length-1].y%}'];
                } else if (that.dlen == 2) {
                    butArr = multi ? ['{%=yearlist[0][0].y-1%}', '{%=yearlist[0][0].y+1%}'] : ['{%=yearlist[i][0].y-' + ismu + '%}', '{%=yearlist[i][yearlist[i].length-1].y%}'];
                } else if (that.dlen > 2 && that.dlen <= 6) {
                    butArr = ['{%=yearlist[0][0].y-1%}', '{%=yearlist[0][0].y+1%}'];
                }
                return butArr;
            })();
            var lyPrev = '<a href="###" class="ax-yprev ax-iconfont ax-icon-left-double" @on="yearBtn(lprev,' + aowArr[0] + ')"></a>',
                ryNext = '<a href="###" class="ax-ynext ax-iconfont ax-icon-right-double" @on="yearBtn(rnext,' + aowArr[1] + ')"></a>',
                mPrev = '{% if(dlen>2){ %}<a href="###" class="ax-mprev ax-iconfont ax-icon-left" @on="monthBtn(mprev,{%=daytit[i].YYYY%}-{%=daytit[i].MM%})"></a>{% } %}',
                mNext = '{% if(dlen>2){ %}<a href="###" class="ax-mnext ax-iconfont ax-icon-right" @on="monthBtn(mnext,{%=daytit[i].YYYY%}-{%=daytit[i].MM%})"></a>{% } %}';
            var yaerHtml = '<table class="ax-ytable year{%= i==0 ? "left":"right"%}" style="display:{%=year ? "table":"none"%};"><tbody><tr>' +
                '{% for(var y=0;y<=11;y++){ %}<td class="{%=yearlist[i][y].style%}" @on="yearClick({%=yearlist[i][y].y%})"><span>{%=yearlist[i][y].y%}' + ytxt + '</span></td>{% if((y+1)%3==0){ %} </tr>{% } %} {% } %} </tbody></table>';
            var monthHtml = '<table class="ax-mtable month{%= i==0 ? "left":"right"%}" style="display:{%=month ? "table":"none"%};"><tbody><tr>' +
                '{% for(var m=0;m<=11;m++){ %}<td class="{%=monthlist[i][m].style%}" ym="{%=monthlist[i][m].y%}-{%=monthlist[i][m].m%}" @on="monthClick({%=monthlist[i][m].y%}-{%=monthlist[i][m].m%})"><span>{%=monthlist[i][m].m%}' + mtxt + '</span></td>{% if((m+1)%3==0){ %} </tr>{% } %} {% } %} </tbody></table>';
            var daysHtml = '<table class="ax-dtable days{%= i==0 ? "left":"right"%}" style="display:{%=day ? "table":"none"%};"><thead><tr>' +
                '{% for(var w=0;w<lang.weeks.length;w++){ %} <th><i>{%=lang.weeks[w]%}</i></th> {% } %}</tr></thead><tbody>' +
                '<tr>{% for(var d=0;d<=41;d++){ %}<td class="{%=daylist[i][d].style%}" ymd="{%=daylist[i][d].ymd%}" @on="daysClick({%=daylist[i][d].ymd%})">{%=daylist[i][d].day%}</td>{% if((d+1)%7==0){ %} </tr>{% } %} {% } %} </tbody></table>';
            var hmsHtml = '<div class="ax-date-time">{% for(var h=0;h<timelist.length;h++){ %}<div class="ax-date-panel"><div class="ax-date-header">{%= timelist.length == 1 ? lang.timetxt[0]:lang.timetxt[h+1]%}</div><div class="ax-date-body">' +
                '<div class="ax-time-title"><div class="ax-time-item">{%=lang.times[0]%}</div><div class="ax-time-item">{%=lang.times[1]%}</div><div class="ax-time-item">{%=lang.times[2]%}</div></div>' +
                '<div class="ax-time-list">{% for(var t=0;t<3;t++){ %}<div class="ax-time-item"><ul>{% for(var s=0;s<timelist[h][t].length;s++){ %}<li class="{%=timelist[h][t][s].style%}" @on="hmsClick({%= h %},{%= h>0?3+t:t %})"><span>{%= timelist[h][t][s].hms < 10 ? "0" + timelist[h][t][s].hms :timelist[h][t][s].hms %}</span></li>{% } %}</ul></div>{% } %}</div></div>' + '</div>{% } %}</div>';
            var shortHtml = opts.shortcut.length > 0 ? "{% for(var s=0;s<shortcut.length;s++){ %}<a href='###' @on=shortClick({%= shortcut[s].val %})>{%=shortcut[s].name%}</a>{% } %}" : '';
            var ymtitHtml = (function () {
                var ymtitStr = "";
                if (that.dlen == 1) {
                    ymtitStr = '<a href="###" class="ax-ym">{%=yearlist[i][0].y%}' + ytxt + ' ~ {%=yearlist[i][yearlist[i].length-1].y%}' + ytxt + '</a>';
                } else if (that.dlen == 2) {
                    ymtitStr = '<a href="###" class="ax-ym" @on="yearShow({%=yearlist[0][i].y%})">{%=yearlist[0][i].y%}' + ytxt + '</a>';
                } else if (that.dlen > 2 && that.dlen <= 6) {
                    ymtitStr = '<a href="###" class="ax-ym" @on="monthShow({%=daytit[i].MM%})">{%=daytit[i].MM%}' + mtxt + '</a>' +
                        '<a href="###" class="ax-ym" @on="yearShow({%=daytit[i].YYYY%})">{%=daytit[i].YYYY%}' + ytxt + '</a>';
                }
                return ymtitStr;
            })();
            var ymButton = (function () {
                var titStrBut = "";
                if (that.dlen == 1) {
                    titStrBut = multi ? [lyPrev + ryNext] : [lyPrev, ryNext];
                } else if (that.dlen == 2) {
                    titStrBut = multi ? [lyPrev + ryNext] : [lyPrev, ryNext];
                } else if (that.dlen > 2 && that.dlen <= 6) {
                    titStrBut = multi ? [lyPrev + mPrev + mNext + ryNext] : [lyPrev + mPrev, mNext + ryNext];
                } else if (that.dlen == 7) {
                    titStrBut = "";
                }
                return titStrBut;
            })();
            if (that.dlen == 1) {
                YMDStr = yaerHtml;
            } else if (that.dlen == 2) {
                YMDStr = yaerHtml + monthHtml;
            } else if (that.dlen == 3) {
                YMDStr = yaerHtml + monthHtml + daysHtml;
            } else if (that.dlen > 3 && that.dlen <= 6) {
                YMDStr = yaerHtml + monthHtml + daysHtml;
                hmsStr = hmsHtml;
            } else if (that.dlen == 7) {
                hmsStr = hmsHtml;
            }
            var paneHtml = '{% for(var i=0;i<pane;i++){ %}<div class="ax-date-panel">' +
                '<div class="ax-date-header">{% if(i==0){ %}' + ymButton[0] + '{% }else{ %}' + ymButton[1] + '{% } %}' + ymtitHtml + '</div>' +
                '<div class="ax-date-body{%= i==1?" bordge":"" %}">' + YMDStr + '</div>' +
                '</div>{% } %}';
            opts.mode == 'inline' ? (opts.isClose = false, that.dateCell.setAttribute('data-mode', 'inline')) : null;
            let closeBtn = '';
            if (!opts.isShow || opts.mode == 'inline') {
                opts.isClose = false;
            }
            if (opts.isClear) {
                closeBtn = '<a href="###" class="ax-btn ax-text clear" @on="clearBtn">' + opts.language.clear + '</a>';
            } else if (opts.isClose) {
                closeBtn = '<a href="###" class="ax-btn ax-text clear" @on="closeBtn">' + opts.language.close + '</a>';
            } else {
                closeBtn = '';
            }
            if (opts.multiPane) {
                var btnStr = '<div class="ax-date-footer" line>{% if(timebtn){%}<a href="###" class="ax-btn ax-text timecon" @on="timeBtn">{%=lang.timetxt[0]%}</a>{% } %}' + closeBtn + '{% if(today){ %}<a href="###" class="ax-btn ax-text today" @on="nowBtn">{%=lang.today%}</a>{% } %}{% if(yes){ %}<a href="###" class="ax-btn ax-text setok" @on="sureBtn">{%=lang.yes%}</a>{% } %}</div></div>';
            } else {
                var btnStr = '<div class="ax-date-footer"><div class="ax-footer-left">{% if(timebtn){%}<a href="###" class="ax-btn ax-text timecon" @on="timeBtn">{%=lang.timetxt[0]%}</a>{% } %}</div><div class="ax-footer-right">' + closeBtn + '{% if(today){ %}<a href="###" class="ax-btn ax-text today" @on="nowBtn">{%=lang.today%}</a>{% } %}{% if(yes){ %}<a href="###" class="ax-btn setok" @on="sureBtn">{%=lang.yes%}</a>{% } %}</div></div>';
            }
            return '<div class="ax-date-main"><div class="ax-date-ymd">' + paneHtml + '</div>' + hmsStr + btnStr + '</div>';    
        },
        compileBindNode: function (dom) {
            var self = this, aton = "@on";
            var acquireAttr = function (atVal) {
                var args = /\(.*\)/.exec(atVal);
                if (args) { 
                    args = args[0];
                    atVal = atVal.replace(args, "");
                    args = args.replace(/[\(\)\'\"]/g, '').split(",");
                } else args = [];
                return [atVal, args];
            };
            jet.each(dom.childNodes, function (i, node) {
                if (node.nodeType === 1) {
                    if (!self.$opts.festival) node.removeAttribute("ymd");
                    self.compileBindNode(node);
                    var geton = node.getAttribute(aton);
                    if (geton != null) {
                        var onarr = acquireAttr(geton);
                        jet.on(node, "click", function () {
                            self[onarr[0]] && self[onarr[0]].apply(node, onarr[1]);
                        });
                        node.removeAttribute(aton);
                    }
                }
            });
        },
        methodEventBind: function () {
            var that = this, opts = that.$opts, multi = opts.multiPane, DTS = that.$data,
                result = new DateTime().reDate(), dateY = result.GetYear(), dateM = result.GetMonth(), dateD = result.GetDate(),
                range = opts.range, elCell = that.dateCell;
            jet.extend(that, {
                yearBtn: function (type, val) {
                    var yarr = val.split("#"), pval = jet.reMatch(yarr[0]), tmval = that.selectTime;
                    exarr = [jet.extend({ YYYY: parseInt(val), MM: dateM, DD: dateD }, tmval[0]), {}];
                    var dateVal = that.parseValue([exarr[0]], that.format);
                    that.storeData(exarr[0], exarr[1]);
                    that.renderDate();
                    opts.toggle && opts.toggle({ elem: that.valCell, val: dateVal, date: exarr[0] });
                },
                yearShow: function (val) {
                    DTS.year = true;
                    DTS.month = false;
                    if (that.dlen > 2 && that.dlen <= 6) {
                        DTS.day = false;
                    }
                    that.renderDate();
                },
                monthBtn: function (type, val) {
                    var ymarr = jet.reMatch(val), tmval = that.selectTime, exarr = [], PrevYM, NextYM,
                        year = parseInt(ymarr[0]), month = parseInt(ymarr[1]);
                    if (range) {
                        if (type == "mprev") {
                            PrevYM = jet.prevMonth(year, month);
                            NextYM = jet.nextMonth(PrevYM.y, PrevYM.m);
                        } else {
                            NextYM = jet.nextMonth(year, month);
                            PrevYM = jet.prevMonth(NextYM.y, NextYM.m);
                        }
                        exarr = [jet.extend({ YYYY: PrevYM.y, MM: PrevYM.m, DD: dateD }, tmval[0]), { YYYY: NextYM.y, MM: NextYM.m, DD: dateD }];
                    } else {
                        var PNYM = (type == "mprev") ? jet.prevMonth(year, month) : jet.nextMonth(year, month);
                        exarr = [jet.extend({ YYYY: PNYM.y, MM: PNYM.m, DD: dateD }, tmval[0]), {}];
                    }
                    var dateVal = that.parseValue([exarr[0]], that.format);
                    that.storeData(exarr[0], exarr[1]);
                    that.renderDate();
                    opts.toggle && opts.toggle({ elem: that.valCell, val: dateVal, date: exarr[0] });
                },
                monthShow: function (val) {
                    DTS.year = false;
                    DTS.month = true;
                    if (that.dlen > 2 && that.dlen <= 6) {
                        DTS.day = false;
                    }
                    that.renderDate();
                },
                shortClick: function (val) {
                    var reval = val.replace(/\#/g, ','), evobj = eval("(" + reval + ")"),
                        gval = jet.getDateTime(evobj), tmval = that.selectTime;
                    that.selectValue = [jet.parse(gval, "YYYY-MM-DD")];
                    that.selectDate = [{ YYYY: gval.YYYY, MM: gval.MM, DD: gval.DD }];
                    that.selectTime = [{ hh: gval.hh, mm: gval.mm, ss: gval.ss }]
                    tmval = that.selectTime;
                    if (opts.onClose) {
                        var nYM = jet.nextMonth(gval.YYYY, gval.MM),
                            ymarr = [{ YYYY: gval.YYYY, MM: gval.MM, DD: gval.DD }, { YYYY: nYM.y, MM: nYM.m, DD: null }];
                        that.storeData(jet.extend(ymarr[0], tmval[0]), jet.extend(ymarr[1], tmval[1]));
                        that.renderDate();
                    } else {
                        that.setValue(gval, that.format);
                        that.closeDate();
                    }
                    that.lastClick = 'panel';
                },
                yearClick: function (val) {
                    if (jet.hasClass(this, "ax-disabled")) return;
                    var yearVal = "", lens = that.dlen;
                    if (range && lens == 1) {
                        var ylen = that.selectValue.length;
                        that.selectDate = (ylen == 2) ? [{ YYYY: parseInt(val), MM: dateM }] :
                            [{ YYYY: that.selectDate[0].YYYY, MM: that.selectDate[0].MM }, { YYYY: parseInt(val), MM: dateM }];
                        that.selectValue = (ylen == 2) ? [val + "-" + jet.digit(dateM)] : [that.selectValue[0], val + "-" + jet.digit(dateM)];
                        if (that.selectValue.length == 2) {
                            var svalarr = [that.selectValue[0], that.selectValue[1]], newArr = [{}, {}];
                            svalarr.sort(function (a, b) { return a > b ? 1 : -1; });
                            that.selectValue = svalarr;
                            jet.each(svalarr, function (i, strval) {
                                jet.each(jet.reMatch(strval), function (s, dval) {
                                    newArr[i][ymdzArr[s]] = dval;
                                });
                            });
                            that.selectDate = newArr;
                        }
                    } else if (lens > 1 && lens <= 6) {
                        yearVal = parseInt(val);
                    } else {
                        that.selectValue = [val + "-" + jet.digit(dateM)];
                        that.selectDate = [{ YYYY: parseInt(val), MM: dateM }];
                    }
                    DTS.year = (lens == 1) ? true : false;
                    DTS.month = (lens < 3) ? true : false;
                    DTS.day = (lens > 2 && lens <= 6) ? true : false;
                    var electVal = (lens > 1 && lens <= 6) ? yearVal : parseInt(that.selectDate[0].YYYY);
                    that.storeData(jet.extend({ YYYY: electVal, MM: dateM, DD: dateD }, that.selectTime[0]), {});
                    that.renderDate();
                    that.lastClick = 'panel';
                },
                monthClick: function (val) {
                    if (jet.hasClass(this, "ax-disabled")) return;
                    var ymval = jet.reMatch(val), newArr = [{}, {}], mlen = that.selectValue.length;
                    if (range) {
                        that.selectDate = (mlen == 2) ? [{ YYYY: ymval[0], MM: ymval[1] }] :
                            [{ YYYY: that.selectDate[0].YYYY, MM: that.selectDate[0].MM }, { YYYY: parseInt(val), MM: ymval[1] }];
                        that.selectValue = (mlen == 2) ? [val] : [that.selectValue[0], val];
                        if (that.selectValue.length == 2) {
                            var svalarr = [that.selectValue[0], that.selectValue[1]];
                            svalarr.sort(function (a, b) { return a > b ? 1 : -1; });
                            that.selectValue = svalarr;
                            jet.each(svalarr, function (i, strval) {
                                jet.each(jet.reMatch(strval), function (s, dval) {
                                    newArr[i][ymdzArr[s]] = dval;
                                });
                            });
                            that.selectDate = newArr;
                        }
                    } else {
                        that.selectValue = [val];
                        that.selectDate = [{ YYYY: ymval[0], MM: ymval[1] }];
                    }
                    if (that.dlen > 2) {
                        DTS.year = false;
                        DTS.month = false;
                    }
                    DTS.day = (that.dlen > 2 && that.dlen <= 6) ? true : false;
                    that.storeData(jet.extend({
                        YYYY: parseInt(that.selectDate[0].YYYY),
                        MM: parseInt(that.selectDate[0].MM),
                        DD: dateD
                    }, that.selectTime[0]), {});
                    that.renderDate();
                    that.lastClick = 'panel';
                },
                daysClick: function (val) {
                    if (jet.hasClass(this, "ax-disabled")) return;
                    var tmval = that.selectTime, matVal = jet.reMatch(val),
                        slen = that.selectValue.length, dateVal = "",
                        newArr = [{}, {}], nYM, ymarr;
                    if (range) {
                        if (slen == 1) {
                            var svalarr = [that.selectValue[0], val];
                            svalarr.sort(function (a, b) { return a > b ? 1 : -1; });
                            that.selectValue = svalarr;
                            jet.each(svalarr, function (i, strval) {
                                jet.each(jet.reMatch(strval), function (s, dval) {
                                    newArr[i][ymdzArr[s]] = dval;
                                });
                            });
                            that.selectDate = newArr;
                        } else {
                            that.selectValue = [val];
                            newArr = [{ YYYY: matVal[0], MM: matVal[1], DD: matVal[2] }];
                            that.selectDate = [{ YYYY: matVal[0], MM: matVal[1], DD: matVal[2] }, {}];
                        }
                        nYM = jet.nextMonth(newArr[0].YYYY, newArr[0].MM);
                        ymarr = [{ YYYY: newArr[0].YYYY, MM: newArr[0].MM, DD: newArr[0].DD }, { YYYY: nYM.y, MM: nYM.m, DD: null }];
                        that.storeData(jet.extend(ymarr[0], tmval[0]), jet.extend(ymarr[1], tmval[1]));
                        that.renderDate();
                    } else {
                        that.selectValue = [val];
                        that.selectDate = [{ YYYY: matVal[0], MM: matVal[1], DD: matVal[2] }, { YYYY: matVal[0], MM: matVal[1], DD: matVal[2] }];
                        jet.each(new Array(range == false ? 1 : 2), function (a) {
                            jet.each(matVal, function (i, val) {
                                newArr[a][ymdzArr[i]] = val;
                            });
                            jet.extend(newArr[a], tmval[a]);
                        });
                        if (opts.onClose) {
                            that.storeData(jet.extend(newArr[0], tmval[0]), jet.extend(newArr[1], tmval[1]));
                            that.renderDate();
                        } else {
                            dateVal = that.setValue(newArr, that.format);
                            that.closeDate();
                            opts.donefun && opts.donefun.call(that, { elem: that.valCell, val: dateVal, date: newArr });
                        }
                    }
                    that.lastClick = 'panel';
                },
                hmsClick: function (idx, num) {
                    var pidx = parseInt(num), vals = parseInt(jet.text(this)),
                        paridx = parseInt(idx), act = "ax-selected", mhms = ["hh", "mm", "ss"],
                        ulCell = $Q(".ax-date-time", that.dateCell).querySelectorAll("ul")[pidx],
                        tlen = that.$data.timelist[0].length;
                    if (jet.hasClass(this, "ax-disabled")) return;
                    jet.each(ulCell.childNodes, function (i, node) {
                        var reg = new RegExp("(^|\\s+)" + act + "(\\s+|$)", "g");
                        node.className = reg.test(node.className) ? node.className.replace(reg, '') : node.className;
                    });
                    that.selectTime[paridx][paridx == 1 ? mhms[pidx - tlen] : mhms[pidx]] = vals;
                    this.className = this.className + act;
                    if (that.dlen == 7 && idx == 0 && range && !multi) {
                        var nVal = that.getValue({}), nYM = jet.nextMonth(nVal[0].YYYY, nVal[0].MM), st = that.selectTime;
                        that.storeData(
                            { YYYY: nVal[0].YYYY, MM: nVal[0].MM, DD: null, hh: st[0].hh, mm: st[0].mm, ss: st[0].ss },
                            { YYYY: nYM.y, MM: nYM.m, DD: null, hh: st[1].hh, mm: st[1].mm, ss: st[1].ss }
                        );
                        that.renderDate();
                    }
                    that.lastClick = 'panel';
                },
                timeBtn: function () {
                    var timeCell = $Q(".ax-date-time", elCell), disNo = timeCell.style.display == "none";
                    jet.text(this, disNo ? opts.language.backtxt : opts.language.timetxt[0]);
                    jet.setCss(timeCell, { display: disNo ? "" : "none" });
                    that.lastClick = 'panel';
                    timeCell.querySelectorAll('ul').forEach(item =>{
                        axPreventScroll(item);
                    });
                },
                clearBtn: function () {
                    jet.valText(that.valCell, "");
                    that.selectDate = [jet.parse(jet.getDateTime({}), "YYYY-MM-DD hh:mm:ss")];
                    if (opts.isShow) {
                        that.closeDate();
                    }
                    opts.clearfun && opts.clearfun.call(that);
                },
                closeBtn: function () {
                    if (opts.isShow) {
                        that.closeDate();
                    }
                    opts.closefun && opts.closefun.call(that);
                },
                nowBtn: function () {
                    var newArr = jet.getDateTime({}), nYM = jet.nextMonth(newArr.YYYY, newArr.MM), dateVal;
                    that.selectDate = [newArr];
                    that.storeData(newArr, { YYYY: nYM.y, MM: nYM.m, DD: null, hh: 0, mm: 0, ss: 0 });
                    that.renderDate();
                    if (opts.nowClose) {
                        dateVal = opts.isShow ? that.setValue([newArr], that.format, true) : jet.parse(newArr, that.format);
                        that.closeDate();
                    } else {
                        if (opts.mode == 'inline') {
                            that.setValue([newArr], that.format, true);
                        }
                    }
                    that.nowVal = that.selectDate;
                    that.lastClick = 'now';
                    /*  if (opts.onClose && range || !opts.isShow) {
                         that.storeData(newArr, { YYYY: nYM.y, MM: nYM.m, DD: null, hh: 0, mm: 0, ss: 0 });
                         that.renderDate();
                     } else {
                         that.storeData(newArr, { YYYY: nYM.y, MM: nYM.m, DD: null, hh: 0, mm: 0, ss: 0 });
                         that.renderDate();
                     } */
                    /*if (opts.onClose && range || !opts.isShow) {
                     that.storeData(newArr, { YYYY: nYM.y, MM: nYM.m, DD: null, hh: 0, mm: 0, ss: 0 });
                    that.renderDate(); 
                     } else {
                    that.closeDate();
                    }*/
                    opts.donefun && opts.donefun.call(that, { elem: that.valCell, val: dateVal, date: newArr });
                },
                sureBtn: function () {
                    var newArr = that.selectValue.length > 1 ? [{}, {}] : [{}], dateVal = "", tmval = that.selectTime;
                    var equal = function (o) {
                        var h = o.hh == undefined ? 0 : o.hh, m = o.mm == undefined ? 0 : o.mm, s = o.ss == undefined ? 0 : o.ss;
                        return parseInt(jet.digit(h) + "" + jet.digit(m) + "" + jet.digit(s));
                    };
                    if (range) {
                        if (that.selectValue.length > 1) {
                            var sortarr = that.selectValue;
                            sortarr.sort(function (a, b) { return a > b ? 1 : -1; });
                            jet.each(sortarr, function (i, arr) {
                                jet.each(jet.reMatch(arr), function (a, val) {
                                    newArr[i][ymdzArr[a]] = val;
                                });
                                jet.extend(newArr[i], tmval[i]);
                            });
                        } else if (that.dlen == 7 && tmval.length > 1) {
                            newArr = tmval;
                        }
                        var sameTime = equal(tmval[0]) >= equal(tmval[1]), selVal = that.selectValue, sameDate = "";
                        if (selVal[1] != undefined) sameDate = selVal[0].replace(/\-/g, "") == selVal[1].replace(/\-/g, "");
                        if (selVal.length == 1 && that.dlen < 7) {
                            that.tips(opts.language.name == "cn" ? "未选结束日期" : "Please select the end date"); return;
                        } else if ((that.dlen == 7 && sameTime) || (sameDate && sameTime)) {
                            that.tips(opts.language.name == "cn" ? "结束时间必须大于开始时间" : "The end time must be greater than the start time"); return;
                        }
                    } else {
                        jet.each(new Array(range == false ? 1 : 2), function (i) {
                            if (that.dlen != 7) jet.each(jet.reMatch(that.selectValue[0]), function (a, val) {
                                newArr[i][ymdzArr[a]] = val;
                            });
                            jet.extend(newArr[i], tmval[i]);
                        });
                    }
                    if (that.lastClick == 'now') {
                        dateVal = that.setValue(that.nowVal, that.format, opts.isShow ? true : false);
                    } else {
                        dateVal = that.setValue(newArr, that.format, opts.isShow ? true : false);
                    }
                    that.closeDate();
                    opts.donefun && opts.donefun.call(that, { elem: that.valCell, val: dateVal, date: newArr });
                },
                blankArea: function () {
                    /* jet.on(document, "mouseup", function (ev) {
                        jet.stopPropagation(ev);
                        opts.mode !== 'inline' && that.closeDate();
                    });
                    jet.on($Q(elx), "mouseup", function (ev) {
                        jet.stopPropagation(ev);
                    }); */
                }
            });
        },
        eachYear: function (val, type) {
            var that = this, opts = that.$opts, yNum = parseInt(val), yarr = [], seCls = '', selYear = that.selectDate, i,
                mins = jet.reMatch(that.minDate), maxs = jet.reMatch(that.maxDate);
            i = type == 1 ? yNum : that.yindex;
            that.yindex = type == 1 ? 12 + yNum : 12 + that.yindex;
            var endDate = selYear[1] == undefined ? "" : selYear[1].YYYY;
            for (; i < that.yindex; i++) {
                if (opts.range && i == selYear[0].YYYY) {
                    seCls = "ax-selected ax-start";
                } else if (opts.range && i == endDate) {
                    seCls = "ax-selected ax-end";
                } else if (i == selYear[0].YYYY || i == endDate) {
                    seCls = "ax-selected";
                } else if (i > selYear[0].YYYY && i < endDate) {
                    seCls = "ax-contain";
                } else if (i < mins[0] || i > maxs[0]) {
                    seCls = "ax-disabled";
                } else {
                    seCls = "";
                }
                yarr.push({ style: seCls, y: i });
            }
            return yarr;
        },
        eachMonth: function (val, type) {
            var that = this, opts = that.$opts, marr = [],
                selMonth = that.selectDate, seCls = '', monthArr = opts.language.month,
                mins = jet.reMatch(that.minDate), maxs = jet.reMatch(that.maxDate),
                minym = parseInt(mins[0] + "" + jet.digit(mins[1])),
                maxym = parseInt(maxs[0] + "" + jet.digit(maxs[1])),
                currStart = parseInt(selMonth[0].YYYY + "" + jet.digit(selMonth[0].MM)),
                currEnd = selMonth[1] ? parseInt(selMonth[1].YYYY + "" + jet.digit(selMonth[1].MM)) : 0;
            jet.each(monthArr, function (i, months) {
                var ival = parseInt(val + "" + jet.digit(months));
                if (opts.range && ival == currStart) {
                    seCls = "ax-selected ax-start";
                } else if (opts.range && ival == currEnd) {
                    seCls = "ax-selected ax-end";
                } else if (ival == currStart || ival == currEnd) {
                    seCls = "ax-selected";
                } else if (ival > currStart && ival < currEnd) {
                    seCls = "ax-contain";
                } else if (ival < minym || ival > maxym) {
                    seCls = "ax-disabled";
                } else {
                    seCls = "";
                }
                marr.push({ style: seCls, y: val, m: months });
            });
            return marr;
        },
        eachDays: function (yd, md, ds, idx) {
            var that = this, count = 0, daysArr = [], opts = that.$opts,
                firstWeek = new Date(yd, md - 1, 1).getDay() || 7,
                daysNum = jet.getDaysNum(yd, md), sDate = that.selectDate,
                prevM = jet.prevMonth(yd, md),
                prevDaysNum = jet.getDaysNum(yd, prevM.m), nextM = jet.nextMonth(yd, md),
                lang = opts.language, endval = opts.valiDate || [],
                minArr = jet.reMatch(that.minDate), minNum = parseInt(minArr[0] + "" + jet.digit(minArr[1]) + "" + jet.digit(minArr[2])),
                maxArr = jet.reMatch(that.maxDate), maxNum = parseInt(maxArr[0] + "" + jet.digit(maxArr[1]) + "" + jet.digit(maxArr[2]));
            var startDate = sDate[0] ? parseInt(sDate[0].YYYY + "" + jet.digit(sDate[0].MM) + "" + jet.digit(sDate[0].DD)) : "";
            var endDate = sDate[1] ? parseInt(sDate[1].YYYY + "" + jet.digit(sDate[1].MM) + "" + jet.digit(sDate[1].DD)) : "";
            var setMark = function (my, mm, md) {
                var Marks = opts.marks, contains = function (arr, obj) {
                    var clen = arr.length;
                    while (clen--) { if (arr[clen] === obj) return true; }
                    return false;
                }, isArr = jet.isType(Marks, "array");
                return isArr && Marks.length > 0 && contains(Marks, my + "-" + jet.digit(mm) + "-" + jet.digit(md)) ? '<i class="marks"></i>' : "";
            };
            var isfestival = function (y, m, d) {
                var festivalStr = '';
                if (opts.festival == true && lang.name == "cn") {
                    var lunar = jeLunar(y, m - 1, d), feslunar = (lunar.solarFestival || lunar.lunarFestival),
                        lunartext = (feslunar && lunar.jieqi) != "" ? feslunar : (lunar.jieqi || lunar.showInLunar);
                    festivalStr = '<div class="ax-with-lunar"><div class="ax-solar">' + d + '</div><div class="ax-lunar">' + lunartext + '</div></div>';
                } else {
                    festivalStr = '<span class="ax-unit">' + d + '</span>';
                }
                return festivalStr;
            };
            var dateLimit = function (Y, M, D, isMonth) {
                var thatNum = parseInt(Y + "" + jet.digit(M) + "" + jet.digit(D));
                if (isMonth) {
                    if (thatNum >= minNum && thatNum <= maxNum) return true;
                } else {
                    if (minNum > thatNum || maxNum < thatNum) return true;
                }
            };
            var regExpDate = function (date, cls) {
                var inArray = function (search, array) {
                    for (var i in array) if (array[i] == search) return true;
                    return false;
                };
                if (endval.length > 0 && endval[0] != "") {
                    if (/\%/g.test(endval[0])) {
                        var reval = endval[0].replace(/\%/g, "").split(","), enArr = [];
                        jet.each(reval, function (r, rel) {
                            enArr.push(jet.digit(parseInt(rel)));
                        });
                        var isfind = inArray(jet.digit(date), enArr) == false;
                        cls = jet.isBool(endval[1]) ? (isfind ? " ax-disabled" : cls) : (isfind ? cls : " ax-disabled");
                    } else {
                        var valreg = that.dateRegExp(endval[0]), regday = valreg.test(jet.digit(date));
                        cls = jet.isBool(endval[1]) ? (regday ? " ax-disabled" : cls) : (regday ? cls : " ax-disabled");
                    }
                }
                return cls;
            };
            for (var p = prevDaysNum - firstWeek + 1; p <= prevDaysNum; p++, count++) {
                var pmark = setMark(prevM.y, prevM.m, p), pcls = dateLimit(prevM.y, prevM.m, p, false) ? "ax-disabled" : "ax-other";
                pcls = regExpDate(p, pcls);
                daysArr.push({ style: pcls, ymd: prevM.y + '-' + jet.digit(prevM.m) + '-' + jet.digit(p), day: (isfestival(prevM.y, prevM.m, p) + pmark) });
            }
            for (var b = 1; b <= daysNum; b++, count++) {
                var bmark = setMark(yd, md, b), bcls = "";
                var dateval = parseInt(yd + "" + jet.digit(md) + "" + jet.digit(b)),
                    parsdate = dateval > startDate, rangdate = dateval < endDate;
                if (dateLimit(yd, md, b, true)) {
                    if (opts.range && dateval == startDate) {
                        bcls = " ax-selected ax-start";
                    } else if (opts.range && dateval == endDate) {
                        bcls = " ax-selected ax-end";
                    } else if (dateval == startDate || dateval == endDate) {
                        bcls = " ax-selected";
                    } else if (parsdate && rangdate) {
                        bcls = " ax-contain";
                    } else {
                        bcls = "";
                    }
                } else {
                    bcls = " ax-disabled";
                }
                bcls = regExpDate(b, bcls);
                daysArr.push({ style: "ax-current" + bcls, ymd: yd + '-' + jet.digit(md) + '-' + jet.digit(b), day: (isfestival(yd, md, b) + bmark) });
            }
            for (var n = 1, nlen = 42 - count; n <= nlen; n++) {
                var nmark = setMark(nextM.y, nextM.m, n);
                var ncls = dateLimit(nextM.y, nextM.m, n, false) ? "ax-disabled" : "ax-other";
                ncls = regExpDate(n, ncls);
                daysArr.push({ style: ncls, ymd: nextM.y + '-' + jet.digit(nextM.m) + '-' + jet.digit(n), day: (isfestival(nextM.y, nextM.m, n) + nmark) });
            }
            return daysArr;
        },
        eachTime: function (hmsArr, type) {
            var that = this, opts = that.$opts, range = opts.range, multi = opts.multiPane, minVal = [], maxVal = [],
                mhms = ["hh", "mm", "ss"], timeArr = [], hmsCls = '', format = that.format,
                ntVal = jet.trim(that.minDate).replace(/\s+/g, " "),
                xtVal = jet.trim(that.maxDate).replace(/\s+/g, " "),
                nVal = ntVal.split(" "), xVal = xtVal.split(" ");
            if (that.dlen > 3 && /\:/.test(nVal) && /\:/.test(xVal)) {
                minVal = jet.reMatch(/\s/.test(ntVal) && that.dlen > 3 ? nVal[1] : ntVal);
                maxVal = jet.reMatch(/\s/.test(xtVal) && that.dlen > 3 ? xVal[1] : xtVal);
            }
            jet.each([24, 60, 60], function (s, lens) {
                timeArr[s] = [];
                var unhmsVal = minVal[s] == undefined || minVal[s] == 0 ? hmsArr[mhms[s]] : minVal[s],
                    currVal = that.getValue() == "" ? unhmsVal : hmsArr[mhms[s]];
                if (that.dlen > 3 && /\:/.test(nVal) && type == 1) {
                    that.selectTime[0][mhms[s]] = currVal;
                }
                for (var h = 0; h < lens; h++) {
                    var exists = new RegExp(mhms[s], "g").test(format);
                    if (h == currVal) {
                        hmsCls = exists ? "ax-selected" : "ax-disabled";
                    } else if (!exists || !range && multi && (h < minVal[s] || h > maxVal[s])) {
                        hmsCls = "ax-disabled";
                    } else if (!multi) {
                        hmsCls = type == 1 && h < minVal[s] || type == 2 && h > maxVal[s] ? "ax-disabled" : "";
                    } else {
                        hmsCls = "";
                    }
                    timeArr[s].push({ style: hmsCls, hms: h });
                }
            });
            return timeArr;
        },
        closeDate: function () {
            /* var elem = $Q(elx), tipelem = $Q("#jedatetipscon");
            elem && document.body.removeChild(elem);
            tipelem && document.body.removeChild(tipelem); */
            if (this.$opts.mode == 'popup') {
                this.popup.hide();
            } else if (this.$opts.mode == 'dialog') {
                this.dialog.hide();
            }
        },
        parseValue: function (fnObj, matStr) {
            var that = this, valArr = [], opts = that.$opts, range = opts.range;
            jet.each(fnObj, function (i, val) {
                valArr.push(jet.parse(val, matStr));
            });
            return range == false ? valArr[0] : valArr.join(range);
        },
        dateRegExp: function (valArr) {
            var enval = valArr.split(",") || [], regs = "";
            var doExp = function (val) {
                var arr, tmpEval, regs = /#?\{(.*?)\}/;
                val = val + "";
                while ((arr = regs.exec(val)) != null) {
                    arr.lastIndex = arr.index + arr[1].length + arr[0].length - arr[1].length - 1;
                    tmpEval = parseInt(eval(arr[1]));
                    if (tmpEval < 0) tmpEval = "9700" + -tmpEval;
                    val = val.substring(0, arr.index) + tmpEval + val.substring(arr.lastIndex + 1);
                }
                return val;
            };
            if (enval && enval.length > 0) {
                for (var i = 0; i < enval.length; i++) {
                    regs += doExp(enval[i]);
                    if (i != enval.length - 1) regs += "|";
                }
                regs = regs ? new RegExp("(?:" + regs + ")") : null;
            } else {
                regs = null;
            }
            return regs;
        },
        showFestival: function () {
            var that = this, opts = that.$opts;
            jet.each(that.dateCell.querySelectorAll(".ax-dtable td"), function (i, node) {
                var tval = jet.reMatch(jet.attr(node, "ymd")), tipDiv = document.createElement("div");
                node.removeAttribute("ymd");
                new axHover(node, {
                    enter: function () {
                        var lunar = new jeLunar(tval[0], tval[1] - 1, tval[2]);
                        if ($Q("#jedatetipscon")) return;
                        tipDiv.id = tipDiv.className = "jedatetipscon";
                        var tiphtml = '<p>' + lunar.solarYear + '\u5E74' + lunar.solarMonth + '\u6708' + lunar.solarDate + '\u65E5 ' + lunar.inWeekDays + '</p><p>\u519C\u5386：' + lunar.shengxiao + '\u5E74 ' + lunar.lnongMonth + '\u6708' + lunar.lnongDate + '</p><p>' + lunar.ganzhiYear + '\u5E74 ' + lunar.ganzhiMonth + '\u6708 ' + lunar.ganzhiDate + '\u65E5</p>';
                        var Fesjieri = (lunar.solarFestival || lunar.lunarFestival) != "" ? '<p class="red">' + ("\u8282\u65E5：" + lunar.solarFestival + lunar.lunarFestival) + '</p>' : "";
                        var Fesjieqi = lunar.jieqi != "" ? '<p>' + (lunar.jieqi != "" ? "\u8282\u6C14：" + lunar.jieqi : "") + '</p>' : "";
                        var tiptext = (lunar.solarFestival || lunar.lunarFestival || lunar.jieqi) != "" ? (Fesjieri + Fesjieqi) : "";
                        jet.html(tipDiv, tiphtml + tiptext);
                        that.lunarPopup = new axPopup(node, {
                            size: '',
                            close: false,
                            placement: 'bottom-start',
                            footerShow: false,
                            content: tipDiv,
                        }).show();
                    },
                    leave: function () {
                        that.lunarPopup ? that.lunarPopup.targetDom.remove() : null;
                    },
                })
            });
            if (that.dateCell.nodeType === 1 && !jet.hasClass(that.dateCell, "grid")) that.dateCell.className = that.dateCell.className + " grid";
        },
        lunarOrien: function (obj, self, pos) {
            var tops, leris, ortop, orleri, rect = self.getBoundingClientRect(), boxW = obj.offsetWidth, boxH = obj.offsetHeight;
            leris = rect.right + boxW / 1.5 >= jet.docArea(true) ? rect.right - boxW : rect.left + (pos ? 0 : jet.docScroll(true));
            tops = rect.bottom + boxH / 1 <= jet.docArea() ? rect.bottom - 1 : rect.top > boxH / 1.5 ? rect.top - boxH - 1 : jet.docArea() - boxH;
            if (leris + boxW > jet.docArea(true)) leris = rect.left - (boxW - rect.width);
            ortop = Math.max(tops + (pos ? 0 : jet.docScroll()) + 1, 1) + "px", orleri = leris + "px";
            return { top: ortop, left: orleri }
        },
        dateOrien: function (elbox, valCls, pos) {
            var that = this, tops, leris, ortop, orleri,
                rect = that.$opts.fixed ? valCls.getBoundingClientRect() : elbox.getBoundingClientRect(),
                leris = rect.left, tops = rect.bottom;
            if (that.$opts.fixed) {
                var boxW = elbox.offsetWidth, boxH = elbox.offsetHeight;
                if (leris + boxW > jet.docArea(true)) {
                    leris = leris - (boxW - rect.width);
                }
                if (tops + boxH > jet.docArea()) {
                    tops = rect.top > boxH ? rect.top - boxH - 2 : jet.docArea() - boxH - 1;
                }
                ortop = Math.max(tops + (pos ? 0 : jet.docScroll()) + 1, 1) + "px"; orleri = leris + "px";
            } else {
                ortop = "50%"; orleri = "50%";
                elbox.style.cssText = "marginTop:" + -(rect.height / 2) + ";marginLeft:" + -(rect.width / 2);
            }
        },
        tips: function (text, time) {
            /* var that = this, tipCls = $Q(".ax-date-tips", that.dateCell), tipTime;
            jet.html(tipCls, text || ""); jet.setCss(tipCls, { display: "block" });
            clearTimeout(tipTime);
            tipTime = setTimeout(function () {
                jet.html(tipCls, ""); jet.setCss(tipCls, { display: "none" });
            }, (time || 2.5) * 1000); */
            new axMessage({
                content: text,
                iconShow: true,
                result: 'error',
            });
        },
        locateScroll: function () {
            var that = this, ulCell = $Q(".ax-date-time", that.dateCell).querySelectorAll("ul");
            jet.each(ulCell, function (i, cell) {
                var hmsCls = cell.querySelector(".ax-selected");
                cell.scrollTop = hmsCls ? (hmsCls.offsetTop) : 0;
            });
            if (that.dlen != 7) jet.setCss($Q(".ax-date-time", that.dateCell), { display: 'none' });
        }
    });
    function jeLunar(ly, lm, ld) {
        var lunarInfo = [19416, 19168, 42352, 21717, 53856, 55632, 91476, 22176, 39632, 21970, 19168, 42422, 42192, 53840, 119381, 46400, 54944, 44450, 38320, 84343, 18800, 42160, 46261, 27216, 27968, 109396, 11104, 38256, 21234, 18800, 25958, 54432, 59984, 28309, 23248, 11104, 100067, 37600, 116951, 51536, 54432, 120998, 46416, 22176, 107956, 9680, 37584, 53938, 43344, 46423, 27808, 46416, 86869, 19872, 42448, 83315, 21200, 43432, 59728, 27296, 44710, 43856, 19296, 43748, 42352, 21088, 62051, 55632, 23383, 22176, 38608, 19925, 19152, 42192, 54484, 53840, 54616, 46400, 46496, 103846, 38320, 18864, 43380, 42160, 45690, 27216, 27968, 44870, 43872, 38256, 19189, 18800, 25776, 29859, 59984, 27480, 21952, 43872, 38613, 37600, 51552, 55636, 54432, 55888, 30034, 22176, 43959, 9680, 37584, 51893, 43344, 46240, 47780, 44368, 21977, 19360, 42416, 86390, 21168, 43312, 31060, 27296, 44368, 23378, 19296, 42726, 42208, 53856, 60005, 54576, 23200, 30371, 38608, 19415, 19152, 42192, 118966, 53840, 54560, 56645, 46496, 22224, 21938, 18864, 42359, 42160, 43600, 111189, 27936, 44448],
            sTermInfo = [0, 21208, 43467, 63836, 85337, 107014, 128867, 150921, 173149, 195551, 218072, 240693, 263343, 285989, 308563, 331033, 353350, 375494, 397447, 419210, 440795, 462224, 483532, 504758];
        var Gan = "甲乙丙丁戊己庚辛壬癸", Zhi = "子丑寅卯辰巳午未申酉戌亥", Animals = "鼠牛虎兔龙蛇马羊猴鸡狗猪";
        var solarTerm = ["小寒", "大寒", "立春", "雨水", "惊蛰", "春分", "清明", "谷雨", "立夏", "小满",
            "芒种", "夏至", "小暑", "大暑", "立秋", "处暑", "白露", "秋分", "寒露", "霜降", "立冬", "小雪", "大雪", "冬至"];
        var nStr1 = "日一二三四五六七八九十", nStr2 = "初十廿卅", nStr3 = ["正", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "腊"],
            sFtv1 = {
                "0101": "*1元旦节", "0202": "湿地日",
                "0214": "情人节", "0308": "妇女节",
                "0312": "植树节", "0315": "消费者权益日",
                "0401": "愚人节", "0422": "地球日",
                "0501": "*1劳动节", "0504": "青年节",
                "0512": "护士节", "0518": "博物馆日",
                "0520": "母亲节", "0601": "儿童节",
                "0623": "奥林匹克日", "0630": "父亲节",
                "0701": "建党节", "0801": "建军节",
                "0903": "抗战胜利日", "0910": "教师节",
                "1001": "*3国庆节", "1201": "艾滋病日",
                "1224": "平安夜", "1225": "圣诞节"
            },
            sFtv2 = {
                "0100": "除夕", "0101": "*2春节",
                "0115": "元宵节", "0505": "*1端午节",
                "0707": "七夕节", "0715": "中元节",
                "0815": "*1中秋节", "0909": "*1重阳节",
                "1015": "下元节", "1208": "腊八节",
                "1223": "小年"
            };
        function flunar(Y) {
            var sTerm = function (j, i) {
                var h = new Date((31556925974.7 * (j - 1900) + sTermInfo[i] * 60000) + Date.UTC(1900, 0, 6, 2, 5));
                return (h.getUTCDate());
            },
                d = function (k) {
                    var h, j = 348;
                    for (h = 32768; h > 8; h >>= 1) j += (lunarInfo[k - 1900] & h) ? 1 : 0;
                    return (j + b(k));
                },
                ymdCyl = function (h) {
                    return (Gan.charAt(h % 10) + Zhi.charAt(h % 12));
                },
                b = function (h) {
                    var islp = (g(h)) ? ((lunarInfo[h - 1900] & 65536) ? 30 : 29) : (0);
                    return islp;
                },
                g = function (h) {
                    return (lunarInfo[h - 1900] & 15)
                },
                e = function (i, h) {
                    return ((lunarInfo[i - 1900] & (65536 >> h)) ? 30 : 29);
                },
                newymd = function (m) {
                    var k, j = 0, h = 0, l = new Date(1900, 0, 31), n = (m - l) / 86400000;
                    this.dayCyl = n + 40;
                    this.monCyl = 14;
                    for (k = 1900; k < 2050 && n > 0; k++) {
                        h = d(k); n -= h;
                        this.monCyl += 12;
                    }
                    if (n < 0) {
                        n += h; k--;
                        this.monCyl -= 12;
                    }
                    this.year = k;
                    this.yearCyl = k - 1864;
                    j = g(k);
                    this.isLeap = false;
                    for (k = 1; k < 13 && n > 0; k++) {
                        if (j > 0 && k == (j + 1) && this.isLeap == false) {
                            --k;
                            this.isLeap = true;
                            h = b(this.year);
                        } else {
                            h = e(this.year, k);
                        }
                        if (this.isLeap == true && k == (j + 1)) {
                            this.isLeap = false;
                        }
                        n -= h;
                        if (this.isLeap == false) this.monCyl++;
                    }
                    if (n == 0 && j > 0 && k == j + 1) {
                        if (this.isLeap) {
                            this.isLeap = false;
                        } else {
                            this.isLeap = true;
                            --k;
                            --this.monCyl;
                        }
                    }
                    if (n < 0) {
                        n += h; --k;
                        --this.monCyl;
                    }
                    this.month = k;
                    this.day = n + 1;
                },
                digit = function (num) {
                    return num < 10 ? "0" + (num | 0) : num;
                },
                reymd = function (i, j) {
                    var h = i;
                    return j.replace(/dd?d?d?|MM?M?M?|yy?y?y?/g, function (k) {
                        switch (k) {
                            case "yyyy":
                                var l = "000" + h.getFullYear();
                                return l.substring(l.length - 4);
                            case "dd": return digit(h.getDate());
                            case "d": return h.getDate().toString();
                            case "MM": return digit((h.getMonth() + 1));
                            case "M": return h.getMonth() + 1;
                        }
                    });
                },
                lunarMD = function (i, h) {
                    var j;
                    switch (i, h) {
                        case 10: j = "初十"; break;
                        case 20: j = "二十"; break;
                        case 30: j = "三十"; break;
                        default:
                            j = nStr2.charAt(Math.floor(h / 10));
                            j += nStr1.charAt(h % 10);
                    }
                    return j;
                };
            this.isToday = false;
            this.isRestDay = false;
            this.solarYear = reymd(Y, "yyyy");
            this.solarMonth = reymd(Y, "M");
            this.solarDate = reymd(Y, "d");
            this.solarWeekDay = Y.getDay();
            this.inWeekDays = "星期" + nStr1.charAt(this.solarWeekDay);
            var X = new newymd(Y);
            this.lunarYear = X.year;
            this.shengxiao = Animals.charAt((this.lunarYear - 4) % 12);
            this.lunarMonth = X.month;
            this.lunarIsLeapMonth = X.isLeap;
            this.lnongMonth = this.lunarIsLeapMonth ? "闰" + nStr3[X.month - 1] : nStr3[X.month - 1];
            this.lunarDate = X.day;
            this.showInLunar = this.lnongDate = lunarMD(this.lunarMonth, this.lunarDate);
            if (this.lunarDate == 1) {
                this.showInLunar = this.lnongMonth + "月";
            }
            this.ganzhiYear = ymdCyl(X.yearCyl);
            this.ganzhiMonth = ymdCyl(X.monCyl);
            this.ganzhiDate = ymdCyl(X.dayCyl++);
            this.jieqi = "";
            this.restDays = 0;
            if (sTerm(this.solarYear, (this.solarMonth - 1) * 2) == reymd(Y, "d")) {
                this.showInLunar = this.jieqi = solarTerm[(this.solarMonth - 1) * 2];
            }
            if (sTerm(this.solarYear, (this.solarMonth - 1) * 2 + 1) == reymd(Y, "d")) {
                this.showInLunar = this.jieqi = solarTerm[(this.solarMonth - 1) * 2 + 1];
            }
            if (this.showInLunar == "清明") {
                this.showInLunar = "清明节";
                this.restDays = 1;
            }
            this.solarFestival = sFtv1[reymd(Y, "MM") + reymd(Y, "dd")];
            if (typeof this.solarFestival == "undefined") {
                this.solarFestival = "";
            } else {
                if (/\*(\d)/.test(this.solarFestival)) {
                    this.restDays = parseInt(RegExp.$1);
                    this.solarFestival = this.solarFestival.replace(/\*\d/, "");
                }
            }
            this.showInLunar = (this.solarFestival == "") ? this.showInLunar : this.solarFestival;
            this.lunarFestival = sFtv2[this.lunarIsLeapMonth ? "00" : digit(this.lunarMonth) + digit(this.lunarDate)];
            if (typeof this.lunarFestival == "undefined") {
                this.lunarFestival = "";
            } else {
                if (/\*(\d)/.test(this.lunarFestival)) {
                    this.restDays = (this.restDays > parseInt(RegExp.$1)) ? this.restDays : parseInt(RegExp.$1);
                    this.lunarFestival = this.lunarFestival.replace(/\*\d/, "");
                }
            }
            if (this.lunarMonth == 12 && this.lunarDate == e(this.lunarYear, 12)) {
                this.lunarFestival = sFtv2["0100"];
                this.restDays = 1;
            }
            this.showInLunar = (this.lunarFestival == "") ? this.showInLunar : this.lunarFestival;
        }
        return new flunar(new Date(ly, lm, ld));
    }
    return jeDate;
})();
document.querySelectorAll('[axDate]').forEach(element => {
    new axDate(element);
});
/*!
* 插件：轮滑选择；改造自ion.rangeSlider | https://github.com/IonDen/ion.rangeSlider；使用方法：new axRange('#id',{参数})
*/
const axRanges = [];
class axRange {
    constructor(targetDom, options) {
        if ((typeof targetDom) === 'string') {
            this.targetDom = document.querySelector(targetDom);
        } else {
            this.targetDom = targetDom;
        }
        if (!(this instanceof axRange)) return new axRange(targetDom, options);
        let _this = this;
        this.calcCount = 0;
        this.updateTm = 0;
        this.oldFrom = 0;
        this.oldTo = 0;
        this.oldMinInterval = null;
        this.rafId = null;
        this.dragging = false;
        this.forceRedraw = false;
        this.noDiapason = false;
        this.hasTabIndex = true;
        this.isKey = false;
        this.isUpdate = false;
        this.isStart = true;
        this.isFinish = false;
        this.isActive = false;
        this.isResize = false;
        this.isClick = false;
        this.target = "base";
        this.cache = {
            win: window,
            body: document.body,
            targetDom: this.targetDom,
            cont: null,
            rs: null,
            min: null,
            max: null,
            from: null,
            to: null,
            single: null,
            bar: null,
            line: null,
            s_single: null,
            s_from: null,
            s_to: null,
            shad_single: null,
            shad_from: null,
            shad_to: null,
            edge: null,
            grid: null,
            grid_labels: []
        };
        this.coords = {
            x_gap: 0,
            x_pointer: 0,
            w_rs: 0,
            w_rs_old: 0,
            w_handle: 0,
            p_gap: 0,
            p_gap_left: 0,
            p_gap_right: 0,
            p_step: 0,
            p_pointer: 0,
            p_handle: 0,
            p_single_fake: 0,
            p_single_real: 0,
            p_from_fake: 0,
            p_from_real: 0,
            p_to_fake: 0,
            p_to_real: 0,
            p_bar_x: 0,
            p_bar_w: 0,
            grid_gap: 0,
            big_num: 0,
            big: [],
            big_w: [],
            big_p: [],
            big_x: []
        };
        this.labels = {
            w_min: 0,
            w_max: 0,
            w_from: 0,
            w_to: 0,
            w_single: 0,
            p_min: 0,
            p_max: 0,
            p_from_fake: 0,
            p_from_left: 0,
            p_to_fake: 0,
            p_to_left: 0,
            p_single_fake: 0,
            p_single_left: 0
        };
        if (this.targetDom.nodeName !== "INPUT") {
            console && console.warn && console.warn("Base targetDom should be <input>!", input);
        }
        this.config = {
            className: "",
            type: "single",
            min: 0,
            max: 100,
            from: null,
            to: null,
            step: 1,
            minInterval: 0,
            maxInterval: 0,
            dragInterval: false,
            values: [],
            pValues: [],
            fromStick: false,
            fromMin: null,
            fromMax: null,
            fromShadow: false,
            toStick: false,
            toMin: null,
            toMax: null,
            toShadow: false,
            prettifyEnabled: false,
            prettifySeparator: " ",
            prettify: null,
            forceEdges: false,
            keyboard: true,
            grid: false,
            gridMargin: true,
            gridNum: 4,
            gridSnap: false,
            hideLabelTrack: false,
            hideLabelSlider: false,
            prefix: "",
            postfix: "",
            maxPostfix: "",
            decorateBoth: true,
            valuesSeparator: " — ",
            inputValuesSeparator: ";",
            disabled: false,
            block: false,
            scope: null,
            onStart: null,
            onChange: null,
            onFinish: null,
            onUpdate: null
        }
        let val = this.targetDom.value;
        if (val !== undefined && val !== "") {
            if (options && options.inputValuesSeparator) {
                val = val.split(options.inputValuesSeparator);
            } else {
                val = val.split(";");
            }
            if (val[0] && val[0] == +val[0]) {
                val[0] = +val[0];
            }
            if (val[1] && val[1] == +val[1]) {
                val[1] = +val[1];
            }
            if (options && options.values && options.values.length) {
                this.config.from = val[0] && options.values.indexOf(val[0]);
                this.config.to = val[1] && options.values.indexOf(val[1]);
            } else {
                this.config.from = val[0] && +val[0];
                this.config.to = val[1] && +val[1];
            }
        }
        this.options = axExtend(this.config, options, this.targetDom,'axRange');
        this.targetDom ? this.referName = this.targetDom.getAttribute('axRange') : this.referName = '';
        this.handlers = {};
        this.update_check = {};
        this.result = {
            input: this.cache.targetDom,
            slider: null,
            min: this.options.min,
            max: this.options.max,
            from: this.options.from,
            from_percent: 0,
            from_value: null,
            to: this.options.to,
            to_percent: 0,
            to_value: null
        };
        const base_html =
            '<div class="ax-range-label">' +
            '<span class="ax-range-line" tabindex="0"></span>' +
            '<span class="ax-range-min">0</span><span class="ax-range-max">1</span>' +
            '<span class="ax-range-from">0</span><span class="ax-range-to">0</span><span class="ax-range-single">0</span>' +
            '</div>' +
            '<div class="ax-range-grid">1</div>';
        const single_html =
            '<div class="ax-range-bar ax-range-bar-single"></div>' +
            '<div class="ax-range-shadow ax-shadow-single"></div>' +
            '<span class="ax-range-handle ax-single"><i></i><i></i><i></i></span>';
        const double_html =
            '<div class="ax-range-bar"></div>' +
            '<div class="ax-range-shadow ax-shadow-from"></div>' +
            '<div class="ax-range-shadow ax-shadow-to"></div>' +
            '<span class="ax-range-handle ax-from"><i></i><i></i><i></i></span>' +
            '<span class="ax-range-handle ax-to"><i></i><i></i><i></i></span>';
        const disable_html =
            '<div class="ax-disabled-mask"></div>';
        this.ready = function (update) {
            this.noDiapason = false;
            this.coords.p_step = convertToPercent(this.options.step, true);
            this.target = "base";
            this.toggleInput();
            append();
            setMinMax();
            if (update) {
                this.forceRedraw = true;
                calc(true);
                callOnUpdate();
            } else {
                this.forceRedraw = true;
                calc(true);
                callOnStart();
            }
            updateScene();
        };
        const append = function () {
            const container_html = '<div class="ax-range ' + _this.options.className + '"></div>';
            _this.cache.targetDom.insertAdjacentHTML('beforebegin', container_html);
            _this.cache.targetDom.setAttribute("readonly", "true");
            _this.cache.cont = _this.cache.targetDom.previousElementSibling;
            _this.result.slider = _this.cache.cont;
            _this.cache.cont.innerHTML = base_html;
            _this.cache.label = _this.cache.cont.querySelector(".ax-range-label");
            _this.cache.min = _this.cache.cont.querySelector(".ax-range-min");
            _this.cache.max = _this.cache.cont.querySelector(".ax-range-max");
            _this.cache.from = _this.cache.cont.querySelector(".ax-range-from");
            _this.cache.to = _this.cache.cont.querySelector(".ax-range-to");
            _this.cache.single = _this.cache.cont.querySelector(".ax-range-single");
            _this.cache.line = _this.cache.cont.querySelector(".ax-range-line");
            _this.cache.grid = _this.cache.cont.querySelector(".ax-range-grid");
            if (_this.options.type === "single") {
                _this.cache.cont.insertAdjacentHTML('beforeend', single_html);
                _this.cache.bar = _this.cache.cont.querySelector(".ax-range-bar");
                _this.cache.edge = _this.cache.cont.querySelector(".ax-range-bar-single");
                _this.cache.s_single = _this.cache.cont.querySelector(".ax-single");
                _this.cache.from.style.visibility = "hidden";
                _this.cache.to.style.visibility = "hidden";
                _this.cache.shad_single = _this.cache.cont.querySelector(".ax-shadow-single");
            } else {
                _this.cache.cont.insertAdjacentHTML('beforeend', double_html);
                _this.cache.bar = _this.cache.cont.querySelector(".ax-range-bar");
                _this.cache.s_from = _this.cache.cont.querySelector(".ax-from");
                _this.cache.s_to = _this.cache.cont.querySelector(".ax-to");
                _this.cache.shad_from = _this.cache.cont.querySelector(".ax-shadow-from");
                _this.cache.shad_to = _this.cache.cont.querySelector(".ax-shadow-to");
                setTopHandler();
            }
            if (_this.options.hideLabelSlider) {
                _this.cache.from.style.display = "none";
                _this.cache.to.style.display = "none";
                _this.cache.single.style.display = "none";
            }
            appendGrid();
            if (_this.options.disabled) {
                appendDisableMask();
                _this.cache.targetDom.disabled = true;
            } else {
                _this.cache.targetDom.disabled = false;
                removeDisableMask();
                bindEvents();
            }
            if (!_this.options.disabled) {
                if (_this.options.block) {
                    appendDisableMask();
                } else {
                    removeDisableMask();
                }
            }
            if (_this.options.dragInterval) {
                _this.cache.bar.style.cursor = "ew-resize";
            }
        };
        const setTopHandler = function () {
            const min = _this.options.min,
                max = _this.options.max,
                from = _this.options.from,
                to = _this.options.to;
            if (from > min && to === max) {
                _this.cache.s_from.classList.add("ax-last");
            } else if (to < max) {
                _this.cache.s_to.classList.add("ax-last");
            }
        };
        /**
         * Determine which handles was clicked last and which handler should have hover effect
         *
         * @param _this.target {String}
         */
        const changeLevel = function (target) {
            switch (_this.target) {
                case "single":
                    _this.coords.p_gap = toFixed(_this.coords.p_pointer - _this.coords.p_single_fake);
                    _this.cache.s_single.classList.add("ax-hover");
                    break;
                case "from":
                    _this.coords.p_gap = toFixed(_this.coords.p_pointer - _this.coords.p_from_fake);
                    _this.cache.s_from.classList.add("ax-hover", "ax-last");
                    _this.cache.s_to.classList.remove("ax-last");
                    break;
                case "to":
                    _this.coords.p_gap = toFixed(_this.coords.p_pointer - _this.coords.p_to_fake);
                    _this.cache.s_to.classList.add("ax-hover", "ax-last");
                    _this.cache.s_from.classList.remove("ax-last");
                    break;
                case "both":
                    _this.coords.p_gap_left = toFixed(_this.coords.p_pointer - _this.coords.p_from_fake);
                    _this.coords.p_gap_right = toFixed(_this.coords.p_to_fake - _this.coords.p_pointer);
                    _this.cache.s_to.classList.remove("ax-last");
                    _this.cache.s_from.classList.remove("ax-last");
                    break;
            }
        };
        /**
         * Then slider is disabled -> append extra layer with opacity
         */
        const appendDisableMask = function () {
            _this.cache.cont.insertAdjacentHTML('beforeend', disable_html);
            _this.cache.cont.classList.add("ax-disabled");
        };
        /**
         * Then slider is not disabled -> remove disable mask
         */
        const removeDisableMask = function () {
            _this.cache.cont.classList.remove(".ax-disabled-mask");
            _this.cache.cont.classList.remove("ax-disabled");
        };
        this.remove = function () {
            this.cache.cont.remove();
            this.cache.cont = null;
            this.cache.win.removeEventListener("keydown", key.bind(this, 'keyboard'));
            this.cache.body.removeEventListener("touchmove", pointerMove.bind(this));
            this.cache.body.removeEventListener("mousemove", pointerMove.bind(this));
            this.cache.win.removeEventListener("touchend", pointerUp.bind(this));
            this.cache.win.removeEventListener("mouseup", pointerUp.bind(this));
            this.cache.grid_labels = [];
            this.coords.big = [];
            this.coords.big_w = [];
            this.coords.big_p = [];
            this.coords.big_x = [];
            cancelAnimationFrame(this.rafId);
        };
        const bindEvents = function () {
            if (_this.noDiapason) {
                return;
            }
            _this.cache.body.addEventListener('touchmove', pointerMove.bind(this));
            _this.cache.body.addEventListener('mousemove', pointerMove.bind(this));
            _this.cache.win.addEventListener('touchend', pointerUp.bind(this));
            _this.cache.win.addEventListener('mouseup', pointerUp.bind(this));
            _this.cache.line.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
            _this.cache.line.addEventListener('mousedown', pointerClick.bind(this, 'click'));
            _this.cache.line.addEventListener('focus', pointerFocus.bind(this));
            if (_this.options.dragInterval && _this.options.type === "double") {
                _this.cache.bar.addEventListener('touchstart', pointerDown.bind(this, 'both'), { passive: true });
                _this.cache.bar.addEventListener('mousedown', pointerDown.bind(this, 'both'));
            } else {
                _this.cache.bar.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
                _this.cache.bar.addEventListener('mousedown', pointerClick.bind(this, 'click'));
            }
            if (_this.options.type === "single") {
                _this.cache.single.addEventListener('touchstart', pointerDown.bind(this, 'single'), { passive: true });
                _this.cache.s_single.addEventListener('touchstart', pointerDown.bind(this, 'single'), { passive: true });
                _this.cache.shad_single.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
                _this.cache.single.addEventListener('mousedown', pointerDown.bind(this, 'single'));
                _this.cache.s_single.addEventListener('mousedown', pointerDown.bind(this, 'single'));
                _this.cache.edge.addEventListener('mousedown', pointerClick.bind(this, 'click'));
                _this.cache.shad_single.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
            } else {
                _this.cache.single.addEventListener('touchstart', pointerDown.bind(this, null), { passive: true });
                _this.cache.single.addEventListener('mousedown', pointerDown.bind(this, null));
                _this.cache.from.addEventListener('touchstart', pointerDown.bind(this, 'from'), { passive: true });
                _this.cache.s_from.addEventListener('touchstart', pointerDown.bind(this, 'from'), { passive: true });
                _this.cache.to.addEventListener('touchstart', pointerDown.bind(this, 'to'), { passive: true });
                _this.cache.s_to.addEventListener('touchstart', pointerDown.bind(this, 'to'), { passive: true });
                _this.cache.shad_from.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
                _this.cache.shad_to.addEventListener('touchstart', pointerClick.bind(this, 'click'), { passive: true });
                _this.cache.from.addEventListener('mousedown', pointerDown.bind(this, 'from'));
                _this.cache.s_from.addEventListener('mousedown', pointerDown.bind(this, 'from'));
                _this.cache.to.addEventListener('mousedown', pointerDown.bind(this, 'to'));
                _this.cache.s_to.addEventListener('mousedown', pointerDown.bind(this, 'to'));
                _this.cache.shad_from.addEventListener('mousedown', pointerClick.bind(this, 'click'));
                _this.cache.shad_to.addEventListener('mousedown', pointerClick.bind(this, 'click'));
            }
            if (_this.options.keyboard) {
                _this.cache.line.addEventListener('keydown', key.bind(this, 'keyboard'));
            }
        };
        /**
         * Focus with tabIndex
         *
         * @param e {Object} event object
         */
        const pointerFocus = function (e) {
            if (!_this.target) {
                let x, $handle;
                if (_this.options.type === "single") {
                    $handle = _this.cache.single;
                } else {
                    $handle = _this.cache.from;
                }
                x = $handle.getBoundingClientRect().left;
                x += ($handle.getBoundingClientRect().width / 2) - 1;
                pointerClick("single", { preventDefault: function () { }, pageX: x });
            } else {
                _this.cache.line.focus();
            }
        };
        const pointerMove = function (e) {
            if (!_this.dragging) {
                return;
            }
            const x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX; 
            _this.coords.x_pointer = x - _this.coords.x_gap;
            calc();
        };
        const pointerUp = function (e) {
            if (_this.isActive) {
                _this.isActive = false;
            } else {
                return;
            }
            const hoverState = _this.cache.cont.querySelector(".ax-hover");
            if (hoverState) {
                hoverState.classList.remove("ax-hover");
            }
            _this.forceRedraw = true;
            updateScene();
            restoreOriginalMinInterval();
            if (_this.cache.cont.contains(e.target) || _this.dragging) {
                callOnFinish();
            }
            _this.dragging = false;
        };
        const pointerDown = function (destination, e) {
            axPreventDefault(e);
            const x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX; 
            if (e.button === 2) {
                return;
            }
            if (destination === "both") {
                setTempMinInterval();
            }
            if (!destination) {
                destination = _this.target || "from";
            }
            _this.target = destination;
            _this.isActive = true;
            _this.dragging = true;
            _this.coords.x_gap = _this.cache.label.getBoundingClientRect().left;
            _this.coords.x_pointer = x - _this.coords.x_gap;
            calcPointerPercent();
            changeLevel(destination);
            _this.cache.line.dispatchEvent(new Event("focus"));
            updateScene();
        };
        const pointerClick = function (destination, e) {
            axPreventDefault(e);
            const x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX; 
            if (e.button === 2) {
                return;
            }
            _this.target = destination;
            _this.isClick = true;
            _this.coords.x_gap = _this.cache.label.getBoundingClientRect().left;
            _this.coords.x_pointer = +(x - _this.coords.x_gap).toFixed();
            _this.forceRedraw = true;
            calc();
            _this.cache.line.dispatchEvent(new Event("focus"));
        };
        const key = function (destination, e) {
            if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                return;
            }
            switch (e.which) {
                case 83: 
                case 65: 
                case 40: 
                case 37: 
                axPreventDefault(e);
                    moveByKey(false);
                    break;
                case 87: 
                case 68: 
                case 38: 
                case 39: 
                axPreventDefault(e);
                    moveByKey(true);
                    break;
            }
        };
        const moveByKey = function (right) {
            let p = _this.coords.p_pointer;
            const p_step = _this.options.step / ((_this.options.max - _this.options.min) / 100);
            right ? p += p_step : p -= p_step;
            _this.coords.x_pointer = toFixed(_this.coords.w_rs / 100 * p);
            _this.isKey = true;
            calc();
        };
        const setMinMax = function () {
            if (!_this.options) {
                return;
            }
            if (_this.options.hideLabelTrack) {
                _this.cache.min.style.display = "none";
                _this.cache.max.style.display = "none";
                return;
            }
            if (_this.options.values.length) {
                _this.cache.min.innerHTML = decorate(_this.options.pValues[_this.options.min]);
                _this.cache.max.innerHTML = decorate(_this.options.pValues[_this.options.max]);
            } else {
                const min_pretty = _prettify(_this.options.min);
                const max_pretty = _prettify(_this.options.max);
                _this.result.min_pretty = min_pretty;
                _this.result.max_pretty = max_pretty;
                _this.cache.min.innerHTML = decorate(min_pretty, _this.options.min);
                _this.cache.max.innerHTML = decorate(max_pretty, _this.options.max);
            }
            _this.labels.w_min = _this.cache.min.offsetWidth;
            _this.labels.w_max = _this.cache.max.offsetWidth;
        };
        /**
         * Then _this.dragging interval, prevent interval collapsing
         * using min_interval option
         */
        const setTempMinInterval = function () {
            const interval = _this.result.to - _this.result.from;
            if (_this.oldMinInterval === null) {
                _this.oldMinInterval = _this.options.minInterval;
            }
            _this.options.minInterval = interval;
        };
        const restoreOriginalMinInterval = function () {
            if (_this.oldMinInterval !== null) {
                _this.options.minInterval = _this.oldMinInterval;
                _this.oldMinInterval = null;
            }
        };
        /**
         * All calculations and measures start here
         *
         * @param update {boolean=}
         */
        const calc = function (update) {
            if (!_this.options) {
                return;
            }
            _this.calcCount++;
            if (_this.calcCount === 10 || update) {
                _this.calcCount = 0;
                _this.coords.w_rs = _this.cache.label.offsetWidth;
                calcHandlePercent();
            }
            if (!_this.coords.w_rs) {
                return;
            }
            calcPointerPercent();
            let handle_x = getHandleX();
            if (_this.target === "both") {
                _this.coords.p_gap = 0;
                handle_x = getHandleX();
            }
            if (_this.target === "click") {
                _this.coords.p_gap = _this.coords.p_handle / 2;
                handle_x = getHandleX();
                if (_this.options.dragInterval) {
                    _this.target = "both_one";
                } else {
                    _this.target = chooseHandle(handle_x);
                }
            }
            switch (_this.target) {
                case "base":
                    const w = (_this.options.max - _this.options.min) / 100,
                        f = (_this.result.from - _this.options.min) / w,
                        t = (_this.result.to - _this.options.min) / w;
                    _this.coords.p_single_real = toFixed(f);
                    _this.coords.p_from_real = toFixed(f);
                    _this.coords.p_to_real = toFixed(t);
                    _this.coords.p_single_real = checkDiapason(_this.coords.p_single_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_from_real = checkDiapason(_this.coords.p_from_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_to_real = checkDiapason(_this.coords.p_to_real, _this.options.toMin, _this.options.toMax);
                    _this.coords.p_single_fake = convertToFakePercent(_this.coords.p_single_real);
                    _this.coords.p_from_fake = convertToFakePercent(_this.coords.p_from_real);
                    _this.coords.p_to_fake = convertToFakePercent(_this.coords.p_to_real);
                    _this.target = null;
                    break;
                case "single":
                    if (_this.options.fromStick) {
                        break;
                    }
                    _this.coords.p_single_real = convertToRealPercent(handle_x);
                    _this.coords.p_single_real = calcWithStep(_this.coords.p_single_real);
                    _this.coords.p_single_real = checkDiapason(_this.coords.p_single_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_single_fake = convertToFakePercent(_this.coords.p_single_real);
                    break;
                case "from":
                    if (_this.options.fromStick) {
                        break;
                    }
                    _this.coords.p_from_real = convertToRealPercent(handle_x);
                    _this.coords.p_from_real = calcWithStep(_this.coords.p_from_real);
                    if (_this.coords.p_from_real > _this.coords.p_to_real) {
                        _this.coords.p_from_real = _this.coords.p_to_real;
                    }
                    _this.coords.p_from_real = checkDiapason(_this.coords.p_from_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_from_real = checkMinInterval(_this.coords.p_from_real, _this.coords.p_to_real, "from");
                    _this.coords.p_from_real = checkMaxInterval(_this.coords.p_from_real, _this.coords.p_to_real, "from");
                    _this.coords.p_from_fake = convertToFakePercent(_this.coords.p_from_real);
                    break;
                case "to":
                    if (_this.options.toStick) {
                        break;
                    }
                    _this.coords.p_to_real = convertToRealPercent(handle_x);
                    _this.coords.p_to_real = calcWithStep(_this.coords.p_to_real);
                    if (_this.coords.p_to_real < _this.coords.p_from_real) {
                        _this.coords.p_to_real = _this.coords.p_from_real;
                    }
                    _this.coords.p_to_real = checkDiapason(_this.coords.p_to_real, _this.options.toMin, _this.options.toMax);
                    _this.coords.p_to_real = checkMinInterval(_this.coords.p_to_real, _this.coords.p_from_real, "to");
                    _this.coords.p_to_real = checkMaxInterval(_this.coords.p_to_real, _this.coords.p_from_real, "to");
                    _this.coords.p_to_fake = convertToFakePercent(_this.coords.p_to_real);
                    break;
                case "both":
                    if (_this.options.fromStick || _this.options.toStick) {
                        break;
                    }
                    handle_x = toFixed(handle_x + (_this.coords.p_handle * 0.001));
                    _this.coords.p_from_real = convertToRealPercent(handle_x) - _this.coords.p_gap_left;
                    _this.coords.p_from_real = calcWithStep(_this.coords.p_from_real);
                    _this.coords.p_from_real = checkDiapason(_this.coords.p_from_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_from_real = checkMinInterval(_this.coords.p_from_real, _this.coords.p_to_real, "from");
                    _this.coords.p_from_fake = convertToFakePercent(_this.coords.p_from_real);
                    _this.coords.p_to_real = convertToRealPercent(handle_x) + _this.coords.p_gap_right;
                    _this.coords.p_to_real = calcWithStep(_this.coords.p_to_real);
                    _this.coords.p_to_real = checkDiapason(_this.coords.p_to_real, _this.options.toMin, _this.options.toMax);
                    _this.coords.p_to_real = checkMinInterval(_this.coords.p_to_real, _this.coords.p_from_real, "to");
                    _this.coords.p_to_fake = convertToFakePercent(_this.coords.p_to_real);
                    break;
                case "both_one":
                    if (_this.options.fromStick || _this.options.toStick) {
                        break;
                    }
                    const real_x = convertToRealPercent(handle_x),
                        from = _this.result.from_percent,
                        to = _this.result.to_percent,
                        full = to - from,
                        half = full / 2;
                    let new_from = real_x - half,
                        new_to = real_x + half;
                    if (new_from < 0) {
                        new_from = 0;
                        new_to = new_from + full;
                    }
                    if (new_to > 100) {
                        new_to = 100;
                        new_from = new_to - full;
                    }
                    _this.coords.p_from_real = calcWithStep(new_from);
                    _this.coords.p_from_real = checkDiapason(_this.coords.p_from_real, _this.options.fromMin, _this.options.fromMax);
                    _this.coords.p_from_fake = convertToFakePercent(_this.coords.p_from_real);
                    _this.coords.p_to_real = calcWithStep(new_to);
                    _this.coords.p_to_real = checkDiapason(_this.coords.p_to_real, _this.options.toMin, _this.options.toMax);
                    _this.coords.p_to_fake = convertToFakePercent(_this.coords.p_to_real);
                    break;
            }
            if (_this.options.type === "single") {
                _this.coords.p_bar_x = (_this.coords.p_handle / 2);
                _this.coords.p_bar_w = _this.coords.p_single_fake;
                _this.result.from_percent = _this.coords.p_single_real;
                _this.result.from = convertToValue(_this.coords.p_single_real);
                _this.result.from_pretty = _prettify(_this.result.from);
                if (_this.options.values.length) {
                    _this.result.from_value = _this.options.values[_this.result.from];
                }
            } else {
                _this.coords.p_bar_x = toFixed(_this.coords.p_from_fake + (_this.coords.p_handle / 2));
                _this.coords.p_bar_w = toFixed(_this.coords.p_to_fake - _this.coords.p_from_fake);
                _this.result.from_percent = _this.coords.p_from_real;
                _this.result.from = convertToValue(_this.coords.p_from_real);
                _this.result.from_pretty = _prettify(_this.result.from);
                _this.result.to_percent = _this.coords.p_to_real;
                _this.result.to = convertToValue(_this.coords.p_to_real);
                _this.result.to_pretty = _prettify(_this.result.to);
                if (_this.options.values.length) {
                    _this.result.from_value = _this.options.values[_this.result.from];
                    _this.result.to_value = _this.options.values[_this.result.to];
                }
            }
            calcMinMax();
            calcLabels();
        };
        /**
         * calculates pointer X in percent
         */
        const calcPointerPercent = function () {
            if (!_this.coords.w_rs) {
                _this.coords.p_pointer = 0;
                return;
            }
            if (_this.coords.x_pointer < 0 || isNaN(_this.coords.x_pointer)) {
                _this.coords.x_pointer = 0;
            } else if (_this.coords.x_pointer > _this.coords.w_rs) {
                _this.coords.x_pointer = _this.coords.w_rs;
            }
            _this.coords.p_pointer = toFixed(_this.coords.x_pointer / _this.coords.w_rs * 100);
        };
        const convertToRealPercent = function (fake) {
            const full = 100 - _this.coords.p_handle;
            return fake / full * 100;
        };
        const convertToFakePercent = function (real) {
            const full = 100 - _this.coords.p_handle;
            return real / 100 * full;
        };
        const getHandleX = function () {
            const max = 100 - _this.coords.p_handle;
            let x = toFixed(_this.coords.p_pointer - _this.coords.p_gap);
            if (x < 0) {
                x = 0;
            } else if (x > max) {
                x = max;
            }
            return x;
        };
        const calcHandlePercent = function () {
            if (_this.options.type === "single") {
                _this.coords.w_handle = _this.cache.s_single.offsetWidth;
            } else {
                _this.coords.w_handle = _this.cache.s_from.offsetWidth;
            }
            _this.coords.p_handle = toFixed(_this.coords.w_handle / _this.coords.w_rs * 100);
        };
        /**
         * Find closest handle to pointer click
         *
         * @param real_x {Number}
         * @returns {String}
         */
        const chooseHandle = function (real_x) {
            if (_this.options.type === "single") {
                return "single";
            } else {
                const m_point = _this.coords.p_from_real + ((_this.coords.p_to_real - _this.coords.p_from_real) / 2);
                if (real_x >= m_point) {
                    return _this.options.toStick ? "from" : "to";
                } else {
                    return _this.options.fromStick ? "to" : "from";
                }
            }
        };
        /**
         * Measure Min and Max labels width in percent
         */
        const calcMinMax = function () {
            if (!_this.coords.w_rs) {
                return;
            }
            _this.labels.p_min = _this.labels.w_min / _this.coords.w_rs * 100;
            _this.labels.p_max = _this.labels.w_max / _this.coords.w_rs * 100;
        };
        /**
         * Measure labels width and X in percent
         */
        const calcLabels = function () {
            if (!_this.coords.w_rs || _this.options.hideLabelSlider) {
                return;
            }
            if (_this.options.type === "single") {
                _this.labels.w_single = _this.cache.single.offsetWidth;
                _this.labels.p_single_fake = _this.labels.w_single / _this.coords.w_rs * 100;
                _this.labels.p_single_left = _this.coords.p_single_fake + (_this.coords.p_handle / 2) - (_this.labels.p_single_fake / 2);
                _this.labels.p_single_left = checkEdges(_this.labels.p_single_left, _this.labels.p_single_fake);
            } else {
                _this.labels.w_from = _this.cache.from.offsetWidth;
                _this.labels.p_from_fake = _this.labels.w_from / _this.coords.w_rs * 100;
                _this.labels.p_from_left = _this.coords.p_from_fake + (_this.coords.p_handle / 2) - (_this.labels.p_from_fake / 2);
                _this.labels.p_from_left = toFixed(_this.labels.p_from_left);
                _this.labels.p_from_left = checkEdges(_this.labels.p_from_left, _this.labels.p_from_fake);
                _this.labels.w_to = _this.cache.to.offsetWidth;
                _this.labels.p_to_fake = _this.labels.w_to / _this.coords.w_rs * 100;
                _this.labels.p_to_left = _this.coords.p_to_fake + (_this.coords.p_handle / 2) - (_this.labels.p_to_fake / 2);
                _this.labels.p_to_left = toFixed(_this.labels.p_to_left);
                _this.labels.p_to_left = checkEdges(_this.labels.p_to_left, _this.labels.p_to_fake);
                _this.labels.w_single = _this.cache.single.offsetWidth;
                _this.labels.p_single_fake = _this.labels.w_single / _this.coords.w_rs * 100;
                _this.labels.p_single_left = ((_this.labels.p_from_left + _this.labels.p_to_left + _this.labels.p_to_fake) / 2) - (_this.labels.p_single_fake / 2);
                _this.labels.p_single_left = toFixed(_this.labels.p_single_left);
                _this.labels.p_single_left = checkEdges(_this.labels.p_single_left, _this.labels.p_single_fake);
            }
        };
        /**
         * Main function called in request animation frame
         * to update everything
         */
        const updateScene = function () {
            if (_this.rafId) {
                cancelAnimationFrame(_this.rafId);
                _this.rafId = null;
            }
            clearTimeout(_this.updateTm);
            _this.updateTm = null;
            if (!_this.options) {
                return;
            }
            drawHandles();
            if (_this.isActive) {
                _this.rafId = requestAnimationFrame(updateScene);
            } else {
                _this.updateTm = setTimeout(updateScene, 300);
            }
        };
        /**
         * Draw handles
         */
        const drawHandles = function () {
            _this.coords.w_rs = _this.cache.label.offsetWidth;
            if (!_this.coords.w_rs) {
                return;
            }
            if (_this.coords.w_rs !== _this.coords.w_rs_old) {
                _this.target = "base";
                _this.isResize = true;
            }
            if (_this.coords.w_rs !== _this.coords.w_rs_old || _this.forceRedraw) {
                setMinMax();
                calc(true);
                drawLabels();
                if (_this.options.grid) {
                    calcGridMargin();
                    calcGridLabels();
                }
                _this.forceRedraw = true;
                _this.coords.w_rs_old = _this.coords.w_rs;
                drawShadow();
            }
            if (!_this.coords.w_rs) {
                return;
            }
            if (!_this.dragging && !_this.forceRedraw && !_this.isKey) {
                return;
            }
            if (_this.oldFrom !== _this.result.from || _this.oldTo !== _this.result.to || _this.forceRedraw || _this.isKey) {
                drawLabels();
                _this.cache.bar.style.left = _this.coords.p_bar_x + "%";
                _this.cache.bar.style.width = _this.coords.p_bar_w + "%";
                if (_this.options.type === "single") {
                    _this.cache.bar.style.left = "0";
                    _this.cache.bar.style.width = _this.coords.p_bar_w + _this.coords.p_bar_x + "%";
                    _this.cache.s_single.style.left = _this.coords.p_single_fake + "%";
                    _this.cache.single.style.left = _this.labels.p_single_left + "%";
                } else {
                    _this.cache.s_from.style.left = _this.coords.p_from_fake + "%";
                    _this.cache.s_to.style.left = _this.coords.p_to_fake + "%";
                    if (_this.oldFrom !== _this.result.from || _this.forceRedraw) {
                        _this.cache.from.style.left = _this.labels.p_from_left + "%";
                    }
                    if (_this.oldTo !== _this.result.to || _this.forceRedraw) {
                        _this.cache.to.style.left = _this.labels.p_to_left + "%";
                    }
                    _this.cache.single.style.left = _this.labels.p_single_left + "%";
                }
                writeToInput();
                if ((_this.oldFrom !== _this.result.from || _this.oldTo !== _this.result.to) && !_this.isStart) {
                    _this.cache.targetDom.dispatchEvent(new Event("change"));
                    _this.cache.targetDom.dispatchEvent(new Event("input"));
                }
                _this.oldFrom = _this.result.from;
                _this.oldTo = _this.result.to;
                if (!_this.isResize && !_this.isUpdate && !_this.isStart && !_this.isFinish) {
                    callOnChange();
                }
                if (_this.isKey || _this.isClick) {
                    _this.isKey = false;
                    _this.isClick = false;
                    callOnFinish();
                }
                _this.isUpdate = false;
                _this.isResize = false;
                _this.isFinish = false;
            }
            _this.isStart = false;
            _this.isKey = false;
            _this.isClick = false;
            _this.forceRedraw = false;
        };
        /**
         * Draw labels
         * measure labels collisions
         * collapse close labels
         */
        const drawLabels = function () {
            if (!_this.options) {
                return;
            }
            const values_num = _this.options.values.length,
                p_values = _this.options.pValues;
            let text_single,
                text_from,
                text_to,
                from_pretty,
                to_pretty;
            if (_this.options.hideLabelSlider) {
                return;
            }
            if (_this.options.type === "single") {
                if (values_num) {
                    text_single = decorate(p_values[_this.result.from]);
                    _this.cache.single.innerHTML = text_single;
                } else {
                    from_pretty = _prettify(_this.result.from);
                    text_single = decorate(from_pretty, _this.result.from);
                    _this.cache.single.innerHTML = text_single;
                }
                calcLabels();
                if (_this.labels.p_single_left < _this.labels.p_min + 1) {
                    _this.cache.min.style.visibility = "hidden";
                } else {
                    _this.cache.min.style.visibility = "visible";
                }
                if (_this.labels.p_single_left + _this.labels.p_single_fake > 100 - _this.labels.p_max - 1) {
                    _this.cache.max.style.visibility = "hidden";
                } else {
                    _this.cache.max.style.visibility = "visible";
                }
            } else {
                if (values_num) {
                    if (_this.options.decorateBoth) {
                        text_single = decorate(p_values[_this.result.from]);
                        text_single += _this.options.valuesSeparator;
                        text_single += decorate(p_values[_this.result.to]);
                    } else {
                        text_single = decorate(p_values[_this.result.from] + _this.options.valuesSeparator + p_values[_this.result.to]);
                    }
                    text_from = decorate(p_values[_this.result.from]);
                    text_to = decorate(p_values[_this.result.to]);
                    _this.cache.single.innerHTML = text_single;
                    _this.cache.from.innerHTML = text_from;
                    _this.cache.to.innerHTML = text_to;
                } else {
                    from_pretty = _prettify(_this.result.from);
                    to_pretty = _prettify(_this.result.to);
                    if (_this.options.decorateBoth) {
                        text_single = decorate(from_pretty, _this.result.from);
                        text_single += _this.options.valuesSeparator;
                        text_single += decorate(to_pretty, _this.result.to);
                    } else {
                        text_single = decorate(from_pretty + _this.options.valuesSeparator + to_pretty, _this.result.to);
                    }
                    text_from = decorate(from_pretty, _this.result.from);
                    text_to = decorate(to_pretty, _this.result.to);
                    _this.cache.single.innerHTML = text_single;
                    _this.cache.from.innerHTML = text_from;
                    _this.cache.to.innerHTML = text_to;
                }
                calcLabels();
                const min = Math.min(_this.labels.p_single_left, _this.labels.p_from_left),
                    single_left = _this.labels.p_single_left + _this.labels.p_single_fake,
                    to_left = _this.labels.p_to_left + _this.labels.p_to_fake;
                let max = Math.max(single_left, to_left);
                if (_this.labels.p_from_left + _this.labels.p_from_fake >= _this.labels.p_to_left) {
                    _this.cache.from.style.visibility = "hidden";
                    _this.cache.to.style.visibility = "hidden";
                    _this.cache.single.style.visibility = "visible";
                    if (_this.result.from === _this.result.to) {
                        if (_this.target === "from") {
                            _this.cache.from.style.visibility = "visible";
                        } else if (_this.target === "to") {
                            _this.cache.to.style.visibility = "visible";
                        } else if (!_this.target) {
                            _this.cache.from.style.visibility = "visible";
                        }
                        _this.cache.single.style.visibility = "hidden";
                        max = to_left;
                    } else {
                        _this.cache.from.style.visibility = "hidden";
                        _this.cache.to.style.visibility = "hidden";
                        _this.cache.single.style.visibility = "visible";
                        max = Math.max(single_left, to_left);
                    }
                } else {
                    _this.cache.from.style.visibility = "visible";
                    _this.cache.to.style.visibility = "visible";
                    _this.cache.single.style.visibility = "hidden";
                }
                min < _this.labels.p_min + 1 ? _this.cache.min.style.visibility = "hidden" : _this.cache.min.style.visibility = "visible";
                max > 100 - _this.labels.p_max - 1 ? _this.cache.max.style.visibility = "hidden" : _this.cache.max.style.visibility = "visible";
            }
        };
        /**
         * Draw shadow intervals
         */
        const drawShadow = function () {
            const o = _this.options,
                c = _this.cache,
                is_from_min = typeof o.fromMin === "number" && !isNaN(o.fromMin),
                is_from_max = typeof o.fromMax === "number" && !isNaN(o.fromMax),
                is_to_min = typeof o.toMin === "number" && !isNaN(o.toMin),
                is_to_max = typeof o.toMax === "number" && !isNaN(o.toMax);
            let from_min,
                from_max,
                to_min,
                to_max;
            if (o.type === "single") {
                if (o.fromShadow && (is_from_min || is_from_max)) {
                    from_min = convertToPercent(is_from_min ? o.fromMin : o.min);
                    from_max = convertToPercent(is_from_max ? o.fromMax : o.max) - from_min;
                    from_min = toFixed(from_min - (_this.coords.p_handle / 100 * from_min));
                    from_max = toFixed(from_max - (_this.coords.p_handle / 100 * from_max));
                    from_min = from_min + (_this.coords.p_handle / 2);
                    c.shad_single.style.display = "block";
                    c.shad_single.style.left = from_min + "%";
                    c.shad_single.style.width = from_max + "%";
                } else {
                    c.shad_single.style.display = "none";
                }
            } else {
                if (o.fromShadow && (is_from_min || is_from_max)) {
                    from_min = convertToPercent(is_from_min ? o.fromMin : o.min);
                    from_max = convertToPercent(is_from_max ? o.fromMax : o.max) - from_min;
                    from_min = toFixed(from_min - (_this.coords.p_handle / 100 * from_min));
                    from_max = toFixed(from_max - (_this.coords.p_handle / 100 * from_max));
                    from_min = from_min + (_this.coords.p_handle / 2);
                    c.shad_from.style.display = "block";
                    c.shad_from.style.left = from_min + "%";
                    c.shad_from.style.width = from_max + "%";
                } else {
                    c.shad_from.style.display = "none";
                }
                if (o.toShadow && (is_to_min || is_to_max)) {
                    to_min = convertToPercent(is_to_min ? o.toMin : o.min);
                    to_max = convertToPercent(is_to_max ? o.toMax : o.max) - to_min;
                    to_min = toFixed(to_min - (_this.coords.p_handle / 100 * to_min));
                    to_max = toFixed(to_max - (_this.coords.p_handle / 100 * to_max));
                    to_min = to_min + (_this.coords.p_handle / 2);
                    c.shad_to.style.display = "block";
                    c.shad_to.style.left = to_min + "%";
                    c.shad_to.style.width = to_max + "%";
                } else {
                    c.shad_to.style.display = "none";
                }
            }
        };
        /**
         * Write values to input targetDom
         */
        const writeToInput = function () {
            if (_this.options.type === "single") {
                if (_this.options.values.length) {
                    _this.cache.targetDom.setAttribute("value", _this.result.from_value);
                } else {
                    _this.cache.targetDom.setAttribute("value", _this.result.from);
                }
                _this.cache.targetDom.dataset.from = _this.result.from;
            } else {
                if (_this.options.values.length) {
                    _this.cache.targetDom.setAttribute("value", _this.result.from_value + _this.options.inputValuesSeparator + _this.result.to_value);
                } else {
                    _this.cache.targetDom.setAttribute("value", _this.result.from + _this.options.inputValuesSeparator + _this.result.to);
                }
                _this.cache.targetDom.dataset.from = _this.result.from;
                _this.cache.targetDom.dataset.to = _this.result.to;
            }
        };
        const callOnStart = function () {
            writeToInput();
            if (_this.options.onStart && typeof _this.options.onStart === "function") {
                if (_this.options.scope) {
                    _this.options.onStart.call(_this.options.scope, _this.result);
                } else {
                    _this.options.onStart(_this.result);
                }
            }
        };
        const callOnChange = function () {
            writeToInput();
            if (_this.options.onChange && typeof _this.options.onChange === "function") {
                if (_this.options.scope) {
                    _this.options.onChange.call(_this.options.scope, _this.result);
                } else {
                    _this.options.onChange(_this.result);
                }
            }
        };
        const callOnFinish = function () {
            writeToInput();
            if (_this.options.onFinish && typeof _this.options.onFinish === "function") {
                if (_this.options.scope) {
                    _this.options.onFinish.call(_this.options.scope, _this.result);
                } else {
                    _this.options.onFinish(_this.result);
                }
            }
        };
        const callOnUpdate = function () {
            writeToInput();
            if (_this.options.onUpdate && typeof _this.options.onUpdate === "function") {
                if (_this.options.scope) {
                    _this.options.onUpdate.call(_this.options.scope, _this.result);
                } else {
                    _this.options.onUpdate(_this.result);
                }
            }
        };
        this.toggleInput = function () {
            this.cache.targetDom.classList.toggle("ax-range-input");
            if (this.hasTabIndex) {
                this.cache.targetDom.setAttribute("tabindex", "-1");
            } else {
                this.cache.targetDom.removeAttribute("tabindex");
            }
            this.hasTabIndex = !this.hasTabIndex;
        };
        /**
         * Convert real value to percent
         *
         * @param value {Number} X in real
         * @param no_min {boolean=} don't use min value
         * @returns {Number} X in percent
         */
        const convertToPercent = function (value, no_min) {
            let diapason = _this.options.max - _this.options.min,
                one_percent = diapason / 100,
                val, percent;
            if (!diapason) {
                _this.noDiapason = true;
                return 0;
            }
            if (no_min) {
                val = value;
            } else {
                val = value - _this.options.min;
            }
            percent = val / one_percent;
            return toFixed(percent);
        };
        /**
         * Convert percent to real values
         *
         * @param percent {Number} X in percent
         * @returns {Number} X in real
         */
        const convertToValue = function (percent) {
            let min = _this.options.min,
                max = _this.options.max,
                min_decimals = min.toString().split(".")[1],
                max_decimals = max.toString().split(".")[1],
                min_length, max_length,
                avg_decimals = 0,
                abs = 0;
            if (percent === 0) {
                return _this.options.min;
            }
            if (percent === 100) {
                return _this.options.max;
            }
            if (min_decimals) {
                min_length = min_decimals.length;
                avg_decimals = min_length;
            }
            if (max_decimals) {
                max_length = max_decimals.length;
                avg_decimals = max_length;
            }
            if (min_length && max_length) {
                avg_decimals = (min_length >= max_length) ? min_length : max_length;
            }
            if (min < 0) {
                abs = Math.abs(min);
                min = +(min + abs).toFixed(avg_decimals);
                max = +(max + abs).toFixed(avg_decimals);
            }
            let number = ((max - min) / 100 * percent) + min,
                string = _this.options.step.toString().split(".")[1],
                _result;
            if (string) {
                number = +number.toFixed(string.length);
            } else {
                number = number / _this.options.step;
                number = number * _this.options.step;
                number = +number.toFixed(0);
            }
            if (abs) {
                number -= abs;
            }
            string ? _result = +number.toFixed(string.length) : _result = toFixed(number);
            if (_result < _this.options.min) {
                _result = _this.options.min;
            } else if (_result > _this.options.max) {
                _result = _this.options.max;
            }
            return _result;
        };
        /**
         * Round percent value with step
         *
         * @param percent {Number}
         * @returns percent {Number} rounded
         */
        const calcWithStep = function (percent) {
            let rounded = Math.round(percent / _this.coords.p_step) * _this.coords.p_step;
            if (rounded > 100) {
                rounded = 100;
            }
            if (percent === 100) {
                rounded = 100;
            }
            return toFixed(rounded);
        };
        const checkMinInterval = function (p_current, p_next, type) {
            let o = _this.options, current, next;
            if (!o.minInterval) {
                return p_current;
            }
            current = convertToValue(p_current);
            next = convertToValue(p_next);
            if (type === "from") {
                if (next - current < o.minInterval) {
                    current = next - o.minInterval;
                }
            } else {
                if (current - next < o.minInterval) {
                    current = next + o.minInterval;
                }
            }
            return convertToPercent(current);
        };
        const checkMaxInterval = function (p_current, p_next, type) {
            let o = _this.options, current, next;
            if (!o.maxInterval) {
                return p_current;
            }
            current = convertToValue(p_current);
            next = convertToValue(p_next);
            if (type === "from") {
                if (next - current > o.maxInterval) {
                    current = next - o.maxInterval;
                }
            } else {
                if (current - next > o.maxInterval) {
                    current = next + o.maxInterval;
                }
            }
            return convertToPercent(current);
        };
        const checkDiapason = function (p_num, min, max) {
            let num = convertToValue(p_num);
            typeof min !== 'number' ? min = _this.options.min : min;
            typeof max !== 'number' ? max = _this.options.max : max;
            num < min ? num = min : num;
            num > max ? num = max : num;
            return convertToPercent(num);
        };
        const toFixed = function (num) {
            num = num.toFixed(20);
            return +num;
        };
        const _prettify = function (num) {
            if (!_this.options.prettifyEnabled) {
                return num;
            }
            if (_this.options.prettify && typeof _this.options.prettify === "function") {
                return _this.options.prettify(num);
            } else {
                return prettify(num);
            }
        };
        const prettify = function (num) {
            return num.toString().replace(/(\d{1,3}(?=(?:\d\d\d)+(?!\d)))/g, "$1" + _this.options.prettifySeparator);
        };
        const checkEdges = function (left, width) {
            if (!_this.options.forceEdges) return toFixed(left);
            left < 0 ? left = 0 : left > 100 - width ? left = 100 - width : left;
            return toFixed(left);
        };
        this.validate = function () {
            let o = this.options,
                r = this.result,
                v = o.values,
                vl = v.length,
                value,
                i;
            if (typeof o.min === "string") o.min = +o.min;
            if (typeof o.max === "string") o.max = +o.max;
            if (typeof o.from === "string") o.from = +o.from;
            if (typeof o.to === "string") o.to = +o.to;
            if (typeof o.step === "string") o.step = +o.step;
            if (typeof o.fromMin === "string") o.fromMin = +o.fromMin;
            if (typeof o.fromMax === "string") o.fromMax = +o.fromMax;
            if (typeof o.toMin === "string") o.toMin = +o.toMin;
            if (typeof o.toMax === "string") o.toMax = +o.toMax;
            if (typeof o.gridNum === "string") o.gridNum = +o.gridNum;
            if (o.max < o.min) {
                o.max = o.min;
            }
            if (vl) {
                o.pValues = [];
                o.min = 0;
                o.max = vl - 1;
                o.step = 1;
                o.gridNum = o.max;
                o.gridSnap = true;
                for (i = 0; i < vl; i++) {
                    value = +v[i];
                    if (!isNaN(value)) {
                        v[i] = value;
                        value = _prettify(value);
                    } else {
                        value = v[i];
                    }
                    o.pValues.push(value);
                }
            }
            if (typeof o.from !== "number" || isNaN(o.from)) o.from = o.min;
            if (typeof o.to !== "number" || isNaN(o.to)) o.to = o.max;
            if (o.type === "single") {
                if (o.from < o.min) o.from = o.min;
                if (o.from > o.max) o.from = o.max;
            } else {
                if (o.from < o.min) o.from = o.min;
                if (o.from > o.max) o.from = o.max;
                if (o.to < o.min) o.to = o.min;
                if (o.to > o.max) o.to = o.max;
                if (_this.update_check.from) {
                    if (_this.update_check.from !== o.from) {
                        if (o.from > o.to) o.from = o.to;
                    }
                    if (_this.update_check.to !== o.to) {
                        if (o.to < o.from) o.to = o.from;
                    }
                }
                if (o.from > o.to) o.from = o.to;
                if (o.to < o.from) o.to = o.from;
            }
            if (typeof o.step !== "number" || isNaN(o.step) || !o.step || o.step < 0) {
                o.step = 1;
            }
            if (typeof o.fromMin === "number" && o.from < o.fromMin) {
                o.from = o.fromMin;
            }
            if (typeof o.fromMax === "number" && o.from > o.fromMax) {
                o.from = o.fromMax;
            }
            if (typeof o.toMin === "number" && o.to < o.toMin) {
                o.to = o.toMin;
            }
            if (typeof o.toMax === "number" && o.from > o.toMax) {
                o.to = o.toMax;
            }
            if (r) {
                if (r.min !== o.min) r.min = o.min;
                if (r.max !== o.max) r.max = o.max;
                if (r.from < r.min || r.from > r.max) r.from = o.from;
                if (r.to < r.min || r.to > r.max) r.to = o.to;
            }
            if (typeof o.minInterval !== "number" || isNaN(o.minInterval) || !o.minInterval || o.minInterval < 0) {
                o.minInterval = 0;
            }
            if (typeof o.maxInterval !== "number" || isNaN(o.maxInterval) || !o.maxInterval || o.maxInterval < 0) {
                o.maxInterval = 0;
            }
            if (o.minInterval && o.minInterval > o.max - o.min) {
                o.minInterval = o.max - o.min;
            }
            if (o.maxInterval && o.maxInterval > o.max - o.min) {
                o.maxInterval = o.max - o.min;
            }
        };
        const decorate = function (num, original) {
            let decorated = "",
                o = _this.options;
            if (o.prefix) {
                decorated += o.prefix;
            }
            decorated += num;
            if (o.maxPostfix) {
                if (o.values.length && num === o.pValues[o.max]) {
                    decorated += o.maxPostfix;
                    if (o.postfix) {
                        decorated += " ";
                    }
                } else if (original === o.max) {
                    decorated += o.maxPostfix;
                    if (o.postfix) {
                        decorated += " ";
                    }
                }
            }
            if (o.postfix) {
                decorated += o.postfix;
            }
            return decorated;
        };
        const updateFrom = function () {
            _this.result.from = _this.options.from;
            _this.result.from_percent = convertToPercent(_this.result.from);
            _this.result.from_pretty = _prettify(_this.result.from);
            if (_this.options.values) {
                _this.result.from_value = _this.options.values[_this.result.from];
            }
        };
        const updateTo = function () {
            _this.result.to = _this.options.to;
            _this.result.to_percent = convertToPercent(_this.result.to);
            _this.result.to_pretty = _prettify(_this.result.to);
            if (_this.options.values) {
                _this.result.to_value = _this.options.values[_this.result.to];
            }
        };
        this.updateResult = function () {
            this.result.min = this.options.min;
            this.result.max = this.options.max;
            updateFrom();
            updateTo();
        };
        const appendGrid = function () {
            if (!_this.options.grid) {
                return;
            }
            let o = _this.options,
                i, z,
                total = o.max - o.min,
                big_num = o.gridNum,
                big_p = 0,
                big_w = 0,
                small_max = 4,
                local_small_max,
                small_p,
                small_w = 0,
                _result,
                html = '';
            calcGridMargin();
            if (o.gridSnap) {
                big_num = total / o.step;
            }
            if (big_num > 50) big_num = 50;
            big_p = toFixed(100 / big_num);
            if (big_num > 4) {
                small_max = 3;
            }
            if (big_num > 7) {
                small_max = 2;
            }
            if (big_num > 14) {
                small_max = 1;
            }
            if (big_num > 28) {
                small_max = 0;
            }
            for (i = 0; i < big_num + 1; i++) {
                local_small_max = small_max;
                big_w = toFixed(big_p * i);
                if (big_w > 100) {
                    big_w = 100;
                }
                _this.coords.big[i] = big_w;
                small_p = (big_w - (big_p * (i - 1))) / (local_small_max + 1);
                for (z = 1; z <= local_small_max; z++) {
                    if (big_w === 0) {
                        break;
                    }
                    small_w = toFixed(big_w - (small_p * z));
                    html += '<span class="ax-range-grid-pol ax-small" style="left: ' + small_w + '%"></span>';
                }
                html += '<span class="ax-range-grid-pol" style="left: ' + big_w + '%"></span>';
                _result = convertToValue(big_w);
                if (o.values.length) {
                    _result = o.pValues[_result];
                } else {
                    _result = _prettify(_result);
                }
                html += '<span class="ax-range-grid-text ax-grid-text-' + i + '" style="left: ' + big_w + '%">' + _result + '</span>';
            }
            _this.coords.big_num = Math.ceil(big_num + 1);
            _this.cache.cont.classList.add("ax-with-grid");
            _this.cache.grid.innerHTML = html;
            cacheridLabels();
        };
        const cacheridLabels = function () {
            for (let i = 0; i < _this.coords.big_num; i++) {
                _this.cache.grid_labels.push(_this.cache.grid.querySelector(".ax-grid-text-" + i));
            }
            calcGridLabels();
        };
        const calcGridLabels = function () {
            const start = [], finish = [],
                num = _this.coords.big_num;
            for (let i = 0; i < num; i++) {
                _this.coords.big_w[i] = _this.cache.grid_labels[i].offsetWidth;
                _this.coords.big_p[i] = toFixed(_this.coords.big_w[i] / _this.coords.w_rs * 100);
                _this.coords.big_x[i] = toFixed(_this.coords.big_p[i] / 2);
                start[i] = toFixed(_this.coords.big[i] - _this.coords.big_x[i]);
                finish[i] = toFixed(start[i] + _this.coords.big_p[i]);
            }
            if (_this.options.forceEdges) {
                if (start[0] < -_this.coords.grid_gap) {
                    start[0] = -_this.coords.grid_gap;
                    finish[0] = toFixed(start[0] + _this.coords.big_p[0]);
                    _this.coords.big_x[0] = _this.coords.grid_gap;
                }
                if (finish[num - 1] > 100 + _this.coords.grid_gap) {
                    finish[num - 1] = 100 + _this.coords.grid_gap;
                    start[num - 1] = toFixed(finish[num - 1] - _this.coords.big_p[num - 1]);
                    _this.coords.big_x[num - 1] = toFixed(_this.coords.big_p[num - 1] - _this.coords.grid_gap);
                }
            }
            calcGridCollision(2, start, finish);
            calcGridCollision(4, start, finish);
            for (let i = 0; i < num; i++) {
                const label = _this.cache.grid_labels[i];
                if (_this.coords.big_x[i] !== Number.POSITIVE_INFINITY) {
                    label.style.marginLeft = -_this.coords.big_x[i] + "%";
                }
            }
        };
        const calcGridCollision = function (step, start, finish) {
            const num = _this.coords.big_num;
            for (let i = 0; i < num; i += step) {
                let next_i = i + (step / 2);
                if (next_i >= num) {
                    break;
                }
                const label = _this.cache.grid_labels[next_i];
                if (finish[i] <= start[next_i]) {
                    label.style.visibility = "visible";
                } else {
                    label.style.visibility = "hidden";
                }
            }
        };
        const calcGridMargin = function () {
            if (!_this.options.gridMargin) {
                return;
            }
            _this.coords.w_rs = _this.cache.label.offsetWidth;
            if (!_this.coords.w_rs) {
                return;
            }
            if (_this.options.type === "single") {
                _this.coords.w_handle = _this.cache.s_single.offsetWidth;
            } else {
                _this.coords.w_handle = _this.cache.s_from.offsetWidth;
            }
            _this.coords.p_handle = toFixed(_this.coords.w_handle / _this.coords.w_rs * 100);
            _this.coords.grid_gap = toFixed((_this.coords.p_handle / 2) - 0.1);
            _this.cache.grid.style.width = toFixed(100 - _this.coords.p_handle) + "%";
            _this.cache.grid.style.left = _this.coords.grid_gap + "%";
        };
        this.init();
    }
    init() {
        this.validate();
        this.ready();
        if (this.referName) {
            if (axIsEmpty(axRanges)) {
                axRanges.push({ name: this.referName, instance: this });
            } else {
                for (let i = 0; i < axRanges.length; i++) {
                    if (axRanges[i].name == this.referName) {
                        axRanges[i].instance = this;
                        break;
                    } else {
                        axRanges.push({ name: this.referName, instance: this });
                    }
                }
            }
        }
    }
    update(options, callback) {
        if (!this.targetDom) {
            return;
        }
        this.isUpdate = true;
        this.options.from = this.result.from;
        this.options.to = this.result.to;
        this.update_check.from = this.result.from;
        this.update_check.to = this.result.to;
        this.options = Object.assign(this.options, options);
        this.validate();
        this.updateResult(options);
        this.toggleInput();
        this.remove();
        this.ready(true);
        'updated' in this.handlers ? this.emit('updated', '') : null;
        callback && callback.call(this);
        return this;
    }
    reset(callback) {
        if (!this.targetDom) {
            return;
        }
        this.updateResult();
        'reset' in this.handlers ? this.emit('reset', '') : null;
        callback && callback.call(this);
        this.update();
    }
    destroy(callback) {
        if (!this.targetDom) {
            return;
        }
        this.toggleInput();
        this.targetDom.removeAttribute("readonly");
        this.remove();
        this.targetDom = null;
        this.options = null;
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        callback && callback.call(this);
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axRange]').forEach(element => {
        new axRange(element);
    });
})();
/*!
 * 插件：分页；使用方法：new axPagination('#id',{参数})
 * 从现有的list中自动创建分页
 * 从已知的数组创建列表并分页
 * 可追加列表item数量并重新渲染分页
 * 分页节点能自动在列表下方创建，也可以在指定的dom创建
 */
class axPagination {
    constructor(targetDom, options) {
        this.options = axExtend({
            listDom: '',
            count: 10, 
            current: 1, 
            firstText: '首页', 
            prevText: '上一页', 
            nextText: '下一页', 
            lastText: '尾页', 
            allPages: false,
            data: [], 
            clickDelay: 200,
            template: '', 
            type: 'regular', 
            loadingMode: 'replace',
            className: '',
            lastDel: '', 
            async: '',
            ajaxType: 'post',
            delay: 0,
            dataExtend: '',
            onBeforeRendered: function (listArr) {
            },
            onRendered: function (current, pagesNum) {
            },
            onUpdate: function (current, pagesNum) {
            },
            onTurned: function (current, pagesNum) {
            }
        }, options, targetDom, this.constructor.name);
        this.targetExist = targetDom ? true : false;
        this.targetDom = targetDom ? axIdToDom(targetDom) : axAddElem('div', { class: this.options.className ? 'ax-pagination ' + this.options.className : 'ax-pagination' });
        if (this.dataType(this.options.data) == 'pageDom') {
            this.listDom = axIdToDom(this.options.data);
        } else if (this.options.listDom) {
            this.listDom = axIdToDom(this.options.listDom);
        } else {
            this.listDom = '';
        }
        this.handlers = {};
        this.preData = [];
        this.asyncData = []
        this.selectData = [];
        this.itemsNum = 0;
        this.pagesNum = 0;
        this.current = this.options.current;
        this.loadingDom = axAddElem('div', { class: 'ax-pageTurning' })
        if (!this.options.template) {
            this.template = '';
        } else {
            if (this.options.template.trim().substr(0, 1) == '#') {
                this.template = document.querySelector(this.options.template).innerHTML
            } else {
                this.template = this.options.template;
            }
        }
        this.pagesDom = axAddElem('div', { class: 'ax-core' });
        this.pageFirst = axAddElem('a', { href: '###', class: 'ax-first' }, this.options.firstText);
        this.pageLast = axAddElem('a', { href: '###', class: 'ax-last' }, this.options.lastText);
        this.pagePrev = axAddElem('a', { href: '###', class: 'ax-prev' }, this.options.prevText);
        this.pageNext = axAddElem('a', { href: '###', class: 'ax-next' }, this.options.nextText);
        this.pageTotal = axAddElem('span', { class: 'ax-total' });
        this.pageGo = axAddElem('span', { class: 'ax-gopage' });
        this.group = axAddElem('div', { class: 'ax-group' });
        this.renderedIndex = 0;
        this.init(this.options.data);
    }
    init(data) {
        let _this = this;
        if (axIsEmpty(data)) {
            this.listDom ? this.listDom.innerHTML = '' : null;
            this.targetDom.innerHTML = '';
            this.current = 1;
            this.pagesNum = 1;
            this.itemsNum = 0;
            return false;
        }
        if (this.dataType(data) == 'json') {
            if (!_this.template && this.listDom.nodeName != 'TBODY') {
                console.error('The template is required!');
                return false;
            }
            this.jsonAjax(data, function () {
                this.listDom ? this.renderList(1) : null;
                this.renderFinish();
            });
        } else if (this.dataType(data) == 'sql') {
            if (!this.template && this.listDom.nodeName != 'TBODY') {
                console.error('The template is required!');
                return false;
            }
            this.sqlAjax(this.current, function () {
                this.listDom ? this.renderList(1) : null;
                this.renderFinish();
            });
        } else {
            if (this.dataType(data) == 'sortList') {
                data.forEach(i => {
                    this.preData.push(i.dom);
                });
            } else if (this.dataType(data) == 'pureNode') {
                this.preData = [...data];
            } else if (this.dataType(data) == 'tplArray') {
                if (!this.template) {
                    console.error('The template is required!');
                    return false;
                }
                data.forEach(i => {
                    let item = axStrToDom(axTplEngine(this.template, i));
                    this.preData.push(item);
                });
            } else {
                this.preData = [...this.listDom.childNodes].filter(item => item.nodeType == 1);
            }
            this.getCurrent(this.preData);
            this.listDom ? this.renderList(this.current) : null;
            this.renderFinish();
        }
    }
    dataType(data) {
        let type = '';
        if (axType(data) == 'Array') {
            if (data[0].hasOwnProperty('dom')) {
                type = 'sortList';
            } else if (axType(data[0]).includes('Element')) {
                type = 'pureNode';
            } else {
                type = 'tplArray';
            }
        } else if (axType(data) == 'String') {
            if (this.options.async == 'json') {
                type = 'json';
            } else if (this.options.async == 'sql') {
                type = 'sql';
            } else {
                type = 'pageDom';
            }
        }
        return type;
    }
    renderTotal() {
        this.pageTotal.innerHTML = '共有' + this.pagesNum + '页, ' + this.itemsNum + '条数据';
    }
    renderFinish() {
        let _this = this;
        this.targetDom.removeAttribute('paging');
        this.renderPagesTotal(this.current, () => {
            this.renderTotal();
        });
        this.getPagination();
        if (this.listDom && !this.targetExist) {
            if (this.listDom.nodeName == 'TBODY') {
                this.listDom.parentElement.insertAdjacentElement('afterend', this.targetDom)
            } else {
                this.listDom.insertAdjacentElement('afterend', this.targetDom)
            }
        }
        this.pageFirst.onclick = axDebounce(function (e) {
            if (_this.current <= 1) {
                axPreventDefault(e);
            } else {
                _this.current = 1;
                _this.currentToRenderList(_this.current);
            }
        }, this.options.clickDelay);
        this.pageLast.onclick = axDebounce(function (e) {
            if (_this.current >= _this.pagesNum) {
                axPreventDefault(e);
            } else {
                _this.current = _this.pagesNum;
                _this.currentToRenderList(_this.current);
            }
        }, this.options.clickDelay);
        this.pagePrev.onclick = axDebounce(function (e) {
            if (_this.current <= 1) {
                axPreventDefault(e);
            } else {
                _this.current = _this.current - 1;
                _this.currentToRenderList(_this.current);
            }
        }, this.options.clickDelay);
        this.pageNext.onclick = axDebounce(function (e) {
            if (_this.current >= _this.pagesNum) {
                axPreventDefault(e);
            } else {
                _this.current = _this.current + 1;
                _this.currentToRenderList(_this.current);
            }
        }, this.options.clickDelay);
        this.renderedIndex++;
        this.options.onRendered && this.options.onRendered.call(this, this.current, this.pagesNum);
        'rendered' in this.handlers ? this.emit('rendered', this.current, this.pagesNum) : null;
    }
    currentFix(current, pagesNum = this.pagesNum) {
        if (!current) {
            return this.current;
        }
        if (current <= 1) {
            this.current = 1;
        } else if (current >= pagesNum) {
            this.current = pagesNum;
        } else {
            this.current = current;
        }
        return this.current;
    }
    getCurrent(data, current, pagesNum, itemsNum) {
        this.itemsNum = itemsNum ? itemsNum : data.length;
        if (pagesNum) {
            this.pagesNum = pagesNum;
        } else {
            let divisor = this.itemsNum / this.options.count;
            this.pagesNum = divisor % 1 === 0 ? divisor : Math.floor(divisor) + 1;
        }
        this.currentFix(current ? current : this.current, this.pagesNum);
    }
    renderList(current) {
        let fragment = document.createDocumentFragment();
        this.selectData = this.preData.slice(this.options.count * (current - 1), this.options.count * current);
        this.selectData.forEach((item, index) => {
            if (index + 1 == this.selectData.length && this.options.lastDel && item.querySelector(this.options.lastDel)) {
                item.removeChild(item.querySelector(this.options.lastDel))
            }
            fragment.appendChild(item);
        });
        this.options.onBeforeRendered && this.options.onBeforeRendered.call(this, this.selectData, this.asyncData);
        'beforeRendered' in this.handlers ? this.emit('beforeRendered', this.selectData, this.asyncData) : null;
        this.listDom.innerHTML = '';
        this.listDom.appendChild(fragment);
    }
    renderPagesTotal(current, callback) {
        let _this = this;
        current = this.currentFix(current);
        this.pagesDom.innerHTML = ''
        if (this.options.allPages) {
            for (let i = 1; i <= this.pagesNum; i++) {
                let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                this.pagesDom.appendChild(item);
            }
        } else {
            if (this.pagesNum < 11) {
                for (let i = 1; i <= this.pagesNum; i++) {
                    let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                    this.pagesDom.appendChild(item);
                }
            } else {
                if (current < 6) {
                    for (let i = 1; i <= 8; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                    this.pagesDom.appendChild(axAddElem('span', {}, '...'));
                    for (let i = this.pagesNum - 1; i <= this.pagesNum; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                } else if (this.pagesNum - current < 5) {
                    for (let i = 1; i <= 2; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                    this.pagesDom.appendChild(axAddElem('span', {}, '...'));
                    for (let i = this.pagesNum - 6; i <= this.pagesNum; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                } else {
                    for (let i = 1; i <= 2; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                    this.pagesDom.appendChild(axAddElem('span', {}, '...'));
                    for (let i = current - 2; i <= current + 2; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                    this.pagesDom.appendChild(axAddElem('span', {}, '...'));
                    for (let i = this.pagesNum - 1; i <= this.pagesNum; i++) {
                        let item = axAddElem('a', { href: '###', 'data-page': i }, i);
                        this.pagesDom.appendChild(item);
                    }
                }
            }
        }
        let pages = this.pagesDom.querySelectorAll('[data-page]');
        [...pages].forEach(item => {
            item.onclick = axDebounce(function () {
                _this.current = ~~item.dataset.page; 
                _this.currentToRenderList(_this.current);
            }, this.options.clickDelay);
        });
        this.setClass(current);
        callback && callback.call(this, current);
        return this.pagesDom;
    }
    setClass(current) {
        let pages = this.pagesDom.querySelectorAll('[data-page]'),
            page = [...pages].filter(item => ~~item.dataset.page == current)[0];
        page.classList.add('ax-active');
        if (~~page.dataset.page == 1) {
            this.pageFirst.classList.add('ax-disabled');
            this.pagePrev.classList.add('ax-disabled');
            if (this.pagesNum == 1) {
                this.pageLast.classList.add('ax-disabled');
                this.pageNext.classList.add('ax-disabled');
            } else {
                this.pageLast.classList.remove('ax-disabled');
                this.pageNext.classList.remove('ax-disabled');
            }
        } else if (~~page.dataset.page == this.pagesNum) {
            this.pageLast.classList.add('ax-disabled');
            this.pageNext.classList.add('ax-disabled');
            this.pageFirst.classList.remove('ax-disabled');
            this.pagePrev.classList.remove('ax-disabled');
        } else {
            this.pageFirst.classList.remove('ax-disabled');
            this.pagePrev.classList.remove('ax-disabled');
            this.pageLast.classList.remove('ax-disabled');
            this.pageNext.classList.remove('ax-disabled');
        }
    }
    getPagination() {
        let _this = this;
        let fragment = document.createDocumentFragment();
        this.pageGo.innerHTML = '跳到</span><input type="text"><button type="button" class="ax-btn">确定</button>';
        let goInput = this.pageGo.querySelector('input'),
            goBtn = this.pageGo.querySelector('button');
        goBtn.onclick = axDebounce(function () {
            let val = ~~goInput.value;
            if (val <= 1) {
                console.warn('The value is out of range,it has been fixed!');
                goInput.value = 1;
                _this.current = 1;
            } else if (val >= _this.pagesNum) {
                console.warn('The value is out of range,it has been fixed!');
                goInput.value = _this.pagesNum;
                _this.current = _this.pagesNum;
            } else {
                _this.current = val;
            }
            _this.currentToRenderList(_this.current);
        }, this.options.clickDelay);
        goInput.onkeyup = function (e) {
            if (e.code === 'Enter') {
                goBtn.click();
            }
        }
        if (this.options.type == 'regular') {
            fragment.appendChild(this.pageFirst);
            fragment.appendChild(this.pagePrev);
            fragment.appendChild(this.pagesDom);
            fragment.appendChild(this.pageNext);
            fragment.appendChild(this.pageLast);
        } else if (this.options.type == 'group') {
            this.group.appendChild(this.pageFirst);
            this.group.appendChild(this.pagePrev);
            this.group.appendChild(this.pagesDom);
            this.group.appendChild(this.pageNext);
            this.group.appendChild(this.pageLast);
            fragment.appendChild(this.group);
        } else if (this.options.type == 'simple') {
            fragment.appendChild(this.pagePrev);
            fragment.appendChild(this.pageNext);
        } else if (this.options.type == 'full') {
            fragment.appendChild(this.pageTotal);
            fragment.appendChild(this.pageFirst);
            fragment.appendChild(this.pagePrev);
            fragment.appendChild(this.pagesDom);
            fragment.appendChild(this.pageNext);
            fragment.appendChild(this.pageLast);
            fragment.appendChild(this.pageGo);
        } else if (this.options.type == 'pagesRight') {
            let left = axAddElem('div'),
                right = axAddElem('div', { class: 'ax-col ax-align-right' });
            this.targetDom.classList.add('ax-row');
            left.appendChild(this.pageTotal);
            right.appendChild(this.pageFirst);
            right.appendChild(this.pagePrev);
            right.appendChild(this.pagesDom);
            right.appendChild(this.pageNext);
            right.appendChild(this.pageLast);
            right.appendChild(this.pageGo);
            fragment.appendChild(left);
            fragment.appendChild(right);
        } else if (this.options.type == 'pagesLeft') {
            let right = axAddElem('div'),
                left = axAddElem('div', { class: 'ax-col ax-align-left' });
            this.targetDom.classList.add('ax-row');
            right.appendChild(this.pageTotal);
            left.appendChild(this.pageFirst);
            left.appendChild(this.pagePrev);
            left.appendChild(this.pagesDom);
            left.appendChild(this.pageNext);
            left.appendChild(this.pageLast);
            left.appendChild(this.pageGo);
            fragment.appendChild(left);
            fragment.appendChild(right);
        } else {
            fragment.appendChild(this.pagesDom);
        }
        this.targetDom.appendChild(fragment);
    }
    jsonAjax(data, callback) {
        let _this = this;
        axAjax({
            url: data,
            type: this.options.ajaxType,
            before: function (loading) {
                _this.listDom ? _this.listDom.innerHTML = '<div class="ax-pageTurning">' + loading + '</div>' : null;
            },
            success: function (content) {
                content.forEach((i, index) => {
                    let item, obj = { index: index };
                    if (!_this.template && _this.listDom.nodeName == 'TBODY') {
                        item = axAddElem('tr');
                        for (let k in i) {
                            let td = axAddElem('td', { name: k }, i[k])
                            item.appendChild(td);
                            obj.children = [];
                            obj.children.push({ dom: td, name: k, label: i[k].toString() });
                        }
                    } else {
                        item = axStrToDom(axTplEngine(_this.template, i));
                    }
                    obj.dom = item;
                    _this.asyncData.push(obj);
                    _this.preData.push(item);
                });
                _this.getCurrent(_this.preData);
                callback && callback.call(_this);
            }
        })
    }
    sqlAjax(current, callback) {
        let _this = this;
        axAjax({
            data: Object.assign({ count: this.options.count, current: current }, _this.options.dataExtend),
            url: this.options.data,
            type: this.options.ajaxType,
            before: function (loading) {
                if (_this.listDom) {
                    _this.loadingDom.style = '';
                    _this.loadingDom.innerHTML = loading;
                    if (_this.options.loadingMode == 'overlay') {
                        _this.loadingDom.classList.add('ax-overlay');
                    } else {
                        _this.listDom.innerHTML = '';
                        _this.listDom.appendChild(_this.loadingDom)
                    }
                    _this.listDom.insertAdjacentElement('afterbegin', _this.loadingDom);
                    axFadeIn(_this.loadingDom, 'flex');
                }
            },
            success: function (content) {
                if (typeof content != 'object') {
                    console.error('The type of content must be object!');
                    return false;
                }
                if (axIsEmpty(content.data)) {
                    _this.listDom ? _this.listDom.innerHTML = '' : null;
                    _this.targetDom.innerHTML = '';
                    return false;
                }
                _this.preData = [];
                _this.asyncData = [];
                content.data.forEach((i, index) => {
                    let item, obj = { index: index };
                    if (!_this.template && _this.listDom.nodeName == 'TBODY') {
                        item = axAddElem('tr');
                        obj.children = [];
                        for (let k in i) {
                            let td = axAddElem('td', { name: k }, i[k].toString());
                            item.appendChild(td);
                            obj.children.push({ dom: td, name: k, label: i[k].toString() });
                        }
                    } else {
                        item = axStrToDom(axTplEngine(_this.template, i));
                    }
                    obj.dom = item;
                    _this.asyncData.push(obj);
                    _this.preData.push(item);
                });
                _this.getCurrent(content.data, ~~content.current, ~~content.pagesNum, ~~content.itemsNum);
                callback && callback.call(_this);
            }
        })
    }
    currentToRenderList(current, callback) {
        let _this = this;
        if (_this.dataType(this.options.data) == 'sql') {
            this.sqlAjax(current, function () {
                if (_this.options.delay) {
                    setTimeout(function () {
                        _this.listDom ? _this.renderList(1) : null;
                    }, _this.options.delay)
                } else {
                    _this.listDom ? _this.renderList(1) : null;
                }
                this.options.onRendered && this.options.onRendered.call(this, this.current, this.pagesNum);
                'rendered' in _this.handlers ? _this.emit('rendered', _this.current, _this.pagesNum) : null;
            });
        } else {
            _this.listDom ? _this.renderList(current) : null;
            this.options.onRendered && this.options.onRendered.call(this, this.current, this.pagesNum);
            'rendered' in _this.handlers ? _this.emit('rendered', _this.current, _this.pagesNum) : null;
        }
        _this.renderPagesTotal(current, callback && callback.call(_this, current));
        this.options.onTurned && this.options.onTurned.call(this, this.current, this.pagesNum);
        'turned' in this.handlers ? this.emit('turned', this.current, this.pagesNum) : null;
    }
    first(callback) {
        this.current = 1;
        this.currentToRenderList(this.current);
        callback && callback.call(this, this.current, this.pagesNum);
        return this;
    }
    prev(callback) {
        if (this.current <= 1) {
            return false;
        } else {
            this.current = this.current - 1;
            this.currentToRenderList(this.current);
            callback && callback.call(this, this.current, this.pagesNum);
        }
        return this;
    }
    next(callback) {
        if (this.current >= this.pagesNum) {
            return false;
        } else {
            this.current = this.current + 1;
            this.currentToRenderList(this.current);
            callback && callback.call(this, this.current, this.pagesNum);
        }
        return this;
    }
    last(callback) {
        this.current = this.pagesNum;
        this.currentToRenderList(this.current);
        callback && callback.call(this, this.current, this.pagesNum);
        return this;
    }
    go(page, callback) {
        if (this.current <= 1 || this.current >= this.pagesNum) {
            console.error('The value is out of range!');
            return false;
        } else {
            this.current = ~~page;
            this.currentToRenderList(this.current);
            callback && callback.call(this, this.current, this.pagesNum);
        }
        return this;
    }
    info(callback) {
        let info = { current: this.current, pagesNum: this.pagesNum, count: this.options.count, itemsNum: this.itemsNum, selectData: this.selectData };
        callback && callback.call(this, info);
        return info;
    }
    updatePages(obj, type, callback) {
        if (!obj) {
            return false;
        }
        type = type || 'remove';
        let item;
        if (typeof obj === 'number') {
            item = this.preData[obj];
        } else {
            item = obj;
        }
        if (!item) {
            return false;
        }
        if (type === 'remove') {
            this.preData = this.preData.filter(i => i != item);
            this.getCurrent(this.preData, this.current, '', this.preData.length);
        } else if (type === 'addBefore') {
        } else if (type === 'addAfter') {
        } else {
        }
        this.currentToRenderList(this.current, () => {
            this.renderTotal();
        });
        callback && callback.call(this);
    }
    update(setting, mode, callback) {
        mode = mode || 'overwrite';
        this.options = axExtend(this.options, setting);
        this.current = this.options.current;
        this.targetDom.setAttribute('paging', '');
        this.targetDom.innerHTML = '';
        mode == 'overwrite' ? this.preData = [] : null;
        this.init(this.options.data);
        this.options.onUpdated && this.options.onUpdated.call(this, this.current, this.pagesNum);
        'updated' in this.handlers ? this.emit('updated', this.current, this.pagesNum) : null;
        callback && callback.call(this);
        return this;
    }
    updateData(data, mode, callback) {
        mode = mode || 'overwrite';
        this.targetDom.setAttribute('paging', '');
        this.targetDom.innerHTML = '';
        if (mode === 'overwrite') {
            this.preData = [];
            this.options.dataExtend = '';
        }
        if (typeof data === 'object' && data.url && data.hasOwnProperty('sql')) {
            this.options.data = data.url;
            this.options.dataExtend = data.sql;
        } else {
            this.options.data = data;
        }
        this.init(this.options.data);
        this.options.onUpdated && this.options.onUpdated.call(this, this.current, this.pagesNum);
        'updated' in this.handlers ? this.emit('updated', this.current, this.pagesNum) : null;
        callback && callback.call(this);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axPagination]').forEach(element => {
        new axPagination(element);
    });
})();
/*!
* 插件：可排序列表；使用方法：new axList('#id',{参数})；#id是可选参数，可以从该dom获取参数值
*/
class axList {
    constructor(targetDom, options) {
        this.targetDom = axIdToDom(targetDom);
        this.rawOptions = {
            names: '',
            inputDelay: 200,
            clickDelay: 200,
            paginationDom: null,
            maxCount: 10000,
            order: 'asc',
            operator: 'or',
            paginationShow: true,
            onUpdated: '',
            onInit: '',
            pagination: {
                current: 1, 
                count: 10, 
                data: [], 
                template: null, 
                async: '',
                ajaxType: 'post',
                loadingMode: 'overlay',
            }
        }
        this.options = axExtend(axClone(this.rawOptions), options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.rawData = [];
        this.preData = [];
        this.paginationDom = this.options.paginationDom ? axIdToDom(this.options.paginationDom) : this.targetDom.querySelector('.ax-pagination') || '';
        if (!this.options.pagination.template) {
            this.template = '';
        } else {
            if (this.options.pagination.template.trim().substr(0, 1) == '#') {
                this.template = document.querySelector(this.options.pagination.template).innerHTML
            } else {
                this.template = this.options.pagination.template;
            }
        }
        this.names = this.options.names.replace(/\s+/g, '').split(',');
        this.listDom = this.targetDom.querySelector('[list]');
        this.searchs = [...this.targetDom.querySelectorAll('[search]')];
        this.keywords = [...this.targetDom.querySelectorAll('[keyword]')];
        this.searchVal = '';
        this.sorts = [...this.targetDom.querySelectorAll('[sort]')];
        this.resets = [...this.targetDom.querySelectorAll('[reset]')];
        this.filters = [...this.targetDom.querySelectorAll('[filter]')];
        this.extends = [...this.targetDom.querySelectorAll('[extend]')];
        this.paginationOpt = {};
        this.pagination = null;
        this.init();
    }
    init() {
        let _this = this;
        this.setPaginationOpt();
        if (!axIsEmpty(this.listDom.childNodes)) {
            let data = [...this.listDom.childNodes].filter(item => item.nodeType == 1);
            this.getDomArr(data);
            this.paginationOpt.data = this.preData;
            this.renderFinish();
        } else if (axType(this.options.pagination.data) == 'String' && this.options.pagination.template) {
            if (this.options.pagination.async == 'json') {
                axAjax({
                    url: _this.options.pagination.data,
                    type: _this.options.pagination.ajaxType,
                    success: function (content) {
                        let data = [];
                        content.forEach(i => {
                            let item = axStrToDom(axTplEngine(_this.template, i));
                            data.push(item);
                        });
                        _this.getDomArr(data);
                        _this.paginationOpt.data = _this.preData;
                        _this.renderFinish();
                    }
                })
            } else if (this.options.pagination.async == 'sql') {
                if (!['relative', 'absolute', 'fixed'].includes(axStyle(this.listDom).position)) {
                    this.listDom.style.position = 'relative';
                }
                this.renderSqlFinish();
            }
        } else {
            this.preData = this.options.pagination.data;
            this.rawData = [...this.preData];
            this.paginationOpt.data = this.options.pagination.data;
            this.renderFinish();
        }
        this.options.onInit && this.options.onInit.call(this, this.pagination.current, this.pagination.pagesNum);
    }
    getDomArr(listData) {
        if (this.options.names) {
            listData.forEach(item => {
                let obj = { dom: item };
                this.names.forEach(i => {
                    item.querySelector('[' + i + ']') ? obj[i] = item.querySelector('[' + i + ']').innerText.trim() : null;
                })
                this.preData.push(obj);
            });
            this.rawData = [...this.preData];
            return true;
        } else {
            this.preData = listData;
            this.rawData = [...listData];
            return false;
        }
    }
    renderFinish() {
        this.pagination = new axPagination(this.paginationDom, this.paginationOpt);
        if (!this.options.paginationShow) {
            this.pagination.targetDom.remove();
            if (this.pagination.itemsNum > this.paginationOpt.count) {
                console.error('The maximum length cannot exceed ' + this.paginationOpt.count + '!');
                return false;
            }
        }
        this.loadExtend(false);
        this.loadSort(false);
        this.loadKeyword(false);
        this.loadSearch(false);
        this.loadFilter(false);
        this.loadReset(false);
    }
    setPaginationOpt() {
        this.paginationOpt = this.options.pagination;
        this.paginationOpt.listDom = this.listDom;
        this.paginationOpt.count = !this.options.paginationShow ? this.options.maxCount : this.paginationOpt.count;
        return this.paginationOpt;
    }
    renderSqlFinish() {
        this.pagination = new axPagination(this.paginationDom, this.paginationOpt);
        this.loadSort(true);
        this.loadFilter(true);
        this.loadExtend(true);
        this.loadKeyword(true);
        this.loadSearch(true);
        this.loadReset(true);
    }
    loadExtend(isSql) {
        let _this = this;
        if (this.extends.length !== 0) {
            this.extends.forEach(item => {
                let attr = item.getAttribute('extend');
                item.onclick = axDebounce(function () {
                    _this.extend(attr, isSql);
                }, this.options.clickDelay);
            });
        }
    }
    extend(str, isSql) {
        let _this = this;
        if (!isSql) {
            this.strSearch(str);
        } else {
            this.updateSql({ dataExtend: { extend: str } });
            this.pagination.on('rendered', function () {
                if (axIsEmpty(_this.pagination.preData)) {
                    _this.listDom.innerHTML = '';
                    _this.pagination.targetDom.innerHTML = '';
                }
            });
        }
    }
    loadKeyword(isSql) {
        let _this = this;
        if (this.keywords.length !== 0) {
            this.keywords.forEach(item => {
                let source = [..._this.preData],
                    attr = item.getAttribute('keyword').trim(),
                    operator = item.getAttribute('operator') ? item.getAttribute('operator').trim() : this.options.operator,
                    value = '',
                    arr = attr ? attr.split(',') : [],
                    names = arr.length !== 0 ? arr : this.names;
                if (item.hasAttribute('auto')) {
                    item.oninput = axDebounce(function () {
                        if (arr.length !== 0) {
                            let obj = {};
                            arr.forEach(i => {
                                obj[i] = this.value;
                            });
                            value = obj;
                        } else {
                            value = this.value;
                        }
                        if (!isSql) {
                            _this.keySearch(value, source, operator);
                        } else {
                            _this.sqlSearch(names, this.value, operator);
                        }
                    }, _this.options.inputDelay);
                }
            });
        }
    }
    loadFilter(isSql) {
        let _this = this;
        if (this.filters.length !== 0) {
            this.filters.forEach(item => {
                let data,
                    source = [..._this.preData],
                    operator = item.getAttribute('operator') ? item.getAttribute('operator').trim() : this.options.operator;
                if (!isSql) {
                    data = axAttrToJson(item, 'filter');
                } else {
                    data = item.getAttribute('filter');
                }
                item.onclick = axDebounce(function () {
                    _this.filter(data, source, operator, isSql);
                }, this.options.clickDelay);
            });
        }
    }
    filter(data, source, operator, isSql) {
        operator = operator ? operator : this.options.operator;
        source = source ? source : [...this.preData];
        if (!isSql) {
            this.keySearch(data, source, operator);
        } else {
            this.updateSql({ dataExtend: { filter: data } });
        }
    }
    loadSearch(isSql) {
        let _this = this;
        if (this.searchs.length !== 0) {
            this.searchs.forEach(item => {
                if (this.keywords.length == 0) {
                    return false;
                }
                let fieldName = item.getAttribute('field'),
                    fieldDom = this.keywords.filter(i => i.name == fieldName)[0],
                    searchNames = fieldDom.getAttribute('keyword'),
                    operator = fieldDom.getAttribute('operator') ? fieldDom.getAttribute('operator').trim() : this.options.operator,
                    source = [...this.preData];
                searchNames = searchNames ? searchNames.replace(/\s+/g, '').split(',') : this.names;
                item.onclick = axDebounce(function () {
                    _this.search(searchNames, fieldDom.value, source, operator, isSql);
                }, this.options.clickDelay);
                fieldDom.onkeyup = function (e) {
                    if (e.code === 'Enter') {
                        item.click();
                    }
                }
            });
        }
    }
    search(names, value, source, operator, isSql) {
        operator = operator ? operator : this.options.operator;
        if (!isSql) {
            let obj = {};
            source = source ? source : [...this.preData]; 
            names.forEach(i => {
                obj[i] = value;
            }); 
            this.keySearch(obj, source, operator);
        } else {
            this.sqlSearch(names, value, operator);
        }
    }
    loadSort(isSql) {
        let _this = this;
        if (this.sorts.length !== 0) {
            for (let x = 0, len = this.sorts.length; x < len; x++) {
                let item = this.sorts[x],
                    attr = item.getAttribute('sort').trim();
                if (!isSql) {
                    if (_this.names.every(i => i !== attr)) {
                        continue;
                    }
                }
                item.onclick = axDebounce(function () {
                    if (!isSql) {
                        if (this.getAttribute('order') == 'desc') {
                            this.setAttribute('order', 'asc');
                            _this.sort(attr, 'asc', false);
                        } else if (this.getAttribute('order') == 'asc') {
                            this.setAttribute('order', 'desc');
                            _this.sort(attr, 'desc', false);
                        } else {
                            this.setAttribute('order', _this.options.order);
                            _this.sort(attr, _this.options.order, false);
                        }
                    } else {
                        _this.sort(attr, '', true);
                        if (!attr.includes(',')) {
                            if (attr.includes('desc')) {
                                item.setAttribute('order', 'desc');
                                attr = attr.replace('desc', 'asc');
                            } else if (attr.includes('asc')) {
                                item.setAttribute('order', 'asc');
                                attr = attr.replace('asc', 'desc');
                            }
                        }
                    }
                    _this.sorts.filter(i => i != this).forEach(k => {
                        k.setAttribute('order', '');
                    });
                }, this.options.clickDelay);
            }
        }
    }
    sort(data, order, isSql) {
        if (!isSql) {
            this.preSort(data, order);
        } else {
            this.updateSql({ dataExtend: { sort: data } });
        }
    }
    preSort(name, order, callback) {
        let _this = this;
        if (order == 'desc') {
            this.preData.sort(function (a, b) {
                if (isNaN(a[name] - b[name])) {
                    return b[name].localeCompare(a[name], 'zh-CN-u-kf-lower');
                } else {
                    return b[name] - a[name];
                }
            })
        } else if (order == 'asc') {
            this.preData.sort(function (a, b) {
                if (isNaN(a[name] - b[name])) {
                    return a[name].localeCompare(b[name], 'zh-CN-u-kf-lower');
                } else {
                    return a[name] - b[name];
                }
            })
        } else {
            return false;
        }
        this.pagination.updateData(this.preData);
        'sorted' in this.handlers ? this.emit('sorted', _this.pagination.current, _this.pagination.pagesNum) : null;
        _this.options.onUpdated && _this.options.onUpdated.call(_this, _this.pagination.current, _this.pagination.pagesNum);
        callback && callback.call(this, this.preData, this.pagination.current);
        return this;
    }
    loadReset(isSql) {
        let _this = this;
        if (this.resets.length !== 0) {
            this.resets.forEach(item => {
                item.onclick = axDebounce(function () {
                    _this.reset(isSql);
                }, this.options.clickDelay);
            });
        }
    }
    reset(isSql) {
        if (!isSql) {
            this.preData = [...this.rawData];
            let obj = axClone(this.rawOptions.pagination);
            obj.data = this.preData;
            this.updatePages(obj);
        } else {
            this.updateSql({ dataExtend: '' });
        }
        this.sorts.forEach(i => {
            i.setAttribute('order', '');
        });
        this.keywords.forEach(i => {
            i.value = '';
        });
        'reset' in this.handlers ? this.emit('reset', '') : null;
        this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
    }
    keySearch(value, sourceArr, operator = this.options.operator, callback) {
        let filterArr = sourceArr.filter(i => {
            let values = [];
            if (typeof value == "object") {
                let flag = [];
                for (let k in value) {
                    flag.push(String(i[k]).includes(value[k]));
                }
                if (operator == 'or') {
                    return flag.some(k => k == true);
                } else if (operator == 'and') {
                    return flag.every(k => k == true);
                }
            } else {
                for (let k of this.names) {
                    values.push(i[k]);
                }
                return values.toString().includes(value);
            }
        });
        this.preData = filterArr;
        if (axIsEmpty(this.preData)) {
            'rendered' in this.handlers ? this.emit('rendered', this.pagination.current, this.pagination.pagesNum) : null;
            this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
            callback && callback.call(this, this.pagination.current, this.pagination.pagesNum);
            this.preData = [...this.rawData];
            this.listDom.innerHTML = '';
            this.pagination.targetDom.innerHTML = '';
            return false;
        } else {
            this.pagination.updateData(this.preData);
            'rendered' in this.handlers ? this.emit('rendered', this.pagination.current, this.pagination.pagesNum) : null;
            this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
            callback && callback.call(this, this.pagination.current, this.pagination.pagesNum);
        }
    }
    strSearch(str, callback) {
        this.preData = axStrToFilter(str, [...this.preData]);
        if (axIsEmpty(this.preData)) {
            'rendered' in this.handlers ? this.emit('rendered', this.pagination.current, this.pagination.pagesNum) : null;
            this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
            callback && callback.call(this, this.pagination.current, this.pagination.pagesNum);
            this.preData = [...this.rawData];
            this.listDom.innerHTML = '';
            this.pagination.targetDom.innerHTML = '';
            return false;
        } else {
            this.pagination.updateData(this.preData);
            'rendered' in this.handlers ? this.emit('rendered', this.pagination.current, this.pagination.pagesNum) : null;
            this.options.onUpdated && this.options.onUpdated.call(this, this.pagination.current, this.pagination.pagesNum);
            callback && callback.call(this, this.pagination.current, this.pagination.pagesNum);
        }
    }
    sqlSearch(names, value, operator) {
        let _this = this,
            dataString = '',
            last;
        operator = operator || this.options.operator;
        if (names.length == 0) {
            console.error('The length of names array cannot be greater than 0!')
            return false;
        }
        if (value) {
            names.forEach((i, index) => {
                last = names.length - 1 != index ? operator + ' ' : '';
                dataString += i + ' like "%" "' + value + '" %" ' + last;
            });
        }
        _this.pagination.options.dataExtend = '';
        _this.updatePages({ dataExtend: { search: dataString } });
        _this.pagination.on('rendered', function () {
            if (axIsEmpty(_this.pagination.preData)) {
                _this.listDom.innerHTML = '';
                _this.pagination.targetDom.innerHTML = '';
            }
        })
    }
    updateSql(extend, callback) {
        let _this = this;
        this.pagination.options.dataExtend = '';
        this.pagination.update(extend, '', function () {
            'updated' in _this.handlers ? _this.emit('updated', _this.pagination.current, _this.pagination.pagesNum) : null;
            _this.options.onUpdated && _this.options.onUpdated.call(_this, _this.pagination.current, _this.pagination.pagesNum);
        });
        callback && callback.call(_this, _this.pagination.current, _this.pagination.pagesNum);
        return this;
    }
    updatePages(setting, callback) {
        let _this = this,
            opt = axExtend(_this.options.pagination, setting);
        this.pagination.update(opt, '', function () {
            'updated' in _this.handlers ? _this.emit('updated', _this.pagination.current, _this.pagination.pagesNum) : null;
            _this.options.onUpdated && _this.options.onUpdated.call(_this, _this.pagination.current, _this.pagination.pagesNum);
        });
        callback && callback.call(_this, _this.pagination.current, _this.pagination.pagesNum);
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axList]').forEach(element => {
        new axList(element);
    });
})();
/*!a
 * 插件：灯箱画廊；使用方法：axLightbox('#id',{参数})
 */
const axLightboxs = [];
class axLightbox {
    constructor(options, elem) {
        this.options = axExtend({
            insName: '',
            src: '',
            gallery: true,
            download: false,
            autoplay: false,
            thumb: {
                show: false,
                placement: 'bottom',
                row: 1,
            },
            zoom: true,
            share: false,
            btnClass: 'ax-lightbox-open',
            index: 0,
            onInit: '',
            onShow: '',
            onShwon: '',
            onHide: '',
            onHidden: '',
            onUpdate: '',
            onDestroy: '',
        }, options, elem, this.constructor.name);
        let _this = this;
        this.handlers = {};
        this.data = [];
        this.closeArea = [];
        this.zoomIn = false;
        this.button = elem ? axIdToDom(elem) : null;
        this.shown = false;
        let subset = axInstance.data.find(i => i.instance === this);
        if (!subset) {
            axInstance.push(this, this.options.insName, 'lightbox');
        }
    }
    init() {
        let _this = this;
        this.destroyed = false;
        this.data = axCreateData(this.options.src, ['src', 'cover', 'caption', 'type'], ['media', 'cover', 'caption', 'type'], 'figure', ['', '', '', 'image'], function (data) {
            data.forEach(item => {
                if (!item.cover && item.type == 'image') {
                    item.cover = item.media;
                }
                item.cover = item.cover ? item.cover : axImage.imgNone;
            });
        });
        this.setAttribute();
        this.createBox();
        this.createSlide();
        if (this.data.length > 1) {
            this.prev = axStrToDom(`<span class="ax-prev ax-light"></span>`);
            this.next = axStrToDom(`<span class="ax-next ax-light"></span>`);
            this.swiper.appendChild(this.prev);
            this.swiper.appendChild(this.next);
        }
        let swiperOpt = {
            zoom: this.options.zoom,
            lazy: true,
            keyboard: true,
            mousewheel: true,
            initialSlide: this.options.index || 0,
            pagination: {
                el: this.options.gallery ? this.targetDom.querySelector('.ax-pages') : null,
                type: "fraction",
            },
            thumbs: {
                swiper: '',
            },
            on: {
                touchStart: function (swiper, event) {
                    swiper.el.classList.add('ax-grabbing');
                },
                touchEnd: function (swiper, event) {
                    swiper.el.classList.remove('ax-grabbing');
                },
                zoomChange: function (swiper, scale) {
                    if (scale > 1) {
                        _this.zoomIn = true;
                    } else {
                        setTimeout(function () {
                            _this.zoomIn = false;
                        }, 100)
                    }
                },
            },
        }
        let thumbOpt = {
            lazy: true,
            spaceBetween: 4,
            slidesPerView: "auto",
            mousewheel: true,
            grid: {
                rows: this.options.thumb.row,
            },
            watchSlidesProgress: true,
        }
        if (this.options.gallery && this.options.thumb) {
            this.stage.insertAdjacentElement('afterend', this.createThumb());
            this.insThumb = new axSwiper(this.thumb.querySelector('.ax-swiper'), thumbOpt);
            swiperOpt.thumbs.swiper = this.insThumb;
            this.btnList.onclick = function () {
                _this.targetDom.classList.toggle('ax-thumb-hide');
            }
        }
        if (!this.options.thumb.show) {
            this.targetDom.classList.add('ax-thumb-hide');
        }
        if (this.options.autoplay) {
            swiperOpt.autoplay = {
                delay: 5000,
                stopOnLastSlide: false,
                disableOnInteraction: true,
            }
        }
        this.insSwiper = new axSwiper(this.swiper, swiperOpt);
        document.body.appendChild(this.targetDom);
        if (this.data.length > 1 && this.options.thumb.row && this.options.thumb.row > 1) {
            this.thumb.querySelector('.ax-swiper').style.height = axHeight(this.thumb.querySelector('.ax-slide'), 'outer') * this.options.thumb.row + thumbOpt.spaceBetween * (this.options.thumb.row - 1) + 'px';
        }
        if (!this.options.gallery) {
            this.insSwiper.disable();
        }
        axPreventScroll(this.targetDom);
        this.targetDom.querySelectorAll('[close]').forEach(elem => {
            elem.addEventListener('click', function () {
                _this.hide();
            }, false);
        });
        if (this.options.zoom) {
            this.btnZoom.onclick = function () {
                if (this.classList.contains('ax-icon-zoomin')) {
                    _this.insSwiper.zoom.in();
                } else {
                    _this.insSwiper.zoom.out();
                }
            }
        }
        /*     if (this.options.list && this.thumb) {
                this.btnList.onclick = function () {
                    _this.targetDom.classList.toggle('ax-thumb-hide');
                }
            } */
        if (this.options.download) {
            if (this.data[this.insSwiper.activeIndex].type != 'image') {
                this.btnDownload.href = '###';
                this.btnDownload.classList.add('ax-disabled');
                this.btnDownload.removeAttribute('download');
                this.btnDownload.removeAttribute('target');
            } else {
                this.btnDownload.href = this.data[this.insSwiper.activeIndex].media;
                this.btnDownload.classList.remove('ax-disabled');
                this.btnDownload.setAttribute('download', '');
                this.btnDownload.setAttribute('target', '_blank');
            }
        }
        if (this.options.zoom) {
            if (this.data[this.insSwiper.activeIndex].type != 'image') {
                this.btnZoom.classList.add('ax-disabled');
                this.insSwiper.zoom.disable();
            } else {
                this.btnZoom.classList.remove('ax-disabled');
                this.insSwiper.zoom.enable();
            }
        }
        if (this.options.share) {
            if (this.data[this.insSwiper.activeIndex].type != 'image') {
                this.btnShare.classList.add('ax-disabled');
            } else {
                this.btnShare.classList.remove('ax-disabled');
            }
        }
        this.insSwiper.on('slideChangeTransitionEnd', function () {
            if (_this.options.download) {
                if (_this.data[this.activeIndex].type != 'image') {
                    _this.btnDownload.href = '###';
                    _this.btnDownload.classList.add('ax-disabled');
                    _this.btnDownload.removeAttribute('download');
                    _this.btnDownload.removeAttribute('target');
                } else {
                    _this.btnDownload.href = _this.data[this.activeIndex].media;
                    _this.btnDownload.classList.remove('ax-disabled');
                    _this.btnDownload.setAttribute('download', '');
                    _this.btnDownload.setAttribute('target', '_blank');
                }
            }
            if (_this.options.zoom) {
                if (_this.data[this.activeIndex].type != 'image') {
                    _this.btnZoom.classList.add('ax-disabled');
                    _this.insSwiper.zoom.disable();
                } else {
                    _this.btnZoom.classList.remove('ax-disabled');
                    _this.btnZoom.classList.remove('ax-icon-zoomout');
                    _this.btnZoom.classList.add('ax-icon-zoomin');
                    _this.insSwiper.zoom.enable();
                }
            }
            if (_this.options.share) {
                if (_this.data[this.activeIndex].type != 'image') {
                    _this.btnShare.classList.add('ax-disabled');
                } else {
                    _this.btnShare.classList.remove('ax-disabled');
                }
            }
            _this.targetDom.querySelectorAll('video,audio').forEach(elem => {
                elem.pause();
            });
            _this.zoomIn = false;
        })
        this.insSwiper.on('zoomChange', function (ins, scale) {
            if (scale > 1) {
                _this.btnZoom.classList.remove('ax-icon-zoomin');
                _this.btnZoom.classList.add('ax-icon-zoomout');
            } else {
                _this.btnZoom.classList.remove('ax-icon-zoomout');
                _this.btnZoom.classList.add('ax-icon-zoomin');
            }
        })
        this.options.onInit && this.options.onInit.call(this);
        'init' in this.handlers ? this.emit('init', '') : null;
        return this;
    }
    overlayClose(ev) {
        this.closeArea = [];
        let _this = this;
        let booPrev = true,
            booNext = true,
            booThumb = true;
        if (_this.prev) {
            booPrev = axIsOutside(ev, _this.prev);
        }
        _this.closeArea.push(booPrev);
        if (_this.next) {
            booNext = axIsOutside(ev, _this.next)
        }
        _this.closeArea.push(booNext);
        if (_this.options.thumb) {
            booThumb = axIsOutside(ev, _this.thumb);
        } else {
            booThumb = true;
        }
        _this.closeArea.push(booThumb);
        _this.swiperWrapper.querySelectorAll('.ax-media').forEach(item => {
            let dom = item.firstElementChild;
            _this.closeArea.push(axIsOutside(ev, dom));
        })
        if (_this.swiperWrapper.querySelectorAll('.ax-caption')) {
            _this.swiperWrapper.querySelectorAll('.ax-caption').forEach(item => {
                _this.closeArea.push(axIsOutside(ev, item));
            })
        }
        _this.closeArea.push(axIsOutside(ev, _this.operate));
        _this.closeArea.push(axIsOutside(ev, _this.pages));
        return this.closeArea;
    }
    createSlide() {
        let slideTpl = (src, type) => {
            if (type && type == 'video') {
                return `
                <div class="ax-slide">
                    <div class="ax-media">
                        <video controls><source src="${src}"></video>
                    </div>
                </div>
                `
            } else if (type && type == 'audio') {
                return `
                <div class="ax-slide">
                    <div class="ax-media">
                        <audio controls><source src="${src}" ></audio>
                    </div>
                </div>
                `
            } else if (type && type == 'iframe') {
                return `
                <div class="ax-slide">
                    <div class="ax-media">
                        <iframe src="${src}" frameborder="0" width="100%" height="100%"></iframe>
                    </div>
                </div>
                `
            } else if (type && type == 'text') {
                if (src.substr(0, 1) == "#") {
                    src = document.querySelector(src).innerHTML;
                }
                return `
                <div class="ax-slide">
                    <div class="ax-media">
                        <div class="ax-text">${src}</div>
                    </div>
                </div>
                `
            } else {
                return `
                <div class="ax-slide">
                    <div class="ax-media ax-zoom">
                        <img data-src="${src}" class="ax-lazy" />
                        <span class="ax-loading ax-white"><i></i></span>
                    </div>
                </div>
                `
            }
        }
        this.data.forEach(item => {
            let slide = null,
                caption = null;
            slide = axStrToDom(slideTpl(item.media, item.type));
            caption = item.caption ? axStrToDom(`<div class="ax-caption">${item.caption}</div>`) : null;
            caption ? slide.appendChild(caption) : null;
            this.swiperWrapper.appendChild(slide);
        })
    }
    createThumb() {
        this.thumb = axStrToDom('<div class="ax-thumb"><div class="ax-swiper"><div class="ax-wrapper"></div></div></div>');
        this.thumbWrapper = this.thumb.querySelector('.ax-wrapper');
        this.data.forEach(item => {
            let slide = axStrToDom(`
            <div class="ax-slide">
                <img data-src="${item.cover}" class="ax-lazy" />
                <span class="ax-loading ax-white"><i></i></span>
            </div>
            `);
            this.thumbWrapper.appendChild(slide);
        })
        return this.thumb;
    }
    createBox() {
        let boxTpl = `
        <div class="ax-lightbox" id="${axCreateId('lightbox')}">
        <div class="ax-overlay"></div>
        <div class="ax-tools">
            <div class="ax-pages"></div>
            <div class="ax-operate"><i class="ax-iconfont ax-icon-close" close></i></div>
        </div>
        <div class="ax-stage">
            <div class="ax-swiper">
                <div class="ax-wrapper">
                </div>
            </div>
        </div>
    </div>
      `;
        this.targetDom = axStrToDom(boxTpl);
        this.tools = this.targetDom.querySelector('.ax-tools');
        this.pages = this.targetDom.querySelector('.ax-pages');
        this.operate = this.targetDom.querySelector('.ax-operate');
        this.stage = this.targetDom.querySelector('.ax-stage');
        this.swiper = this.stage.querySelector('.ax-swiper');
        this.swiperWrapper = this.swiper.querySelector('.ax-wrapper');
        this.createBtn();
    }
    createBtn() {
        this.btnShare = axStrToDom('<i class="ax-iconfont ax-icon-share-f" share></i>');
        this.btnDownload = axStrToDom('<a href="###" class="ax-iconfont ax-icon-download" target="_blank" download></a>');
        this.btnZoom = axStrToDom('<i class="ax-iconfont ax-icon-zoomin" zoom></i>');
        this.btnList = axStrToDom('<i class="ax-iconfont ax-icon-list" list></i>');
        this.options.thumb ? this.operate.insertAdjacentElement('afterbegin', this.btnList) : null;
        this.options.download ? this.operate.insertAdjacentElement('afterbegin', this.btnDownload) : null;
        this.options.zoom ? this.operate.insertAdjacentElement('afterbegin', this.btnZoom) : null;
        this.options.share ? this.operate.insertAdjacentElement('afterbegin', this.btnShare) : null;
    }
    setAttribute() {
        for (let i = 0, len = this.data.length; i < len; i++) {
            if (this.data[i].hasOwnProperty('type') && (['iframe', 'video', 'text'].includes(this.data[i].type))) {
                this.options.thumb = false;
            }
            break;
        }
        if (this.data.length < 2) {
            this.options.thumb == false;
        }
    }
    update(setting, callback) {
        if (this.destroyed) {
            return this;
        }
        let _this = this;
        this.options = axExtend(this.options, setting);
        this.init();
        this.options.onUpdate && this.options.onUpdate.call(this);
        'update' in this.handlers ? this.emit('update', '') : null;
        callback && callback.call(this);
        return this;
    }
    show(callback) {
        if (this.destroyed || this.shown) {
            return this;
        }
        let _this = this;
        this.options.onShow && this.options.onShow.call(this);
        'show' in this.handlers ? this.emit('show', '') : null;
        this.targetDom.style.visibility = 'visible';
        this.targetDom.classList.add('ax-show');
        this.button ? this.button.classList.add(this.options.btnClass) : null;
        callback && callback.call(this);
        this.options.onShown && this.options.onShown.call(this);
        'shown' in this.handlers ? this.emit('shown', '') : null;
        _this.targetDom.onclick = function (ev) {
            _this.overlayClose(ev);
            let closeArea = _this.closeArea.includes(false);
            if (!closeArea && !_this.zoomIn) {
                _this.hide();
            }
        }
        this.shown = true;
        return this;
    }
    hide(callback) {
        if (this.destroyed || !this.shown) {
            return this;
        }
        let _this = this;
        this.options.onHide && this.options.onHide.call(this);
        'hide' in this.handlers ? this.emit('hide', '') : null;
        this.button ? this.button.classList.remove(this.options.btnClass) : null;
        this.targetDom.classList.remove('ax-show');
        /*         setTimeout(function () {
                    _this.targetDom.remove();
                }, parseFloat(axStyle(_this.targetDom).transitionDuration) * 1000 * 2)
                 */
        _this.targetDom.addEventListener('transitionend', function () {
            _this.targetDom.remove();
        }, false)
        this.shown = false;
        this.targetDom.querySelectorAll('video,audio').forEach(elem => {
            elem.pause();
        });
        callback && callback.call(this);
        this.options.onHidden && this.options.onHidden.call(this);
        'hidden' in this.handlers ? this.emit('hidden', '') : null;
        return this;
    }
    destroy() {
        this.targetDom.remove();
        callback && callback.call(this);
        this.options.onDestroy && this.options.onDestroy.call(this);
        'destroy' in this.handlers ? this.emit('destroy', '') : null;
        this.destroyed = true;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    let getSource = (element) => {
        let elem = axIdToDom(element),
            obj = [{}],
            node = elem.nodeName;
        if (node == 'A') {
            if (elem.hasAttribute('href') && elem.getAttribute('href').indexOf('##') == -1) {
                obj[0].media = elem.getAttribute('href');
                obj[0].cover = elem.getAttribute('href');
            }
        } else if (node == 'IMG') {
            if (elem.hasAttribute('src')) {
                obj[0].media = elem.getAttribute('src');
                obj[0].cover = elem.getAttribute('src');
            }
        }
        if (elem.hasAttribute('type')) {
            obj[0].type = elem.getAttribute('type');
        } else {
            obj[0].type = 'image';
        }
        if (elem.hasAttribute('title')) {
            obj[0].caption = elem.getAttribute('title');
        } else if (elem.hasAttribute('alt')) {
            obj[0].caption = elem.getAttribute('alt');
        } else {
            obj[0].caption = '';
        }
        return obj;
    }
    let datas = [];
    let btns = [...document.querySelectorAll('[axLightbox]')].filter(i => i.getAttribute('axLightbox').includes('insName')),
        names = {};
    for (let i = 0, len = btns.length; i < len; i++) {
        let item = btns[i],
            name = axAttrToJson(item, 'axLightbox').insName;
        if (!name) {
            continue;
        }
        if (!names.hasOwnProperty(name)) {
            names[name] = [item];
        } else {
            names[name].push(item);
        }
    }
    for (let i in names) {
        let index = 0;
        names[i].forEach(k => {
            k.slideIndex = index;
            let data = [],
                src = axAttrToJson(k, 'axLightbox').src;
            if (src) {
                data = axCreateData(src, ['src', 'cover', 'caption', 'type'], 'figure', ['media', 'cover', 'caption', 'type'], ['', '', '', 'image'], function (data) {
                    data.forEach(item => {
                        if (!item.cover && item.type == 'image') {
                            item.cover = item.media
                        }
                        item.cover = item.cover ? item.cover : axImage.imgNone;
                    });
                });
            } else {
                data = getSource(k);
            }
            index += data.length;
            if (axIsEmpty(datas)) {
                datas.push({ name: i, data: data });
            } else {
                datas.forEach(item => {
                    if (item.name == i) {
                        item.data.push(...data);
                    }
                })
                if (!datas.some(item => (item.name == i))) {
                    datas.push({ name: i, data: data });
                }
            }
        });
    }
    datas.forEach(item => {
        new axLightbox({
            insName: item.name,
            src: item.data,
        });
    });
    document.querySelectorAll('[axLightbox]').forEach((element) => {
        let attr = axAttrToJson(element, 'axLightbox'),
            name = attr.insName;
        if (name) {
            let ins = axInstance.find(name, 'lightbox');
            element.onclick = (ev) => {
                axPreventDefault(ev);
                if (ins) {
                    ins.init();
                    ins.insSwiper.slideTo(element.slideIndex, 0);
                    ins.show();
                }
            }
        } else {
            if (attr.src) {
                element.onclick = (ev) => {
                    axPreventDefault(ev);
                    new axLightbox('', element).init().show();
                }
            } else {
                element.onclick = (ev) => {
                    axPreventDefault(ev);
                    new axLightbox({
                        src: getSource(element),
                    }).init().show();
                }
            }
        }
    });
})();
/*!
* 插件：网页媒体懒加载；使用方法：new axLazyload('#id',{参数})
*/
class axLazyload {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            type: 'single', 
            offset: '0px', 
            visible: [0, 0.5, 1], 
            parent: null,
            animation: 'ax-fadeIn',
            dataName: 'src',
        }, options, this.targetDom,'axLazyload');
        this.handlers = {};
        this.items = [];
        this.init();
    }
    init() {
        if (this.options.type != 'single' && !this.targetDom.classList.contains('ax-lazyload')) {
            this.targetDom.classList.add('ax-lazyload');
        }
        this.interactOpt();
        this.active();
    }
    active() {
        if (this.options.type == 'single') {
            this.mediaInteract();
            this.items.push(this.targetDom);
            this.mediaInteract().observe(this.targetDom);
        } else if (this.options.type == 'multiple') {
            this.mediaInteract();
            this.items = [...this.targetDom.querySelectorAll('[data-' + this.options.dataName + ']')];
            this.items.forEach(i => {
                this.mediaInteract().observe(i);
            });
        }
    }
    interactOpt() {
        this.offset = this.options.offset.replace(/\s*/g, "").split(",");
        if (this.offset.length == 1) {
            this.offset.push(...this.offset)
        } else if (offset.length > 2) {
            this.offset.splice(0, 2);
        }
        return {
            root: this.options.parent,
            rootMargin: this.offset[0] + ' 0px ' + this.offset[1] + ' 0px',
            threshold: this.options.visible,
        }
    }
    mediaInteract() {
        let interact = new IntersectionObserver(entries => {
            entries.forEach(i => {
                if (i.isIntersecting) {
                    if (i.target.hasAttribute('data-' + this.options.dataName)) {
                        i.target.classList.add(this.options.animation);
                        if (i.target.nodeName == 'VIDEO' || i.target.nodeName == 'AUDIO') {
                            i.target.src = i.target.dataset[this.options.dataName];
                            i.target.querySelector('source').setAttribute('src', i.target.dataset[this.options.dataName]);
                        } else {
                            i.target.setAttribute('src', i.target.dataset[this.options.dataName]);
                        }
                        i.target.removeAttribute('data-' + this.options.dataName);
                        interact.unobserve(i.target);
                        'shown' in this.handlers ? this.emit('shown', i.target) : null;
                    }
                }
            });
        }, this.interactOpt());
        return interact;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axLazyload]').forEach(element => {
        new axLazyload(element, { type: 'multiple' });
    });
    document.querySelectorAll('[lazyload]').forEach(element => {
        new axLazyload(element);
    });
})();
/*!
* 插件：列表异步无限滚动；使用方法：new axInfinite('#id',{参数})
*/
class axInfinite {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            type: 'list', 
            offset: '0px', 
            visible: [0], 
            url: '', 
            urlMax: 20,
            data: [], 
            template: null, 
            selector: '',
            trigger: 'scroll',
            parent: null,
            animation: 'ax-fadeIn',
            start: 0,
            count: 10, 
            finishText: '没有更多内容了',
            nextBtn: '<button class="ax-btn ax-btn-primary ax-longer">查看更多</button>',
            ajaxType:'post',
            active:'',
        }, options, this.targetDom,'axInfinite');
        this.handlers = {};
        this.start = this.options.start;
        this.data = this.options.data;
        this.loadStatus = this.targetDom.querySelector('.ax-infinite-status') ? this.targetDom.querySelector('.ax-infinite-status') : axAddElem('div', { class: 'ax-infinite-status' });
        this.loadingDiv = axAddElem('div', { class: 'ax-infinite-loading' }, '<span class="ax-loading"><i></i></span>');
        this.resultDiv = axAddElem('div', { class: 'ax-infinite-tips' });
        this.nextDiv = axAddElem('div', { class: 'ax-infinite-next' }, this.options.nextBtn);
        this.nextButton = this.nextDiv.firstElementChild;
        this.loadStatus.insertAdjacentElement('afterbegin', this.loadingDiv);
        this.loadStatus.appendChild(this.resultDiv);
        this.url = [];
        if (typeof this.options.url == 'string') {
            if (this.options.url.indexOf('{') > 0 && this.options.url.indexOf('}') > 0) {
                let pageStart = ~~this.options.url.match(/\{(\S*)\}/)[1],
                    str = `{${pageStart}}`;
                for (let i = pageStart; i <= pageStart + this.options.urlMax; i++) {
                    this.url.push(this.options.url.replace(str, i));
                }
            } else if (this.options.url == 'pagination') {
                let pages = this.loadStatus.querySelectorAll('[data-page]');
                [...pages].forEach(i => {
                    this.url.push(i.href);
                });
            } else {
                this.options.url ? this.url = [this.options.url] : null;
            }
        } else if (axType(this.options.url) == 'Array') {
            this.url = this.options.url;
        }
        if (!this.options.template) {
            this.template = '';
        } else {
            if (this.options.template.trim().substr(0, 1) == '#') {
                this.template = document.querySelector(this.options.template).innerHTML
            } else {
                this.template = this.options.template;
            }
        }
        this.items = [];
        this.init();
    }
    init() {
        let _this = this;
        if (this.options.type != 'image' && !this.targetDom.classList.contains('ax-infinite')) {
            this.targetDom.classList.add('ax-infinite');
        }
        this.interactOpt();
        if (this.options.trigger == 'scroll') {
            this.active();
        } else if (this.options.trigger == 'clicks') {
            this.loadStatus.appendChild(this.nextDiv);
            this.loadStatus.setAttribute('preloading', '');
            this.targetDom.appendChild(this.loadStatus);
            this.nextButton.onclick = function () {
                _this.loadStatus.removeAttribute('preloading', '');
                _this.loadStatus.removeAttribute('loaded', '');
                _this.loadStatus.setAttribute('loading', '');
                if (_this.options.type == 'pages') {
                    _this.pageAjax(_this.start);
                } else if (_this.options.url && _this.options.template) {
                    if (_this.options.type == 'json') {
                        _this.jsonAjax(_this.start);
                    } else if (_this.options.type == 'sql') {
                        _this.sqlAjax(_this.start, _this.options.count);
                    }
                }
            }
        }
    }
    active(url, callback) {
        let _this = this;
        if (!axIsEmpty(url)) {
            if (axType(url) == 'Array') {
                this.url.push(...url)
            } else {
                this.url.push(url);
            }
        }
        if (this.options.type == 'pages') {
            this.asyncInteract(function () {
                _this.pageAjax(_this.start);
            });
        } else if (!axIsEmpty(this.url) && this.options.template) {
            if (this.options.type == 'json') {
                this.asyncInteract(function () {
                    _this.jsonAjax(_this.start);
                });
            } else if (this.options.type == 'sql') {
                this.asyncInteract(function () {
                    _this.sqlAjax(_this.start, _this.options.count);
                });
            }
        } else if (this.options.type == 'list') {
            if (!axIsEmpty(this.data)) {
                this.renderList(this.data);
            }
            let children = [...this.targetDom.childNodes].filter(i => i.nodeType == 1);
            children.forEach(i => {
                if (axOffset(i).top > window.innerHeight) {
                    i.setAttribute('infinite', '');
                    this.items.push(i);
                }
            });
            this.listInteract();
            this.items.forEach(i => {
                this.listInteract().observe(i);
            });
        }
        callback && callback.call(this);
        this.options.active && this.options.active.call(this);
        'activated' in this.handlers ? this.emit('activated','') : null;
    }
    interactOpt() {
        this.offset = this.options.offset.replace(/\s*/g, "").split(",");
        if (this.offset.length == 1) {
            this.offset.push(...this.offset)
        } else if (offset.length > 2) {
            this.offset.splice(0, 2);
        }
        return {
            root: this.options.parent,
            rootMargin: this.offset[0] + ' 0px ' + this.offset[1] + ' 0px',
            threshold: this.options.visible,
        }
    }
    listInteract() {
        let interact = new IntersectionObserver(entries => {
            entries.forEach(i => {
                if (i.isIntersecting) {
                    if (i.target.hasAttribute('infinite')) {
                        i.target.classList.add(this.options.animation);
                        i.target.removeAttribute('infinite');
                        interact.unobserve(i.target);
                    }
                    'shown' in this.handlers ? this.emit('shown', i.target) : null;
                }
            });
        }, this.interactOpt());
        return interact;
    }
    asyncInteract(callback) {
        this.targetDom.appendChild(this.loadStatus);
        this.asyncObserver = new IntersectionObserver(entries => {
            if (entries[0].isIntersecting) {
                callback();
            }
        }, this.interactOpt());
        this.asyncObserver.observe(this.loadStatus);
    }
    itemInteract() {
        let interact = new IntersectionObserver(entries => {
            entries.forEach(i => {
                if (i.isIntersecting) {
                    if (i.target.hasAttribute('infinite')) {
                        i.target.classList.add(this.options.animation);
                        i.target.removeAttribute('infinite');
                        interact.unobserve(i.target);
                    'shown' in this.handlers ? this.emit('shown', i.target) : null;
                    }
                }
            });
        }, this.interactOpt());
        return interact;
    }
    renderList(data) {
        let fragment = document.createDocumentFragment();
        data.forEach(i => {
            let item = axStrToDom(axTplEngine(this.template, i));
            item.setAttribute('infinite', '');
            this.items.push(item);
            fragment.appendChild(item);
        });
        this.targetDom.appendChild(fragment);
        !this.options.type == 'list' ? this.targetDom.appendChild(this.loadStatus) : null;
    }
    loadFinish() {
        this.options.trigger != 'clicks' ? this.asyncObserver.disconnect() : null;
        this.loadStatus.removeAttribute('loading');
        this.loadStatus.removeAttribute('loaded');
        this.loadStatus.setAttribute('finish', '');
        this.loadingDiv ? this.loadingDiv.remove() : null;
        this.nextDiv ? this.nextDiv.remove() : null;
        this.resultDiv.innerHTML = this.options.finishText;
        'finished' in this.handlers ? this.emit('finished', '') : null;
    }
    pageAjax(urlStart) {
        let _this = this;
        axAjax({
            url: _this.url[urlStart],
            type:_this.options.ajaxType,
            selector: _this.options.selector,
            error: function (data, state) {
                console.error(`发生错误：${state}，可能是地址错误！`);
                _this.loadFinish();
            },
            success: function (content) {
                _this.targetDom.insertAdjacentHTML('beforeEnd', content);
                _this.targetDom.appendChild(_this.loadStatus);
                if (_this.options.trigger == 'clicks') {
                    _this.loadStatus.removeAttribute('loading', '');
                    _this.loadStatus.setAttribute('loaded', '');
                }
                'loaded' in _this.handlers ? _this.emit('loaded', content) : null;
                _this.start++;
                if (_this.start >= _this.url.length) {
                    _this.loadFinish();
                }
            }
        });
    }
    jsonAjax(urlStart) {
        let _this = this;
        axAjax({
            url: _this.url[urlStart],
            type:_this.options.ajaxType,
            error: function (data, state) {
                console.error(`发生错误：${state}，可能是地址错误！`);
                _this.loadFinish();
            },
            success: function (content) {
                _this.itemInteract();
                _this.renderList(content);
                _this.targetDom.appendChild(_this.loadStatus);
                if (_this.options.trigger == 'clicks') {
                    _this.loadStatus.removeAttribute('loading', '');
                    _this.loadStatus.setAttribute('loaded', '');
                }
                _this.items.forEach(i => {
                    _this.itemInteract().observe(i);
                });
                'loaded' in _this.handlers ? _this.emit('loaded', content) : null;
                _this.start++;
                if (_this.start >= _this.url.length) {
                    _this.loadFinish();
                }
            }
        });
    }
    sqlAjax(sqlStart, sqlCount) {
        let _this = this;
        axAjax({
            url: _this.options.url,
            type:_this.options.ajaxType,
            data: { start: sqlStart, count: sqlCount },
            error: function (data, state) {
                console.error(`发生错误：${state}，可能是地址错误！`);
                _this.loadFinish();
            },
            success: function (content) {
                _this.itemInteract();
                _this.renderList(content.data);
                _this.targetDom.appendChild(_this.loadStatus);
                if (_this.options.trigger == 'clicks') {
                    _this.loadStatus.removeAttribute('loading', '');
                    _this.loadStatus.setAttribute('loaded', '');
                }
                _this.items.forEach(i => {
                    _this.itemInteract().observe(i);
                });
                'loaded' in _this.handlers ? _this.emit('loaded', content.data) : null;
                _this.start += sqlCount;
                if (_this.start >= content.total) {
                    _this.loadFinish();
                }
            }
        });
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axInfinite]').forEach(element => {
        new axInfinite(element);
    });
})();
/*!
* 插件：进度条；使用方法：new axProgress('#id',{参数})
*/
class axProgress {
    constructor(elem, options) {
        this.targetDom = axIdToDom(elem);
        this.options = axExtend({
            type: 'line', 
            color: '',
            gradient: false,
            linecap: 'round',
            size: '',
            range: [0, 100],
            value: 0,
            duration: '',
            rotate: false,
            trackShow: true,
            labelFormat: '',
            labelShow: true,
            lablePlace: '',
            labelText: {
                unit: '%',
                tips: '当前进度',
                complete: '完成!',
            },
            started: '',
            completed: '',
            processing: '',
        }, options, this.targetDom,'axProgress');
        this.handlers = {};
        this.circleWidth = 251.2;
        this.semiWidth = 125.6;
        this.gapWidth = 167.6;
        let getValue;
        if (this.options.type == 'circle') {
            getValue = (this.circleWidth - ((this.options.value / this.options.range[1]) * this.circleWidth))
        } else if (this.options.type == 'semicircle') {
            getValue = (this.semiWidth - ((this.options.value / this.options.range[1]) * this.semiWidth));
        } else if (this.options.type == 'gapcircle') {
            getValue = (this.gapWidth - ((this.options.value / this.options.range[1]) * this.gapWidth));
        } else {
            getValue = Math.abs((this.options.value / (this.options.range[1] - this.options.range[0])) * 100);
        }
        this.trueValue = this.getDecimals(getValue);
        this.value = this.options.value;
        this.complete = this.value == this.options.range[1] ? true : false;
        this.completeDom = axAddElem('span', { complete: '' }, `${this.options.labelText.complete}`);
        this.init();
    }
    init() {
        let _this = this;
        this.getTrueValue(this.options.value);
        this.createHtml();
        this.setAttribute();
        this.hasComplete();
        this.options.started && this.options.started.call(this);
        'started' in this.handlers ? this.emit('started', '') : null;
    }
    hasComplete() {
        if (this.complete) {
            this.targetDom.setAttribute('complete', 'true');
            this.labelDom ? this.labelDom.appendChild(this.completeDom) : null;
            this.options.completed && this.options.completed.call(this);
            'completed' in this.handlers ? this.emit('completed', '') : null;
        } else {
            this.targetDom.removeAttribute('complete');
        }
    }
    createAnimation() {
        let dftTime = width => width * 3 + 200;
        let time;
        if (this.options.duration !== undefined && typeof this.options.duration === 'number') {
            time = this.options.duration;
        } else {
            time = dftTime(Math.abs(this.barDiffer));
        }
        let initTime = new Date().getTime();
        let repeat = () => {
            if (this.complete) {
                this.complete = false;
                this.hasComplete();
            }
            let newTime = new Date().getTime() - initTime,
                timestep = newTime / time,
                timefactor = axCurves.easeOut(timestep),
                valueStep = this.lastValue + this.valueDiffer * timefactor,
                barStep = this.lastTrueValue + this.barDiffer * timefactor;
            if (newTime <= time) {
                let value = this.getDecimals(valueStep),
                    trueValue = this.getDecimals(barStep);
                if (this.options.type == 'line') {
                    this.bar.style.width = trueValue + '%';
                } else {
                    this.bar.setAttribute('stroke-dashoffset', trueValue);
                }
                this.progressDom ? this.progressDom.innerText = Math.trunc(valueStep) : null;
                this.options.processing && this.options.processing.call(this, value, trueValue);
                'processing' in this.handlers ? this.emit('processing', value, trueValue) : null;
            } else {
                if (this.options.type == 'line') {
                    this.bar.style.width = this.trueValue + '%';
                } else {
                    this.bar.setAttribute('stroke-dashoffset', this.trueValue);
                }
                this.progressDom ? this.progressDom.innerText = this.value : null;
                this.complete = this.value >= this.options.range[1] ? true : false;
            }
            let repeatLoop = requestAnimationFrame(repeat);
            if (newTime > time) {
                cancelAnimationFrame(repeatLoop);
                this.hasComplete();
                if (this.value <= 0) {
                    this.options.started && this.options.started.call(this);
                    'started' in this.handlers ? this.emit('started', '') : null;
                }
            }
        };
        repeat();
    }
    getDecimals(num) {
        return Math.floor(num * 100) / 100;
    }
    getTrueValue(val) {
        if (val < this.options.range[0]) {
            val = this.options.range[0];
        } else if (val > this.options.range[1]) {
            val = this.options.range[1];
        }
        this.valueDiffer = val - this.value;
        this.lastValue = this.value;
        this.value = val;
        if (this.options.type == 'circle') {
            this.barDiffer = (this.circleWidth - ((val / this.options.range[1]) * this.circleWidth)) - this.trueValue;
            this.lastTrueValue = this.trueValue;
            this.trueValue = (this.circleWidth - ((val / this.options.range[1]) * this.circleWidth));
            this.trueValue > this.circleWidth ? this.trueValue = this.circleWidth : this.trueValue = this.getDecimals(this.trueValue);
        } else if (this.options.type == 'semicircle') {
            this.barDiffer = (this.semiWidth - ((val / this.options.range[1]) * this.semiWidth)) - this.trueValue;
            this.lastTrueValue = this.trueValue;
            this.trueValue = (this.semiWidth - ((val / this.options.range[1]) * this.semiWidth));
            this.trueValue > this.semiWidth ? this.trueValue = this.semiWidth : this.trueValue = this.getDecimals(this.trueValue);
        }else if (this.options.type == 'gapcircle') {
            this.barDiffer = (this.gapWidth - ((val / this.options.range[1]) * this.gapWidth)) - this.trueValue;
            this.lastTrueValue = this.trueValue;
            this.trueValue = (this.gapWidth - ((val / this.options.range[1]) * this.gapWidth));
            this.trueValue > this.gapWidth ? this.trueValue = this.gapWidth : this.trueValue = this.getDecimals(this.trueValue);
        } else if (this.options.type == 'line') {
            this.barDiffer = Math.abs((val / (this.options.range[1] - this.options.range[0])) * 100) - this.trueValue;
            this.lastTrueValue = this.trueValue;
            this.trueValue = Math.abs((val / (this.options.range[1] - this.options.range[0])) * 100);
            this.trueValue > 100 ? this.trueValue = 100 : this.trueValue = this.getDecimals(this.trueValue);
        }
    }
    setAttribute() {
        this.targetDom.setAttribute('linecap', this.options.linecap);
        this.targetDom.setAttribute('type', this.options.type);
        this.options.size ? this.targetDom.setAttribute('size', this.options.size) : null;
        this.options.color ? this.targetDom.setAttribute('color', this.options.color) : null;
        this.options.gradient ? this.targetDom.setAttribute('gradient', '') : null;
        !this.options.trackShow ? this.targetDom.setAttribute('track', 'false') : null;
        if (this.options.rotate) {
            this.wrapper.classList.add('ax-rotate360');
            this.wrapper.style.animationIterationCount = 'infinite';
        }
    }
    createHtml() {
        let svg;
        if (this.options.type == 'line') {
            this.wrapper = axAddElem('div', { 'track': '' });
            this.bar = axAddElem('div', { 'bar': '', 'style': `width:${this.trueValue}%` });
            this.labelFormat = this.options.labelFormat ? this.options.labelFormat : `<span label><i progress></i><i unit></i></span>`;
        } else {
            this.labelFormat = this.options.labelFormat ? this.options.labelFormat : `<div label><div tips></div><div result><i progress></i><i unit></i></div></div>`;
            let gradient = '';
            if (this.options.gradient) {
                if (this.options.color == 'primary') {
                    gradient = `
                <linearGradient id="svgbar-primary" >
                    <stop offset="0%" style="stop-color:var(--color-primary);" ></stop>
                    <stop offset="100%" style="stop-color:var(--color-primary-like);" ></stop>
                </linearGradient>
              `;
                } else if (this.options.color == 'secondary') {
                    gradient = `
                <linearGradient id="svgbar-secondary" >
                    <stop offset="0%" style="stop-color:var(--color-secondary);" ></stop>
                    <stop offset="100%" style="stop-color:var(--color-secondary-like);" ></stop>
                </linearGradient>
              `;
                } else if (this.options.color == 'danger') {
                    gradient = `
                <linearGradient id="svgbar-danger" >
                    <stop offset="0%" style="stop-color:var(--color-danger);" ></stop>
                    <stop offset="100%" style="stop-color:var(--color-danger-like);" ></stop>
                </linearGradient>
              `;
                } else if (this.options.color == 'success') {
                    gradient = `
                <linearGradient id="svgbar-success" >
                    <stop offset="0%" style="stop-color:var(--color-success);" ></stop>
                    <stop offset="100%" style="stop-color:var(--color-success-like);" ></stop>
                </linearGradient>
              `;
                } else if (this.options.color == 'warning') {
                    gradient = `
            <linearGradient id="svgbar-warning" >
                <stop offset="0%" style="stop-color:var(--color-warning);" ></stop>
                <stop offset="100%" style="stop-color:var(--color-warning-like);" ></stop>
            </linearGradient>
          `;
                } else if (this.options.color == 'info') {
                    gradient = `
                <linearGradient id="svgbar-info" >
                    <stop offset="0%" style="stop-color:var(--color-info);" ></stop>
                    <stop offset="100%" style="stop-color:var(--color-info-like);" ></stop>
                </linearGradient>
              `;
                } else if (this.options.color == 'ad') {
                    gradient = `
                <linearGradient id="svgbar-ad" >
                    <stop offset="0%" style="stop-color:var(--color-ad);" ></stop>
                    <stop offset="100%" style="stop-color:var(--color-ad-like);"></stop>
                </linearGradient>
              `;
                }
            }
            if (this.options.type == 'circle') {
                svg = `<svg viewBox="0 0 100 100">
                            ${gradient}
                            ${this.options.trackShow ? '<path d="M 50 50 m -40 0 a 40 40 0 1 1 80 0  a 40 40 0 1 1 -80 0" track></path>' : ''}
                            <path d="M 50 50 m -40 0 a 40 40 0 1 1 80 0  a 40 40 0 1 1 -80 0" bar stroke-dasharray=${this.circleWidth} stroke-linecap=${this.options.linecap}  stroke-dashoffset=${this.trueValue}></path>
                       </svg>
                        `;
            } else if (this.options.type == 'semicircle') {
                svg = `<svg viewBox="0 0 100 60">
                            ${gradient}
                            ${this.options.trackShow ? `<path d="M 50 50 m -40 0 a 40 40 0 1 1 80 0" track stroke-linecap=${this.options.linecap}></path>` : ''}
                            <path d="M 50 50 m -40 0 a 40 40 0 1 1 80 0" bar stroke-dasharray=${this.semiWidth} stroke-linecap=${this.options.linecap} stroke-dashoffset=${this.trueValue}></path>
                       </svg>
                        `;
            }
            else if (this.options.type == 'gapcircle') {
                svg = `<svg viewBox="0 0 100 80">
                            ${gradient}
                            ${this.options.trackShow ? `<path d="M15.367,70.026C11.954,64.137,10,57.296,10,49.999 C10,27.909,27.909,10,50,10c22.092,0,40,17.909,40,39.999c0,7.295-1.952,14.134-5.363,20.022" track stroke-linecap=${this.options.linecap}></path>` : ''}
                            <path d="M15.367,70.026C11.954,64.137,10,57.296,10,49.999 C10,27.909,27.909,10,50,10c22.092,0,40,17.909,40,39.999c0,7.295-1.952,14.134-5.363,20.022" bar stroke-dasharray=${this.gapWidth} stroke-linecap=${this.options.linecap} stroke-dashoffset=${this.trueValue}></path>
                       </svg>
                        `;
            }
        }
        if (this.options.labelShow) {
            if (!this.options.labelPlace) {
                this.targetDom.insertAdjacentHTML('beforeEnd', this.labelFormat);
                this.labelDom = this.targetDom.querySelector('[label]');
            } else {
                let place = axIdToDom(this.options.labelPlace);
                place.insertAdjacentHTML('beforeEnd', this.labelFormat);
                this.labelDom = place.querySelector('[label]');
            }
            this.progressDom = this.labelDom.querySelector('[progress]');
            this.unitDom = this.labelDom.querySelector('[unit]');
            this.tipsDom = this.labelDom.querySelector('[tips]');
            this.progressDom ? this.progressDom.innerHTML = this.value : null;
            this.unitDom ? this.unitDom.innerHTML = this.options.labelText.unit : null;
            this.tipsDom ? this.tipsDom.innerHTML = this.options.labelText.tips : null;
        }
        if (this.options.type == 'line') {
            this.wrapper.appendChild(this.bar);
            this.targetDom.insertAdjacentElement('afterBegin', this.wrapper);
        } else {
            this.targetDom.insertAdjacentHTML('afterBegin', svg);
            this.wrapper = this.targetDom.querySelector('svg');
            this.bar = this.wrapper.querySelector('[bar]');
            this.track = this.wrapper.querySelector('[track]');
        }
    }
    set(val, callback) {
        this.getTrueValue(val);
        if (this.value == this.lastValue) {
            return false;
        }
        this.createAnimation();
        callback && callback.call(this);
        'seted' in this.handlers ? this.emit('seted', this.value, this.trueValue) : null;
        return this;
    }
    get() {
        return {
            value: this.value,
            trueValue: this.trueValue,
            lastValue: this.lastValue,
            lastTrueValue: this.lastTrueValue,
            complete: this.complete
        };
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axProgress]').forEach(element => {
        new axProgress(element);
    });
})();
/*!
 * 插件：创建单行文本域和多行文本域；使用方法：new axInput('#id',{参数})
 * text、textarea、hidden、url、tel、search、email、color、number、range、month、week、date、time、datetime、datetime-local
 * submit、reset和button特别，通过value设定名称
 * radio和checkbox请使用axCheckbox组件
 */
class axInput {
    constructor(elem, options) {
        this.targetDom = elem ? axIdToDom(elem) : '';
        this.options = axExtend({
            type: 'text', 
            name: '', 
            value: '', 
            limit: 0, 
            placeholder: '', 
            width: '', 
            height: '', 
            size: '', 
            className: '', 
            props: '', 
            toolsShow: true, 
            extend: '', 
            clearShow: false, 
            onClear: '', 
            onSet: '', 
            onReset: '', 
            onInit: '', 
            onExceed: '', 
            onInput: '', 
        }, options, this.targetDom, 'axInput');
        this.handlers = {};
        this.output = { name: this.options.name };
        this.createElem();
        this.setAttribute();
        this.addExtend(this.options.extend);
    }
    createElem() {
        let getField = () => {
            if (this.options.type == 'textarea') {
                this.field = axAddElem('textarea', { name: this.options.name, placeholder: this.options.placeholder });
            } else if (this.options.type == 'button') {
                this.field = axAddElem('button', '', this.options.value);
            } else {
                this.field = axAddElem('input', { type: this.options.type, name: this.options.name, placeholder: this.options.placeholder });
            }
        }
        if (this.targetDom) {
            if (this.targetDom.nodeName == 'INPUT' || this.targetDom.nodeName == 'TEXTAREA' || this.targetDom.nodeName == 'BUTTON') {
                this.parent = this.targetDom.parentElement;
                this.field = this.targetDom;
            } else {
                this.parent = this.targetDom;
                getField();
            }
        } else {
            this.parent = axAddElem('div', { class: 'ax-form-wrapper' });
            getField();
        }
        this.parent.appendChild(this.field);
        if (this.parent.querySelector('.ax-pos-right')) {
            this.tools = this.parent.querySelector('.ax-pos-right');
        } else {
            this.tools = axAddElem('span', { class: "ax-pos-right" });
        }
        if (this.tools.querySelector('[clear]')) {
            this.clearBtn = this.tools.querySelector('[clear]');
        } else {
            this.clearBtn = axAddElem('a', { href: '###', class: "ax-iconfont ax-icon-close", clear: '' });
            if (this.options.clearShow) {
                this.tools.appendChild(this.clearBtn);
            }
        }
        if (this.clearBtn) {
            this.clearBtn.onclick = () => {
                this.clear();
            }
        }
        this.options.toolsShow ? this.parent.appendChild(this.tools) : null;
        if (this.options.limit) {
            this.limit = axAddElem('div', { class: "ax-form-limit" }, `已输入<i have>0</i>个字符,还可以输入<i remainder>${this.options.limit}</i>个字`);
            let have = this.limit.querySelector('[have]'),
                remainder = this.limit.querySelector('[remainder]');
            this.parent.appendChild(this.limit);
            this.field.oninput = () => {
                let obj = this.intercept(this.field.value);
                this.field.value = obj.text;
                have ? have.innerHTML = obj.have : null;
                remainder ? remainder.innerHTML = obj.remainder : null;
                this.options.onInput && this.options.onInput.call(this, this.output);
                'input' in this.handlers ? this.emit('input', this.output) : null;
            }
        }
        this.options.value ? this.set(this.options.value) : null;
        this.output.dom = this.field;
        this.output.parent = this.parent;
        this.output.type = this.options.type;
        this.options.onInit && this.options.onInit.call(this, this.output);
    }
    setAttribute() {
        this.options.className ? this.field.setAttribute('class', this.options.className) : null;
        this.options.width ? this.field.style.width = this.options.width : null;
        this.options.height ? this.field.style.height = this.options.height : null;
        this.options.size ? this.field.classList.add(`ax-${this.options.size}`) : null;
        for (let i in this.options.props) {
            this.field.setAttribute(i, this.options.props[i]);
        }
    }
    addExtend(data) {
        if (!this.options.toolsShow) {
            return false;
        }
        let render = (obj) => {
            let btn = axAddElem(obj.node || 'a', { class: obj.icon }, obj.text);
            btn.setAttribute(obj.name, '');
            if (obj.props) {
                for (let i in obj.props) {
                    this.field.setAttribute(i, obj.props[i]);
                }
            }
            this.tools.appendChild(btn);
            obj.callback && obj.callback.call(this, btn, this.field);
        }
        if (Array.isArray(data)) {
            data.forEach(i => {
                render(i);
            });
        } else {
            render(data);
        }
    }
    intercept(text) {
        let len = text.length,
            obj = {};
        if (len >= this.options.limit && this.options.limit) {
            obj = { text: text.substring(0, this.options.limit), have: this.options.limit, remainder: 0 }
            this.limit ? this.limit.classList.add('ax-color-danger') : null;
            this.options.onExceed && this.options.onExceed.call(this, this.output);
            'exceed' in this.handlers ? this.emit('exceed', this.output) : null;
        } else {
            this.limit ? this.limit.classList.remove('ax-color-danger') : null;
            obj = { text: text, have: text.length, remainder: Math.abs(this.options.limit - len) }
        }
        return obj;
    }
    set(str, callback) {
        if(Array.isArray(str)){
            str = JSON.stringify(str[0]);
        }else if(typeof str != 'string'){
            str = JSON.stringify(str);
        }
        let text = str.replace(/<[^>]+>/g, '').trim(),
            obj = this.intercept(text);
        this.field.value = obj.text;
        if (this.limit) {
            this.limit.querySelector('[have]') ? this.limit.querySelector('[have]').innerHTML = obj.have : null;
            this.limit.querySelector('[remainder]') ? this.limit.querySelector('[remainder]').innerHTML = obj.remainder : null;
        }
        this.output.value = this.field.value;
        callback && callback.call(this, this.field, obj.text, obj.remainder);
        this.options.onSet && this.options.onSet.call(this, this.field, obj.text, obj.remainder);
        'set' in this.handlers ? this.emit('set', this.field, obj.text, obj.remainder) : null;
        return this;
    }
    getValues() {
        return this.field.value;
    }
    clear(callback) {
        this.set('');
        callback && callback.call(this, this.field);
        this.options.onClear && this.options.onClear.call(this, this.field);
        'clear' in this.handlers ? this.emit('clear', this.field) : null;
    }
    reset(callback){
        this.set(this.options.value);
        callback && callback.call(this, this.field);
        this.options.onReset && this.options.onReset.call(this, this.field);
        'reset' in this.handlers ? this.emit('reset', this.field) : null;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axInput]').forEach(element => {
        new axInput(element);
    });
})();
/*!
 * 插件：单选和多选文本域；使用方法：new axCheckbox('#id',{参数})
 */
class axCheckbox {
    constructor(elem, options) {
        this.targetDom = elem ? axIdToDom(elem) : '';
        this.options = axExtend({
            type: 'checkbox', 
            style: 'beautify', 
            name: '', 
            children: '', 
            /* [{
                checked: false, 
                disabled: false, 
                value: '', 
                label: '', 
                props: {}, 
                callback: '', 
            }],  */
            value: '', 
            limit: 0, 
            separator: ',', 
            size: '', 
            parentClass: '', 
            childClass: '',
            props: '', 
            display: '', 
            gap: '', 
            columns: 0, 
            clearShow: true, 
            onClear: '', 
            onSet: '', 
            onReset: '', 
            onAddChecked: '', 
            onExceed: '', 
            onInit: '', 
            onChange: '', 
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.output = { children: [] };
        this.getChildren();
        this.name = this.options.name;
        this.trueLimit = this.children.length <= this.options.limit ? this.children.length : this.options.limit;
        this.createParent();
        this.setAttribute();
        if (!axIsEmpty(this.options.value)) {
            this.set(this.options.value);
        }
    }
    getChildren() {
        if (Array.isArray(this.options.children)) {
            if (typeof this.options.children[0] === 'object') {
                this.options.children.forEach(i => {
                    if (!i.hasOwnProperty('value')) {
                        i.value = i.label;
                    }
                });
                this.children = this.options.children;
            } else {
                this.children = this.options.children.map(i => {
                    return { label: i, value: i };
                });
            }
        } else {
            if (typeof this.options.children === 'object') {
                if (!this.options.children.hasOwnProperty('value')) {
                    this.options.children.value = this.options.children.label;
                }
                this.children = [this.options.children];
            } else {
                this.children = [{ label: this.options.children, value: this.options.children }]
            }
        }
    }
    createParent() {
        if (!this.targetDom || this.targetDom.nodeName == 'INPUT') {
            this.parent = axAddElem('div', { class: 'ax-form-wrapper' });
            if (this.targetDom.nodeName == 'INPUT') {
                this.hidden = this.targetDom;
                this.hidden.insertAdjacentElement('beforeBegin', this.parent);
                this.name = this.targetDom.name;
                this.hidden.type != 'hidden' ? this.hidden.style.display = 'none' : null;
            }
        } else {
            this.parent = this.targetDom;
        }
        if (this.children.length > 0) {
            this.children.forEach(i => {
                this.createElem(i);
            });
        }
        let checkedDoms = this.output.children.filter(i => i.checked);
        for (let i = 0, len = checkedDoms.length; i < len; i++) {
            let item = checkedDoms[i],
                input = item.dom.querySelector('input');
            if (this.options.type == 'radio') {
                if (i > 0) {
                    item.checked = false;
                    break;
                } else {
                    input.setAttribute('checked', '');
                    item.checked = true;
                }
            } else if (this.options.type == 'checkbox') {
                if (i < this.trueLimit || !this.trueLimit) {
                    input.setAttribute('checked', '');
                    item.checked = true;
                } else {
                    item.checked = false;
                }
            }
        }
        if (this.options.limit) {
            this.limit = axAddElem('div', { class: "ax-form-limit" }, `已选择<i have>0</i>项,还可以选择<i remainder>${this.options.limit}</i>项`);
            this.resetLimit();
            this.parent.insertAdjacentElement('afterend', this.limit);
        }
        this.output.name = this.name;
        this.output.parent = this.parent;
        this.output.type = this.options.type;
        this.output.value = this.getValues();
        if (this.hidden) {
            this.hidden.value = this.getValues('string', this.options.separator);
        }
        this.output.children.forEach(i => {
            let input = i.dom.querySelector('input');
            input.onchange = () => {
                this.change(i);
            }
        });
        this.options.onInit && this.options.onInit.call(this, this.output);
    }
    createElem(obj) {
        let tpl = `<label class="ax-${this.options.style == 'beautify' ? this.options.type : this.options.style}"><input name="${this.name + '_ax_alt'}" value="${obj.value}" ${obj.disabled ? 'disabled' : ''} type="${this.options.type}"><u></u>${obj.label ? '<i>' + obj.label + '</i>' : ''}</label>`,
            elem = axStrToDom(axTplEngine(tpl, obj)),
            labelWrapper = axAddElem('div');
        if (this.options.childClass) {
            axClass.add(labelWrapper, this.options.childClass);
        }
        this.options.size ? elem.classList.add(`ax-${this.options.size}`) : null;
        for (let i in obj.props) {
            elem.setAttribute(i, obj.props[i]);
        }
        if (this.options.display == 'grid' || this.options.display == 'block') {
            labelWrapper.appendChild(elem);
            this.parent.appendChild(labelWrapper)
        } else {
            this.parent.appendChild(elem);
        }
        let item = { dom: elem, label: obj.label, value: obj.value, checked: obj.checked ? obj.checked : false, disabled: obj.disabled ? obj.disabled : false }
        this.output.children.push(item);
        obj.callback && obj.callback.call(this, item);
        return elem;
    }
    setAttribute() {
        if (this.options.parentClass) {
            axClass.add(this.parent, this.options.parentClass);
        }
        for (let i in this.options.props) {
            this.parent.setAttribute(i, this.options.props[i]);
        }
        if (this.options.display == 'grid') {
            this.parent.classList.add('ax-grid');
            if (this.options.columns) {
                this.parent.classList.add(`ax-grid-${this.options.columns}`);
            };
            if (this.options.gap) {
                this.parent.style.gridColumnGap = this.options.gap;
            }
        }
    }
    change(item) {
        let input = item.dom.querySelector('input'),
            value = item.value;
        if (!value) {
            return false;
        }
        if (input.checked) {
            if (this.options.type == 'radio') {
                let old = this.output.children.find(i => i.checked);
                old ? old.checked = false : null;
            }
            item.checked = true;
        } else {
            item.checked = false;
        }
        let checkedItems = this.output.children.filter(i => i.checked);
        if (this.trueLimit && checkedItems.length > this.trueLimit) {
            input.checked = false;
            item.checked = false;
        }
        this.output.value = this.getValues();
        if (this.hidden) {
            this.hidden.value = this.getValues('string', this.options.separator);
            this.hidden.onchange ? this.hidden.onchange() : null;
        }
        this.resetLimit();
        this.intercept();
        this.options.onChange && this.options.onChange.call(this, item);
        'change' in this.handlers ? this.emit('change', item) : null;
    }
    intercept() {
        let len = this.output.children.filter(i => i.checked).length,
            flag = false;
        if (!this.trueLimit) {
            return false;
        }
        if (len >= this.trueLimit) {
            flag = true;
            this.options.onExceed && this.options.onExceed.call(this, this.output);
            'exceed' in this.handlers ? this.emit('exceed', this.output) : null;
        } else {
            flag = false;
        }
        return flag;
    }
    resetLimit() {
        if (!this.trueLimit) {
            return false;
        }
        let len = this.output.children.filter(i => i.checked).length,
            have = this.limit.querySelector('[have]'),
            remainder = this.limit.querySelector('[remainder]');
        if (len >= this.trueLimit) {
            this.limit ? this.limit.classList.add('ax-color-danger') : null;
            have.innerHTML = this.trueLimit;
            remainder.innerHTML = 0;
        } else {
            this.limit ? this.limit.classList.remove('ax-color-danger') : null;
            have.innerHTML = len;
            remainder.innerHTML = this.trueLimit - len;
        }
    }
    set(data, callback) {
        if (this.options.type == 'radio') {
            let str = '';
            if (Array.isArray(data)) {
                str = data[0];
            } else {
                str = data;
            }
            let item, other;
            if (!str) {
                item = this.output.children.find(i => i.checked);
                if (item) {
                    item.checked = false;
                    item.dom.querySelector('input').checked = false;
                }
            } else {
                item = this.output.children.find(i => i.value == str);
                other = this.output.children.filter(i => i.value != str);
                if (item) {
                    item.checked = true;
                    item.dom.querySelector('input').checked = true;
                }
                other.forEach(i => {
                    i.checked = false;
                    i.dom.querySelector('input').checked = false;
                });
            }
        } else if (this.options.type == 'checkbox') {
            let arr;
            if (Array.isArray(data)) {
                arr = data;
            } else if (typeof data === 'string') {
                arr = data.split(this.options.separator);
            } else {
                arr = [data];
            }
            arr = arr.filter(Boolean);
            if (this.trueLimit && arr.length > this.trueLimit) {
                arr = arr.slice(0, this.trueLimit);
            }
            this.output.children.forEach(i => {
                let input = i.dom.querySelector('input');
                if (arr.includes(i.value)) {
                    i.checked = true;
                    input.checked = true;
                } else {
                    i.checked = false;
                    input.checked = false;
                }
            });
        }
        this.output.value = this.getValues();
        this.hidden ? this.hidden.value = this.getValues('string', this.options.separator) : null;
        this.resetLimit();
        callback && callback.call(this, this.output);
        this.options.onSet && this.options.onSet.call(this, this.output);
        'set' in this.handlers ? this.emit('set', this.output) : null;
        return this;
    }
    addChecked(data, callback) {
        if (this.options.type == 'radio') {
            console.error('Do not use this method of addChecked() in type of radio!');
            return false;
        }
        let trueData = [];
        if (Array.isArray(data)) {
            trueData = data;
        } else {
            trueData = [data];
        }
        trueData = trueData.filter(Boolean);
        for (let i = 0, len = trueData.length; i < len; i++) {
            if (this.intercept()) {
                break;
            }
            let item = trueData[i];
            let find = this.output.children.find(i => i.value == item);
            find.dom.querySelector('input').checked = true;
            find.checked = true;
            this.resetLimit();
        }
        this.output.value = this.getValues();
        this.hidden ? this.hidden.value = this.getValues('string', this.options.separator) : null;
        callback && callback.call(this, trueData, this.output);
        this.options.onAddChecked && this.options.onAddChecked.call(this, trueData, this.output);
        'addChecked' in this.handlers ? this.emit('addChecked', trueData, this.output) : null;
    }
    checkedAll(callback) {
        this.output.children.forEach(i => {
            i.dom.querySelector('input').checked = true;
            i.checked = true;
        });
        this.resetLimit();
        this.output.value = this.getValues();
        callback && callback.call(this, this.output);
        this.options.onCheckedAll && this.options.onCheckedAll.call(this, this.output);
        'checkedAll' in this.handlers ? this.emit('checkedAll', this.output) : null;
    }
    getValues(type, separator) {
        type = type || 'array';
        separator = separator || this.options.separator;
        let values = [];
        this.output.children.forEach(i => {
            if (i.checked) {
                if (type == 'json') {
                    values.push({ label: i.label, value: i.value });
                } else {
                    values.push(i.value);
                }
            }
        });
        if (type == 'string') {
            values = values.join(separator);
        }
        return values;
    }
    reset(callback) {
        let value;
        if (this.options.value) {
            value = this.options.value;
        } else {
            let checkedItem = this.options.children.filter(i => i.checked);
            value = [];
            checkedItem.forEach(i => {
                value.push(i.value);
            });
        }
        this.set(value);
        callback && callback.call(this, this.output);
        this.options.onReset && this.options.onReset.call(this, this.output);
        'reset' in this.handlers ? this.emit('reset', this.output) : null;
    }
    clear(callback) {
        this.output.children.forEach(i => {
            if (i.checked) {
                i.checked = false;
                i.dom.querySelector('input').checked = false;
            }
        });
        this.output.value = [];
        this.resetLimit();
        callback && callback.call(this, this.output);
        this.options.onClear && this.options.onClear.call(this, this.output);
        'clear' in this.handlers ? this.emit('clear', this.output) : null;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axCheckbox]').forEach(element => {
        new axCheckbox(element);
    });
})();
/*!
 * 插件：复选列表全选和取消全选；使用方法：new axCheckAll('#id',{参数})
 */
class axCheckAll {
    constructor(elem, options) {
        this.targetDom = elem ? axIdToDom(elem) : '';
        if (!this.targetDom) {
            return false;
        }
        this.options = axExtend({
            checkDom: '', 
            clearDom: '', 
            separator: ',', 
            includeDisabled: true,
            onInit: '', 
            onChecked: '', 
            onCheckAll: '', 
            onClearAll: '', 
        }, options, this.targetDom, this.constructor.name);
        this.handlers = {};
        this.checkDom = this.options.checkDom ? axIdToDom(this.options.checkDom) : '';
        this.clearDom = this.options.clearDom ? axIdToDom(this.options.clearDom) : '';
        this.list = [];
        this.listAvailable = [];
        this.toggleType = '';
        this.state = '';
        this.toggleBtns = [];
        this.name = '';
        this.init();
    }
    init() {
        this.getOptionsList();
        if (this.list.length === 0) {
            return false;
        }
        this.observeToggle();
        this.observeList();
        this.options.onInit && this.options.onInit.call(this);
        return this;
    }
    observeList() {
        this.setLinkage();
        this.listAvailable.forEach(i => {
            i.field.addEventListener('change', () => {
                this.setLinkage();
            }, false);
        });
    }
    observeToggle() {
        if (this.checkDom && this.checkDom.type === 'checkbox') {
            this.toggleType = 'checkbox';
            this.toggleBtns = [this.checkDom];
            if (this.checkDom.checked) {
                this.checkAll();
            }
            this.checkDom.addEventListener('change', () => {
                if (this.checkDom.checked) {
                    this.checkAll();
                } else {
                    this.clearAll();
                }
            }, false);
        } else if (this.checkDom && this.checkDom.type === 'radio') {
            this.toggleType = 'radio';
            this.toggleBtns = [...document.querySelectorAll(this.options.checkDom.replace('[', '[name='))];
            if (axMultiValues(this.options.checkDom, 'radio', 'string') == 1) {
                this.checkAll();
            }
            this.toggleBtns.forEach(i => {
                i.addEventListener('change', () => {
                    let value = axMultiValues(this.options.checkDom, 'radio', 'string');
                    if (value == 1) {
                        this.checkAll();
                    } else {
                        this.clearAll();
                    }
                }, false);
            });
        } else {
            this.toggleType = 'button';
            if (this.checkDom) {
                this.toggleBtns.push(this.checkDom);
                this.checkDom.onclick = () => {
                    this.checkAll();
                }
            }
            if (this.clearDom) {
                this.toggleBtns.push(this.clearDom);
                this.clearDom.onclick = () => {
                    this.clearAll();
                }
            }
        }
    }
    setLinkage() {
        let value = axMultiValues(this.name, 'checkbox', 'array');
        if (value.length === 0) {
            this.state = 'cleared';
            this.toggleBtns.forEach(i => {
                i.removeAttribute('checking');
            });
            if (this.checkDom && this.toggleType === 'checkbox') {
                this.checkDom.checked = false;
            } else if (this.toggleType = 'radio') {
                let radioChecked = this.toggleBtns.find(k => k.checked);
                if (radioChecked) {
                    radioChecked.checked = false;
                }
            }
            this.options.onClearAll && this.options.onClearAll.call(this);
            'clearAll' in this.handlers ? this.emit('clearAll', '') : null;
        } else if (value.length === this.listAvailable.length) {
            this.state = 'checked';
            this.toggleBtns.forEach(i => {
                i.removeAttribute('checking');
            });
            if (this.checkDom && this.toggleType === 'checkbox') {
                this.checkDom.checked = true;
            } else if (this.toggleType = 'radio') {
                let radio = this.toggleBtns.find(k => k.value == 1);
                if (radio) {
                    radio.checked = true;
                }
            }
            this.options.onCheckAll && this.options.onCheckAll.call(this);
            'checkAll' in this.handlers ? this.emit('checkAll', '') : null;
        } else {
            this.state = 'checking';
            if (this.checkDom && this.toggleType === 'checkbox') {
                this.checkDom.checked = false;
                this.checkDom.setAttribute('checking', '');
            } else if (this.toggleType = 'radio') {
                this.toggleBtns.forEach(i => {
                    i.checked ? i.checked = false : null;
                    i.value == 1 ? i.setAttribute('checking', '') : null;
                });
            }
        }
    }
    getOptionsList(all = this.options.includeDisabled) {
        [...this.targetDom.querySelectorAll('label')].forEach(i => {
            let field = i.querySelector('input');
            if (all) {
                this.list.push({ dom: i, field: field, name: field.name, value: field.value });
            } else {
                if (!i.field.disabled) {
                    this.list.push({ dom: i, field: field, name: field.name, value: field.value });
                }
            }
        });
        if (this.list.find(i => !i.name)) {
            console.error('Checkbox must have name attribute!');
        }
        if (this.list.some(i => i.name != this.list[0].name)) {
            console.error('All names need to be consistent!');
        }
        if (this.list.find(i => !i.value || !i.field.hasAttribute('value'))) {
            console.error('Checkbox must have a value!');
        }
        this.listAvailable = all ? this.list.filter(i => !i.field.disabled) : this.list;
        this.name = this.listAvailable[0].name;
        return this.list;
    }
    getValues(type, separator) {
        type = type || 'array';
        separator = separator || this.options.separator;
        let arr = this.list.filter(i => i.field.checked),
            valueArr = arr.map(i => i.field.value);
        if (type === 'string') {
            return valueArr.join(separator);
        } else if (type === 'array') {
            return valueArr;
        } else {
            return '';
        }
    }
    checked(values, callback) {
        let items = [];
        if (typeof values === 'string') {
            items = values.split(this.options.separator);
        } else if (Array.isArray(values)) {
            items = values;
        } else {
            return false;
        }
        items.forEach(i => {
            let item = this.list.find(k => k.value == i);
            item ? item.field.checked = true : null;
        });
        this.setLinkage();
        callback && callback.call(this, items);
        this.options.onChecked && this.options.onChecked.call(this, items);
        'checked' in this.handlers ? this.emit('checked', items) : null;
        return this;
    }
    checkAll(callback) {
        this.state = 'checked';
        this.list.forEach(i => {
            if (!i.field.disabled) {
                i.field.checked = true;
            }
        });
        this.toggleBtns.forEach(i => {
            i.removeAttribute('checking');
        });
        callback && callback.call(this);
        this.options.onCheckAll && this.options.onCheckAll.call(this);
        'checkAll' in this.handlers ? this.emit('checkAll', '') : null;
        return this;
    }
    clearAll(callback) {
        this.state = 'cleared';
        this.list.forEach(i => {
            if (i.field.checked) {
                i.field.checked = false;
            }
        });
        this.toggleBtns.forEach(i => {
            i.removeAttribute('checking');
        });
        callback && callback.call(this);
        this.options.onClearAll && this.options.onClearAll.call(this);
        'clearAll' in this.handlers ? this.emit('clearAll', '') : null;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
(() => {
    document.querySelectorAll('[axCheckAll]').forEach(element => {
        new axCheckAll(element);
    });
})();
/*!
 * 插件：创建表单；使用方法：new axForm([{}],'#id')
 */
class axForm {
    constructor(targetDom, obj) {
        this.targetDom = targetDom ? axIdToDom(targetDom) : null;
        this.form;
        this.output = [];
        this.handlers = {};
        if (this.targetDom) {
            if (this.targetDom.nodeName == 'FORM') {
                this.form = this.targetDom;
            } else {
                this.form = axAddElem('form');
                this.targetDom.appendChild(this.form);
            }
        } else {
            this.form = axAddElem('form');
        }
        this.init(obj);
    }
    init(obj) {
        this.setAttribute(obj);
        obj.rows.forEach(i => {
            this.createSection(i, obj.style);
        });
        obj.onInit && obj.onInit.call(this, this.output);
        return this;
    }
    createTpl(obj, style) {
        let title = '',
            separate = '',
            props = '';
        if (obj.title && obj.title.show) {
            if (obj.title.html) {
                title = obj.title.html;
            } else {
                title = `<div class="ax-form-label${obj.title.className ? ' ' + obj.title.className : ''}">${obj.title.text ? obj.title.text : ''}</div>`;
            }
        }
        if (style == 'emulate') {
            separate = `<div class="ax-break-line"></div>`;
        } else if (style == 'fit') {
            separate = `<div class="ax-break ax-hide-tel"></div><div class="ax-break-line ax-hide-pad ax-hide-pc"></div>`;
        } else {
            separate = `<div class="ax-break"></div>`;
        }
        if (!axIsEmpty(obj.props)) {
            for (let i in obj.props) {
                props += ` ${i}="${obj.props[i]}" `;
            }
        }
        return `
                    <section${props}>
                    ${obj.before || ''}
                        <div class="ax-form-group">
                            <div class="ax-flex-row">
                                ${title}
                                <div class="ax-form-con">
                                    <div class="ax-form-input"></div>
                                </div>
                                ${obj.tools ? obj.tools : ''}
                            </div>
                        </div>
                        ${obj.after || ''}
                        ${separate}
                    </section >
                    `;
    }
    setAttribute(obj) {
        if (obj.style == 'emulate') {
            this.form.classList.add('ax-emulate');
        } else if (obj.style == 'fit') {
            this.form.classList.add('ax-fit-tel');
        }
        obj.className ? this.form.classList.add(obj.className) : null;
        if (!axIsEmpty(obj.props)) {
            for (let i in obj.props) {
                this.form.setAttribute(i, obj.props[i])
            }
        }
    }
    createCols(cols, parent, display, columns, gap, callback) {
        cols.forEach(i => {
            let colDiv, field;
            if (display == 'grid') {
                parent.classList.add('ax-grid');
                colDiv = axAddElem('div');
                columns ? parent.classList.add('ax-grid-' + columns) : null;
                parent.style.gridGap = gap;
                field = colDiv;
                parent.appendChild(colDiv);
                callback(i, colDiv);
            } else if (display == 'flex') {
                parent.classList.add('ax-row');
                colDiv = axAddElem('div', { class: 'ax-col' });
                field = colDiv;
                parent.appendChild(colDiv);
                callback(i, colDiv);
            } else {
                colDiv = parent;
                field = callback(i, colDiv);
            }
            i.prefix ? field.insertAdjacentHTML('beforebegin', i.prefix) : null;
            i.suffix ? field.insertAdjacentHTML('afterend', i.suffix) : null;
        });
    };
    createSection(obj, style) {
        let section = axStrToDom(this.createTpl(obj, style)),
            wrapper = section.querySelector('.ax-form-input');
        if (axIsEmpty(obj.cols)) {
            this.createItem(obj, wrapper);
        } else {
            this.createCols(obj.cols, wrapper, obj.display, obj.columns, obj.gap, (item, parent) => {
                return this.createItem(item, parent);
            });
        }
        this.form.appendChild(section);
    }
    createItem(obj, parent) {
        let field,
            item = {};
        if (obj.type == 'select') {
            field = axAddElem('select', { name: obj.name || '', ...obj.props });
            if (obj.className) {
                field.setAttribute('class', obj.className);
            }
            parent.appendChild(field);
            if (obj.options && obj.options.length > 0) {
                obj.options.forEach(i => {
                    let opt = axAddElem('option', { value: i.value || '' }, i.label);
                    i.checked ? opt.setAttribute('selected', '') : null;
                    i.disabled ? opt.setAttribute('disabled', '') : null;
                    field.appendChild(opt);
                    i.callback && i.callback.call(this, opt, i);
                });
            }
        } else if (obj.type == 'radio') {
            for (let i in obj.props) {
                parent.setAttribute(i, obj.props[i]);
            }
            if (obj.className) {
                parent.setAttribute('class', obj.className);
            }
            field = [];
            this.createCols(obj.options, parent, obj.display, obj.columns, obj.gap, (i, p) => {
                let item = axAddElem('input', { type: 'radio', name: obj.name || '', value: i.value || '' }),
                    label = axAddElem('label', { class: 'ax-radio' }, `<u></u><i> ${i.label}</i>`);
                i.checked ? item.checked = true : null;
                i.disabled ? item.disabled = true : null;
                label.insertAdjacentElement('afterBegin', item);
                p.appendChild(label);
                field.push(item);
                return label;
            });
        } else if (obj.type == 'checkbox') {
            for (let i in obj.props) {
                parent.setAttribute(i, obj.props[i]);
            }
            if (obj.className) {
                parent.setAttribute('class', obj.className);
            }
            field = [];
            this.createCols(obj.options, parent, obj.display, obj.columns, obj.gap, (i, p) => {
                let item = axAddElem('input', { type: 'checkbox', name: obj.name || '', value: i.value || '' }),
                    label = axAddElem('label', { class: 'ax-checkbox' }, `<u></u><i> ${i.label}</i>`);
                i.checked ? item.checked = true : null;
                i.disabled ? item.disabled = true : null;
                label.insertAdjacentElement('afterBegin', item);
                p.appendChild(label);
                field.push(item);
                return label;
            });
        } else if (obj.type == 'html') {
            field = axAddElem('div', obj.props, obj.value || '');
            if (obj.className) {
                field.setAttribute('class', obj.className);
            }
            parent.appendChild(field);
        } else if (obj.type == 'a') {
            field = axAddElem('a', obj.props, obj.value || '');
            if (obj.className) {
                field.setAttribute('class', obj.className);
            }
            parent.appendChild(field);
        } else if (obj.type == 'button') {
            field = axAddElem('button', obj.props, obj.value || '');
            if (obj.className) {
                field.setAttribute('class', obj.className);
            }
            parent.appendChild(field);
        } else if (obj.type == 'textarea') {
            field = axAddElem('textarea', { name: obj.name || '', value: obj.value || '', ...obj.props });
            obj.readonly ?  field.readonly = true : null;
            obj.disabled ?  field.disabled = true : null;
            if (obj.className) {
                field.setAttribute('class', obj.className);
            }
            obj.placeholder ? field.setAttribute('placeholder',obj.placeholder) : null;
            parent.appendChild(field);
        } else {
            field = axAddElem('input', { type: obj.type, name: obj.name || '', value: obj.value || '', ...obj.props });
            obj.readonly ?  field.readonly = true : null;
            obj.disabled ?  field.disabled = true : null;
            if (obj.className) {
                field.setAttribute('class', obj.className);
            }
            obj.placeholder ? field.setAttribute('placeholder',obj.placeholder) : null;
            parent.appendChild(field);
        }
        item.name = obj.name || '';
        item.value = obj.value || '';
        item.field = field;
        item.parent = parent;
        this.output.push(item);
        obj.callback && obj.callback.call(this, item);
        return field;
    }
    get(type = 'string', separator = ',') {
        let inputs = [];
        this.output.forEach(i => {
            inputs.push(i.field);
        });
        inputs = inputs.flat(2).filter(i => ['INPUT', 'SELECT', 'TEXTAREA'].includes(i.nodeName) && i.name);
        return axSerialize(inputs, type, separator);
    }
    update(obj, callback) {
        this.form.innerHTML = '';
        this.output = [];
        this.init(obj);
         obj.onUpdate && obj.onUpdate.call(this, this.output);
        callback && callback.call(this, this.output);
        'updated' in this.handlers ? this.emit('updated', this.output) : null;
        return this;
    }
    on(type, handler) {
        axAddPlan(type, handler, this);
        return this;
    }
    emit(type, ...params) {
        axExePlan(type, this, ...params);
    }
    off(type, handler) {
        axDelPlan(type, handler, this);
        return this;
    }
}
/*!
*项目所需的立即执行的代码片段，避免污染全局变量
*/
(() => {
    'use strict';
    let postLefts = document.querySelectorAll('.ax-pos-left');
    for (let i = 0; i < postLefts.length; i++) {
        let _this = postLefts[i];
        if (_this.nextElementSibling.nodeName == 'INPUT' || _this.nextElementSibling.nodeName == 'TEXTAREA') {
            _this.nextElementSibling.style.paddingLeft = `${axWidth(_this, 'outer')}px`;
        }
    }
    window.addEventListener('resize', () => {
        for (let i = 0; i < postLefts.length; i++) {
            let _this = postLefts[i];
            if (_this.nextElementSibling.nodeName == 'INPUT' || _this.nextElementSibling.nodeName == 'TEXTAREA') {
                _this.nextElementSibling.style.paddingLeft = `${axWidth(_this, 'outer')}px`;
            }
        }
    }, false);
    let postRights = document.querySelectorAll('.ax-pos-right .ax-val-none');
    for (let i = 0; i < postRights.length; i++) {
        let _this = postRights[i];
        if (_this) {
            _this.addEventListener('click', function () {
                let elem = this.parentElement.previousElementSibling;
                if (elem.nodeName == 'INPUT' || elem.nodeName == 'TEXTAREA') {
                    elem.value = '';
                }
            }, false);
        }
    }
    let panels = document.querySelectorAll('.ax-panel');
    for (let i = 0; i < panels.length; i++) {
        let _this = panels[i],
            header = axChildren(_this, '.ax-panel-header')[0],
            body = axChildren(_this, '.ax-panel-body')[0],
            close = header ? header.querySelector('.ax-panel-close') : null;
        if (close) {
            close.addEventListener('click', function () {
                if (getComputedStyle(body).display == 'none' || getComputedStyle(body).height == '0px') {
                    this.classList.remove('ax-deg180');
                    axSlideDown(body);
                } else {
                    this.classList.add('ax-deg180');
                    axSlideUp(body);
                }
            }, false);
        }
    }
    let boxes = document.querySelectorAll('.ax-box');
    for (let i = 0; i < boxes.length; i++) {
        let _this = boxes[i],
            header = axChildren(_this, '.ax-box-header')[0],
            body = axChildren(_this, '.ax-box-body')[0],
            close = header ? header.querySelector('.ax-box-close') : null;
        if (!axChildren(header, '.ax-des')) {
            header.classList.add('ax-simple');
        }
        if (close) {
            close.addEventListener('click', function () {
                if (getComputedStyle(body).display == 'none' || getComputedStyle(body).height == '0px') {
                    this.classList.remove('ax-deg180');
                    axSlideDown(body);
                } else {
                    this.classList.add('ax-deg180');
                    axSlideUp(body);
                }
            }, false);
        }
    }
    let backtops = document.querySelectorAll('.ax-backtop');
    for (let i = 0; i < backtops.length; i++) {
        let _this = backtops[i],
            children = axChildren(_this, '.ax-item');
        for (let k = 0; k < children.length; k++) {
            if (children[k]) {
                children[k].onmouseenter = function () {
                    this.classList.add('ax-active');
                    if (this.querySelector(".ax-text")) { axFadeIn(this.querySelector(".ax-text")); }
                }
                children[k].onmouseleave = function () {
                    this.classList.remove('ax-active');
                    if (this.querySelector(".ax-text")) { axFadeOut(this.querySelector(".ax-text")); }
                }
            }
        }
    }
    let totops = document.querySelectorAll('.ax-totop');
    for (let i = 0; i < totops.length; i++) {
        totops[i].addEventListener('click', function () {
            axScrollTo();
        }, false);
    }
    let ripples = document.querySelectorAll('.ax-ripple');
    for (let i = 0; i < ripples.length; i++) {
        let _this = ripples[i],
            width = axWidth(_this, 'inner'),
            height = axHeight(_this, 'inner'),
            size = Math.max(width, height);
        _this.addEventListener('click', function (e) {
            let x = e.clientX - (axOffset(this).left - document.documentElement.scrollLeft),
                y = e.clientY - (axOffset(this).top - document.documentElement.scrollTop),
                ripple = axAddElem('u', {
                    style: `left: ${x}px;top: ${y}px; width: ${size}px;height: ${size}px`,
                });
            _this.appendChild(ripple);
            setTimeout(() => {
                ripple.parentNode.removeChild(ripple);
            }, 800);
        }, false);
    }
    let axDodge = (targetDom, text) => {
        targetDom = axIdToDom(targetDom);
        let input = targetDom.querySelector("input,textarea");
        if (text) {
            targetDom.classList.add("ax-active");
            input.value = text;
        } else {
            targetDom.classList.remove("ax-active");
            input.value = text;
        }
        return targetDom;
    }
    window.axDodge = axDodge;
    let dodges = document.querySelectorAll('.ax-dodge');
    for (let i = 0; i < dodges.length; i++) {
        let _this = dodges[i],
            input = _this.querySelector("input,textarea"),
            placeholder = input.getAttribute("placeholder"),
            label = document.createElement("label");
        if (!placeholder) {
            label.innerHTML = "请输入...";
        } else {
            label.innerHTML = placeholder;
            input.setAttribute('placeholder', '');
        }
        _this.appendChild(label);
        input.onfocus = function () {
            _this.classList.add("ax-active");
        };
        input.onblur = function () {
            if (!this.value) {
                _this.classList.remove("ax-active");
            } else {
                _this.classList.add("ax-active");
            }
        };
        if (input.classList.contains("ax-lg")) {
            _this.classList.add("ax-lg");
        }
        label.onclick = function () {
            input.focus();
        };
    }
    window.addEventListener("scroll", () => {
        if (document.documentElement.scrollTop >= 400) {
            for (let i = 0; i < totops.length; i++) {
                if (totops[i].querySelector('a')) {
                    totops[i].querySelector('a').classList.add('ax-show');
                }
            }
        } else {
            for (let i = 0; i < totops.length; i++) {
                if (totops[i].querySelector('a')) {
                    totops[i].querySelector('a').classList.remove('ax-show');
                }
            }
        }
    }, false);
})();
